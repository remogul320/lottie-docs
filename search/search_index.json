{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":".index-page { margin-top: 36px; margin-bottom: 200px; } .index-page a:hover{ color: #00C1A2; text-decoration: none; } .index-card-header { display: flex; flex-direction: row; align-items: flex-end; padding: 24px 8px; gap: 24px; width: 1200px; } .index-card-header-content { display: flex; flex-direction: column; align-items: flex-start; padding: 0px; gap: 16px; width: 768px; } .index-card-header-nav{ display: flex; flex-direction: column; align-items: flex-start; padding: 20px; gap: 8px; width: 360px; background: #F3F6F8; border-radius: 16px; flex: none; order: 1; flex-grow: 0; } .index-page a { color: #20272C } .index-card-lg { display: flex; flex-direction: column; justify-content: center; align-items: flex-start; gap: 16px; width: 588px; height: 200px; padding: 24px; border-radius: 12px; border: 1px solid #F3F6F8; cursor: pointer; } .index-card-sm { display: flex; flex-direction: column; justify-content: center; align-items: flex-start; gap: 16px; width: 282px; left: 0px; top: 0px; border-radius: 12px; padding: 24px; border: 1px solid #F3F6F8; cursor: pointer; } .index-footer { box-sizing: border-box; display: flex; flex-direction: row; justify-content: center; align-items: center; padding: 24px; width: 100vw; height: 110px; border-top: 1px solid #F3F6F8; position: fixed; bottom: 0px; left: 0px; background: white; } .index-footer-content { display: flex; flex-direction: row; align-items: flex-start; padding: 10px; gap: 10px; width: 1200px; } .index-footer-content > p { font-family: 'Karla'; font-style: normal; font-weight: 400; font-size: 14px; line-height: 150%; letter-spacing: -0.02em; color: #63727E; } .index-topic-header { margin: 0 } .index-card-lg:hover { border: 1px solid #D9E0E6; } .index-card-sm:hover { border: 1px solid #D9E0E6; } .index-container-top{ display: flex; flex-direction: row; align-items: flex-start; padding: 0px; gap: 24px; margin-top: 24px; } .index-card-header-content > h2 { margin: 0; } .lottie-button{ display: flex; flex-direction: row; justify-content: center; align-items: center; padding: 4px 12px; gap: 8px; height: 32px; background: #F3F6F8; border-radius: 8px; border: 0; color: #20272C; } .lottie-button:hover { background: #D9E0E6; } .lottie-button:focus { background: #F3F6F8; /* focus-on-light */ box-shadow: 0px 0px 0px 1px #FFFFFF, 0px 0px 0px 3px #00DDB3; } @media (max-width: 800px) { .index-card-header-nav { display: none; } } @media (max-height: 1200px) { .index-page { margin-bottom: 0px; } .index-footer { margin-top: 64px; margin-left: -16px; position: static; } } @media (max-width: 1200px) { .index-card-header{ width: 100%; } } @media (max-width: 1000px) { .index-card-header { padding: 24px 0; } .index-container-top { flex-direction : column; padding: 0; } .index-card-lg { width: 100%; height: auto; } .index-card-sm { width: 100%; height: auto; } .index-footer { padding: 16px; } .index-page { margin-bottom: 0px; } .index-footer { margin-top: 64px; margin-left: -16px; position: static; } } A human's guide to the Lottie format Lottie is a vector animation format, using JSON to represent its data. This guide aims to provide a human-readable description of the format and how everything works within it. Read the guide Topics Introduction Bouncy Ball Lottie from Scratch Bezier Curves Precompositions Lottie Format Tips for Rendering JSON Schema Advanced Interactions Lottie Format This page describes values and other objects used throughout the Lottie format. Lottie from Scratch In this example, we'll build a simple lottie animation from scratch. Lottie Playground JSON Editor Lottie Builder Lottie-Player Easily embed and play Lottie animations in websites. Lottie-React Easily add Lottie animations to your React projects. Lottie-Svelte Svelte provides a Lottie player using the lottie-web library. Lottie-Vue Vue component for the Lottie Web Player. LottieFiles is by Design Barn Inc. Copyright \u00a9 2022 Design Barn Inc. All rights reserved.","title":"Home"},{"location":"Introduction/","text":"A human's guide to the Lottie format Lottie is a vector animation format, using JSON to represent its data. This guide aims to provide a human-readable description of the format and how everything works within it. This documentation assumes the reader is already familiar with the following concepts: JSON Vector Graphics Bezier Curves Tweening Easing Functions What this guide is This guide aims to describe the lottie format in its entirety, while also give in-depth descriptions of how every aspect works, which you can't get from just looking at a list of JSON attributes. It contains a section that shows a breakdown of simple lottie animation describing what is going on as an introduction for the format. It also has reference pages which go over the details of every object you can find in a lottie file, and a description of its most notable attributes. It provides a complete JSON schema , this is intended for people who want to write tools to parse or generate lottie and need to get every little detail. Finally it has a section with details about rendering , which gives tips and provides pseudo-code on how to draw various elements to match with the lottie web player. What this guide is not You won't find here information on how to animate, or how to export a lottie file from your editor of choice. It also won't give information on how to embed lottie animations in your application or website. This is because there's already a lot of documentation for creating and using lottie animations, while this aims at providing a description of the file format itself. For the Impatient The top level JSON object is the Animation . Note that some lottie players require certain JSON keys to be presents before others in the file to play properly. Objects within the JSON may have a mixture of animatable and non-animatable properties. If a property is not animated, the value is represented as usual within the JSON. If it's animated, it has a special representation . Interactive Explanation If you have a lottie animation and you want to see an interactive description of its contents, you can visit the JSON Editor page. Anatomy of a Lottie file Go to the next page for a breakdown of a simple lottie animation. JSON Schema This guide provides a human-readable description of the format, but if you want a machine-readable description, we also have a JSON schema . Other Resources Lottie documentation from python-lottie Lottie community documentation Lottie community schema","title":"Introduction"},{"location":"Introduction/#a-humans-guide-to-the-lottie-format","text":"Lottie is a vector animation format, using JSON to represent its data. This guide aims to provide a human-readable description of the format and how everything works within it. This documentation assumes the reader is already familiar with the following concepts: JSON Vector Graphics Bezier Curves Tweening Easing Functions","title":"A human's guide to the Lottie format"},{"location":"Introduction/#what-this-guide-is","text":"This guide aims to describe the lottie format in its entirety, while also give in-depth descriptions of how every aspect works, which you can't get from just looking at a list of JSON attributes. It contains a section that shows a breakdown of simple lottie animation describing what is going on as an introduction for the format. It also has reference pages which go over the details of every object you can find in a lottie file, and a description of its most notable attributes. It provides a complete JSON schema , this is intended for people who want to write tools to parse or generate lottie and need to get every little detail. Finally it has a section with details about rendering , which gives tips and provides pseudo-code on how to draw various elements to match with the lottie web player.","title":"What this guide is"},{"location":"Introduction/#what-this-guide-is-not","text":"You won't find here information on how to animate, or how to export a lottie file from your editor of choice. It also won't give information on how to embed lottie animations in your application or website. This is because there's already a lot of documentation for creating and using lottie animations, while this aims at providing a description of the file format itself.","title":"What this guide is not"},{"location":"Introduction/#for-the-impatient","text":"The top level JSON object is the Animation . Note that some lottie players require certain JSON keys to be presents before others in the file to play properly. Objects within the JSON may have a mixture of animatable and non-animatable properties. If a property is not animated, the value is represented as usual within the JSON. If it's animated, it has a special representation .","title":"For the Impatient"},{"location":"Introduction/#interactive-explanation","text":"If you have a lottie animation and you want to see an interactive description of its contents, you can visit the JSON Editor page.","title":"Interactive Explanation"},{"location":"Introduction/#anatomy-of-a-lottie-file","text":"Go to the next page for a breakdown of a simple lottie animation.","title":"Anatomy of a Lottie file"},{"location":"Introduction/#json-schema","text":"This guide provides a human-readable description of the format, but if you want a machine-readable description, we also have a JSON schema .","title":"JSON Schema"},{"location":"Introduction/#other-resources","text":"Lottie documentation from python-lottie Lottie community documentation Lottie community schema","title":"Other Resources"},{"location":"advanced_interactions/","text":"Advanced Interactions This page will describe how to create lotties with advanced interactivity, specifically when used with lottie-web player. This page is divided into \"levels\", each level adds more obscure features which are less portable but add increased interaction capabilities. There are 9 levels below Regular Lottie , which is the same as the number of circles of hell in Dante's Inferno. Reader discretion is advised. The techniques described below require knowledge on the following topics: The Lottie format Lottie expressions The lottie-web player ECMAScript / JavaScript DOM and events .playground_html > div > svg { border: 1px solid #ccc; } pre { margin-top: 0; } #content-container .nav.nav-tabs { height: 45px; } Level 0: Regular Lotties Lotties can play an animation, loading an animation looks something like this: Lottie HTML Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 1, \"k\": [ {\"t\": 0, \"s\": [0], \"o\": {\"x\": 0, \"y\": 0}, \"i\": {\"x\": 1, \"y\": 1}}, {\"t\": 360, \"s\": [360]} ]}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 1, 0.3]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30} } ] } ] } <div id=\"level0\"></div> var container = document.getElementById(\"level0\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 1, \"k\": [ {\"t\": 0, \"s\": [0], \"o\": {\"x\": 0, \"y\": 0}, \"i\": {\"x\": 1, \"y\": 1}}, {\"t\": 360, \"s\": [360]} ]}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 1, 0.3]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30} } ] } ] } ; var container = document.getElementById(\"level0\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); })(); By themselves lotties just play an animation, but luckily lottie-web provides some utility functions, note how in the Script above we are storing the variable anim returned by bodymovin.loadAnimation . Level 1: Controlling Playback You can play around with the anim object like setting the current frame, pausing stopping etc. There's also the LottieFiles interactivity library that makes some of these interactions easier to create. Here's an example of a lottie changing based on mouse position: Lottie HTML Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 1, \"k\": [ {\"t\": 0, \"s\": [0], \"o\": {\"x\": 0, \"y\": 0}, \"i\": {\"x\": 1, \"y\": 1}}, {\"t\": 360, \"s\": [360]} ]}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 1, 0.3]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30} } ] } ] } <div id=\"level1\"></div> var container = document.getElementById(\"level1\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: false, animationData: json, }; var anim = bodymovin.loadAnimation(options); container.addEventListener(\"mousemove\", ev => { var rect = container.getBoundingClientRect(); var t = (ev.clientX - rect.left) / rect.width; anim.goToAndStop(t * json.op, true); }); (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 1, \"k\": [ {\"t\": 0, \"s\": [0], \"o\": {\"x\": 0, \"y\": 0}, \"i\": {\"x\": 1, \"y\": 1}}, {\"t\": 360, \"s\": [360]} ]}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 1, 0.3]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30} } ] } ] } ; var container = document.getElementById(\"level1\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: false, animationData: json, }; var anim = bodymovin.loadAnimation(options); container.addEventListener(\"mousemove\", ev => { var rect = container.getBoundingClientRect(); var t = (ev.clientX - rect.left) / rect.width; anim.goToAndStop(t * json.op, true); }); })(); Level 2: SVG Styling When using the SVG renderer, you can make use of CSS styling by specifying a value for cl in the lottie layers. In the example below, CSS rules highlight the lottie layer showing a rectangle when the mouse is over it. Lottie CSS HTML Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [400, 300]}, \"s\": {\"a\": 0, \"k\": [150, 150]}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.769, 0.851, 0.961]} } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"cl\": \"lottie_level_2\", \"shapes\": [ { \"ty\": \"rc\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [256, 128]}, \"r\": {\"a\": 0, \"k\": 3}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.196, 0.314, 0.69]} } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [100, 200]}, \"s\": {\"a\": 0, \"k\": [150, 150]}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.769, 0.851, 0.961]} } ] } ] } .lottie_level_2:hover { opacity: 10%; } .lottie_level_2 { cursor: pointer; } <div id=\"level2\"></div> var container = document.getElementById(\"level2\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: false, animationData: json, }; var anim = bodymovin.loadAnimation(options); .lottie_level_2:hover { opacity: 10%; } .lottie_level_2 { cursor: pointer; } (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [400, 300]}, \"s\": {\"a\": 0, \"k\": [150, 150]}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.769, 0.851, 0.961]} } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"cl\": \"lottie_level_2\", \"shapes\": [ { \"ty\": \"rc\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [256, 128]}, \"r\": {\"a\": 0, \"k\": 3}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.196, 0.314, 0.69]} } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [100, 200]}, \"s\": {\"a\": 0, \"k\": [150, 150]}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.769, 0.851, 0.961]} } ] } ] } ; var container = document.getElementById(\"level2\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: false, animationData: json, }; var anim = bodymovin.loadAnimation(options); })(); Level 3: Basic Expressions Lotties can have expressions , they are basically small snippets of JavaScript code used to modify the value of animated properties. Below the star rotation is animated using an expression instead of using keyframes. Lottie HTML Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0, \"x\": \"var $bm_rt = time * 60;\"}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 1, 0.3]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30} } ] } ] } <div id=\"level3\"></div> var container = document.getElementById(\"level3\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0, \"x\": \"var $bm_rt = time * 60;\"}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 1, 0.3]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30} } ] } ] } ; var container = document.getElementById(\"level3\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); })(); Level 4: Advanced Expressions Within expressions you can access properties from other layers, and since they are all JavaScript objects, you can add your own properties to them. You can make a layer follow the position of another: // Set the layer position to follow the X position of another layer var other_position = thisComp(\"layer_name\").transform.position; var $bm_rt = [other_position[0], value[1]]; Since property values are initialized to their non-expression value, you can't access updated value of the property you are changing from the expression. However you can work around this by storing state in the layer object. // Get size of the rect var size = thisLayer.content(1).size; // Initialize everything at the start if ( time == 0 ) { thisLayer.my_value = size[0] / 2; thisLayer.speed = 60; thisLayer.direction = 1; thisLayer.prev_time = 0; } // Handle the case when the lottie has looped and time has reset // as it might not be exactly 0 if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; // Find the time delta to keep constant speed var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; // Increment x thisLayer.my_value += dt * thisLayer.speed * thisLayer.direction; var x = thisLayer.my_value; if ( x >= thisComp.width - size[0] / 2) thisLayer.direction = -1; else if ( x <= size[0] / 2 ) thisLayer.direction = 1; // Calculate y based on x var y = value[1] + Math.sin((x / thisComp.width) * Math.PI * 2) * (thisComp.height - size[1]) / 2; var $bm_rt = [x, y]; Here's an example: Note that the JSON uses ECMAScript's backtick string syntax for clarity, in a real Lottie file you'd need to put it into a single line. Newlines in the expression string work fine as long as the last line of the expression doesn't end in a single line comment. Lottie HTML Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 60, \"st\": 0, \"nm\": \"layer_name\", \"ks\": { \"p\": { \"a\": 0, \"k\": [0, 256], \"x\": ` // Get size of the rect var size = thisLayer.content(1).size; // Initialize everything at the start if ( time == 0 ) { thisLayer.my_value = size[0] / 2; thisLayer.speed = 120; thisLayer.direction = 1; thisLayer.prev_time = 0; } // Handle the case when the lottie has looped and time has reset // as it might not be exactly 0 if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; // Find the time delta to keep constant speed var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; // Increment x thisLayer.my_value += dt * thisLayer.speed * thisLayer.direction; var x = thisLayer.my_value; if ( x >= thisComp.width - size[0] / 2) thisLayer.direction = -1; else if ( x <= size[0] / 2 ) thisLayer.direction = 1; // Calculate y based on x var y = value[1] + Math.sin((x / thisComp.width) * Math.PI * 2) * (thisComp.height - size[1]) / 2; var $bm_rt = [x, y]; ` } }, \"shapes\": [ { \"ty\": \"rc\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [80, 80]}, \"r\": {\"a\": 0, \"k\": 3}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.196, 0.314, 0.69]} } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 3600, \"st\": 0, \"ks\": { \"p\": { \"a\": 0, \"k\": [0, 256], \"x\": ` // Set the layer position to follow the X position of another layer var other_position = thisComp(\"layer_name\").transform.position; var $bm_rt = [other_position[0], value[1]]; ` } }, \"shapes\": [ { \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [150, 150]}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.769, 0.851, 0.961]} } ] } ] } <div id=\"level4\"></div> var container = document.getElementById(\"level4\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 60, \"st\": 0, \"nm\": \"layer_name\", \"ks\": { \"p\": { \"a\": 0, \"k\": [0, 256], \"x\": ` // Get size of the rect var size = thisLayer.content(1).size; // Initialize everything at the start if ( time == 0 ) { thisLayer.my_value = size[0] / 2; thisLayer.speed = 120; thisLayer.direction = 1; thisLayer.prev_time = 0; } // Handle the case when the lottie has looped and time has reset // as it might not be exactly 0 if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; // Find the time delta to keep constant speed var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; // Increment x thisLayer.my_value += dt * thisLayer.speed * thisLayer.direction; var x = thisLayer.my_value; if ( x >= thisComp.width - size[0] / 2) thisLayer.direction = -1; else if ( x <= size[0] / 2 ) thisLayer.direction = 1; // Calculate y based on x var y = value[1] + Math.sin((x / thisComp.width) * Math.PI * 2) * (thisComp.height - size[1]) / 2; var $bm_rt = [x, y]; ` } }, \"shapes\": [ { \"ty\": \"rc\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [80, 80]}, \"r\": {\"a\": 0, \"k\": 3}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.196, 0.314, 0.69]} } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 3600, \"st\": 0, \"ks\": { \"p\": { \"a\": 0, \"k\": [0, 256], \"x\": ` // Set the layer position to follow the X position of another layer var other_position = thisComp(\"layer_name\").transform.position; var $bm_rt = [other_position[0], value[1]]; ` } }, \"shapes\": [ { \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [150, 150]}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.769, 0.851, 0.961]} } ] } ] } ; var container = document.getElementById(\"level4\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); })(); Level 5: Breaking Time In the previous examples, we had a condition at the start of some expressions initializing custom attributes when time is equal to 0. if ( time == 0 ) thisLayer.my_property = \"some value\"; This works because the first frame is always at time 0 but it isn't a super reliable check: when the player loops, the time can go back to 0 which would result in your properties being initialized again. If you want your interactions to carry over across loops, a better approach is to use a condition where you check for undefined layer properties: if ( thisLayer.my_property === undefined ) thisLayer.my_property = \"some value\"; For smooth value increments, we need to properly handle the time variable within expressions. Similarly to what we've done before the following example shows how to initialize and update a variable over time; // Initialization if ( thisLayer.last_time === undefined ) { thisLayer.last_time = time; thisLayer.value = 0; thisLayer.speed = 600; } // Handle looping if ( time < thisLayer.last_time ) thisLayer.last_time = time; // `dt` is the time since the last expression evaluation in seconds var dt = time - thisLayer.last_time; // Update the time management variable thisLayer.last_time = time; // Increment thisLayer.value = dt * thisLayer.speed; This approach allows you to change values regardless of playback speed and framerate. I also allows you to continue the movement when the lottie reaches its last frame and starts looping. In the following example, the lottie is set to loop every second but it keeps going indefinitely because of the time management setup: Lottie HTML Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 0], \"x\": ` // Initialization if ( thisLayer.prev_time === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; thisLayer.dx = 1; thisLayer.dy = 1; thisLayer.prev_time = 0; } // Time management if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; // Animation thisLayer.px += thisLayer.dx * dt * 100; thisLayer.py += thisLayer.dy * dt * 120; var radius = thisLayer.content(1).outerRadius; if ( thisLayer.px < radius ) thisLayer.dx = 1; else if ( thisLayer.px > thisComp.width - radius ) thisLayer.dx = -1; if ( thisLayer.py < radius ) thisLayer.dy = 1; else if ( thisLayer.py > thisComp.height - radius ) thisLayer.dy = -1; // Set value var $bm_rt = [thisLayer.px, thisLayer.py]; `}}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], } } ] } ] } <div id=\"level5\"></div> var options = { container: document.getElementById(\"level5\"), renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 0], \"x\": ` // Initialization if ( thisLayer.prev_time === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; thisLayer.dx = 1; thisLayer.dy = 1; thisLayer.prev_time = 0; } // Time management if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; // Animation thisLayer.px += thisLayer.dx * dt * 100; thisLayer.py += thisLayer.dy * dt * 120; var radius = thisLayer.content(1).outerRadius; if ( thisLayer.px < radius ) thisLayer.dx = 1; else if ( thisLayer.px > thisComp.width - radius ) thisLayer.dx = -1; if ( thisLayer.py < radius ) thisLayer.dy = 1; else if ( thisLayer.py > thisComp.height - radius ) thisLayer.dy = -1; // Set value var $bm_rt = [thisLayer.px, thisLayer.py]; `}}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], } } ] } ] } ; var options = { container: document.getElementById(\"level5\"), renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); })(); Level 6: Injecting Data Remember the anim object we get from lottie-web? It's the key for more advanced interactions. Internally it stores its lottie structure and the objects being passed to expression as thisComp and thisLayer . Being able to access these objects allows us to pass data directly to the lottie expressions. The object corresponding to thisComp can be accessed as anim.renderer.compInterface , and from there you can get the layers by name or index (see the Composition expression object). In the example below the rotation direction and color of the star change based on whether the mouse is over the element containing the lottie. // Time management as before if ( time == 0 ) { thisLayer.angle = 0; thisLayer.prev_time = 0; } if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; var direction = thisComp.counter_clockwise ? -1 : 1; thisLayer.angle += dt * direction * 60; var $bm_rt = thisLayer.angle; Lottie HTML Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0, \"x\": ` // Time management as before if ( thisLayer.prev_time === undefined ) { thisLayer.angle = 0; thisLayer.prev_time = 0; } if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; var direction = thisComp.mouse_is_over ? -1 : 1; thisLayer.angle += dt * direction * 60; var $bm_rt = thisLayer.angle; `}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], \"x\": \"var $bm_rt = thisComp.mouse_is_over ? [0.196, 0.314, 0.69] : value;\" }, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30} } ] } ] } <div id=\"level6\"></div> var container = document.getElementById(\"level6\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); container.addEventListener(\"mouseenter\", () => { anim.renderer.compInterface.mouse_is_over = true; }); container.addEventListener(\"mouseleave\", () => { anim.renderer.compInterface.mouse_is_over = false; }); (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0, \"x\": ` // Time management as before if ( thisLayer.prev_time === undefined ) { thisLayer.angle = 0; thisLayer.prev_time = 0; } if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; var direction = thisComp.mouse_is_over ? -1 : 1; thisLayer.angle += dt * direction * 60; var $bm_rt = thisLayer.angle; `}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], \"x\": \"var $bm_rt = thisComp.mouse_is_over ? [0.196, 0.314, 0.69] : value;\" }, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30} } ] } ] } ; var container = document.getElementById(\"level6\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); container.addEventListener(\"mouseenter\", () => { anim.renderer.compInterface.mouse_is_over = true; }); container.addEventListener(\"mouseleave\", () => { anim.renderer.compInterface.mouse_is_over = false; }); })(); Level 7: Automatic Event Handlers So far the interaction logic has been done by JavaScript on the browser. In this section we'll add all the logic in the JSON itself and write a wrapper script that sets up the animation. This allows you to have self-contained lotties you can embed in a web page that will handle events on their own. Lottie JSON Extension First thing is to write the expressions in the Lottie itself. Since Lottie is just a JSON file, it's easy to add custom values: { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"events\": { \"click\": \"/*event handler code*/\" } } Now we need to add some JavaScript so we can listen to the events fired by the DOM and execute expressions: for ( let [ev_type, expression] of Object.entries(json.events) ) { let expression_function = Function(\"event\", expression); container.addEventListener(ev_type, expression_function); } Preparing Globals While the above would work, we should expose some objects for it to be useful. The lottie player define a bunch of objects and functions for expressions, but we don't really need all of them since the even handlers only need to pass along the information that an event has occurred. We will define thisComp and time to be the same as the globals of the same name you'd expect to find an expressions, and pass them to the event handling function: function event_handler(ev, expression_function) { var thisComp = anim.renderer.compInterface; var time = anim.renderer.renderedFrame / anim.renderer.globalData.frameRate; expression_function(ev, thisComp, time); } for ( let [ev_type, expression] of Object.entries(json.events) ) { let expression_function = Function(\"event\", \"thisComp\", \"time\", expression); container.addEventListener(ev_type, ev => event_handler(ev, expression_function)); } After this step, you're all set to hanle DOM events automatically from a lottie. The next couple steps add some polish to the event interface for a smoother experience. Mouse Events Events like click , mousemove , etc. provide the mouse coordinates, which you might want to access from within the lottie. By default these coordinates aren't in the same space as the values inside the lottie so we need to scale them appropriately: function event_handler(ev, expression_function) { var thisComp = anim.renderer.compInterface; var time = anim.renderer.renderedFrame / anim.renderer.globalData.frameRate; if ( ev.clientX !== undefined ) { var rect = container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * thisComp.height; } expression_function(ev, thisComp, time); } for ( let [ev_type, expression] of Object.entries(json.events) ) { let expression_function = Function(\"event\", \"thisComp\", \"time\", expression); container.addEventListener(ev_type, ev => event_handler(ev, expression_function)); } Now we can reference the position in the lottie expression: { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"events\": { \"click\": ` var star = thisComp(\"star\"); star.px = event.lottie_x; star.py = event.lottie_y; ` } } In the example below you can click to move the star to a given position: Lottie HTML Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"events\": { \"click\": ` var star = thisComp(\"star\"); star.px = event.lottie_x; star.py = event.lottie_y; ` }, \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 0], \"x\": ` // Initialization if ( thisLayer.px === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; } // Set value var $bm_rt = [thisLayer.px, thisLayer.py]; `}}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], } } ] } ] } <div id=\"level7_mouse\"></div> var container = document.getElementById(\"level7_mouse\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); function event_handler(ev, expression_function) { var thisComp = anim.renderer.compInterface; var time = anim.renderer.renderedFrame / anim.renderer.globalData.frameRate; if ( ev.clientX !== undefined ) { var rect = container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * thisComp.height; } expression_function(ev, thisComp, time); } for ( let [ev_type, expression] of Object.entries(json.events) ) { let expression_function = Function(\"event\", \"thisComp\", \"time\", expression); container.addEventListener(ev_type, ev => event_handler(ev, expression_function)); } (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"events\": { \"click\": ` var star = thisComp(\"star\"); star.px = event.lottie_x; star.py = event.lottie_y; ` }, \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 0], \"x\": ` // Initialization if ( thisLayer.px === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; } // Set value var $bm_rt = [thisLayer.px, thisLayer.py]; `}}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], } } ] } ] } ; var container = document.getElementById(\"level7_mouse\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); function event_handler(ev, expression_function) { var thisComp = anim.renderer.compInterface; var time = anim.renderer.renderedFrame / anim.renderer.globalData.frameRate; if ( ev.clientX !== undefined ) { var rect = container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * thisComp.height; } expression_function(ev, thisComp, time); } for ( let [ev_type, expression] of Object.entries(json.events) ) { let expression_function = Function(\"event\", \"thisComp\", \"time\", expression); container.addEventListener(ev_type, ev => event_handler(ev, expression_function)); } })(); Keyboard Events To allow keyboard events to be fired correctly, you need to ensure the element containing the lottie is focusable. You can do this by setting the tabindex attribute in HTML or with JavaScript. <div id=\"level7_keyboard\" tabindex=\"0\"></div> or container.setAttribute(\"tabindex\", \"0\"); In the example below we'll move a layer based on whether the user is pressing the left and right arrow keys. A good solution for this is to keep track of which key has been pressed and react accordingly. The event handler code is simple enough: For keydown : if ( event.key == \"ArrowLeft\" ) thisComp(\"star\").left = true; else if ( event.key == \"ArrowRight\" ) thisComp(\"star\").right = true; // Prevent scrolling and other browser shortcuts event.preventDefault(); keyup : if ( event.key == \"ArrowLeft\" ) thisComp(\"star\").left = false; else if ( event.key == \"ArrowRight\" ) thisComp(\"star\").right = false; // Prevent scrolling and other browser shortcuts event.preventDefault(); We should also reset these when the lottie element loses focus: focusout : thisComp(\"star\").left = false; thisComp(\"star\").right = false; We need to add some logic to the layer position property: // Initialization if ( thisLayer.px === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; thisLayer.left = false; thisLayer.right = false; thisLayer.prev_time = 0; } // Handle time wrapping around if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; // Time delta var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; // Figure which direction to move var direction = 0; if ( thisLayer.left && thisLayer.right ) direction = 0; else if ( thisLayer.left ) direction = -1; else if ( thisLayer.right ) direction = 1; // Move if ( direction != 0 ) { // 600 is the \"speed\", you need to consider that dt is the time // in seconds since the previous frame so it's usally a rather small value thisLayer.px += direction * dt * 600; var radius = thisLayer.content(1).outerRadius; thisLayer.px = clamp(thisLayer.px, radius, thisComp.width - radius); } // Set value var $bm_rt = [thisLayer.px, thisLayer.py]; The example below shows how to handle keyboard event. Focusing on the element changes the star color. When focused (blue star) left and right arrow keys move the star in the corresponding direction. Lottie HTML Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"events\": { \"keydown\": ` if ( event.key == \"ArrowLeft\" ) thisComp(\"star\").left = true; else if ( event.key == \"ArrowRight\" ) thisComp(\"star\").right = true; // Prevent scrolling and other browser shortcuts event.preventDefault(); `, \"keyup\": ` if ( event.key == \"ArrowLeft\" ) thisComp(\"star\").left = false; else if ( event.key == \"ArrowRight\" ) thisComp(\"star\").right = false; // Prevent scrolling and other browser shortcuts event.preventDefault(); `, \"focusin\": \"thisComp.focus = true;\", \"focusout\": ` thisComp(\"star\").left = false; thisComp(\"star\").right = false; thisComp.focus = false; `, }, \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 0], \"x\": ` // Initialization if ( thisLayer.px === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; thisLayer.left = false; thisLayer.right = false; thisLayer.prev_time = 0; } // Handle time wrapping around if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; // Time delta var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; // Figure which direction to move var direction = 0; if ( thisLayer.left && thisLayer.right ) direction = 0; else if ( thisLayer.left ) direction = -1; else if ( thisLayer.right ) direction = 1; // Move if ( direction != 0 ) { // 600 is the \"speed\", you need to consider that dt is the time // in seconds since the previous frame so it's usally a rather small value thisLayer.px += direction * dt * 600; var radius = thisLayer.content(1).outerRadius; thisLayer.px = clamp(thisLayer.px, radius, thisComp.width - radius); } // Set value var $bm_rt = [thisLayer.px, thisLayer.py]; `}}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], \"x\": \"var $bm_rt = thisComp.focus ? [0.196, 0.314, 0.69] : value;\" } } ] } ] } <div id=\"level7_keyboard\" tabindex=\"0\"></div> var container = document.getElementById(\"level7_keyboard\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); function event_handler(ev, expression_function) { var thisComp = anim.renderer.compInterface; var time = anim.renderer.renderedFrame / anim.renderer.globalData.frameRate; if ( ev.clientX !== undefined ) { var rect = container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * thisComp.height; } expression_function(ev, thisComp, time); } for ( let [ev_type, expression] of Object.entries(json.events) ) { let expression_function = Function(\"event\", \"thisComp\", \"time\", expression); container.addEventListener(ev_type, ev => event_handler(ev, expression_function)); } (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"events\": { \"keydown\": ` if ( event.key == \"ArrowLeft\" ) thisComp(\"star\").left = true; else if ( event.key == \"ArrowRight\" ) thisComp(\"star\").right = true; // Prevent scrolling and other browser shortcuts event.preventDefault(); `, \"keyup\": ` if ( event.key == \"ArrowLeft\" ) thisComp(\"star\").left = false; else if ( event.key == \"ArrowRight\" ) thisComp(\"star\").right = false; // Prevent scrolling and other browser shortcuts event.preventDefault(); `, \"focusin\": \"thisComp.focus = true;\", \"focusout\": ` thisComp(\"star\").left = false; thisComp(\"star\").right = false; thisComp.focus = false; `, }, \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 0], \"x\": ` // Initialization if ( thisLayer.px === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; thisLayer.left = false; thisLayer.right = false; thisLayer.prev_time = 0; } // Handle time wrapping around if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; // Time delta var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; // Figure which direction to move var direction = 0; if ( thisLayer.left && thisLayer.right ) direction = 0; else if ( thisLayer.left ) direction = -1; else if ( thisLayer.right ) direction = 1; // Move if ( direction != 0 ) { // 600 is the \"speed\", you need to consider that dt is the time // in seconds since the previous frame so it's usally a rather small value thisLayer.px += direction * dt * 600; var radius = thisLayer.content(1).outerRadius; thisLayer.px = clamp(thisLayer.px, radius, thisComp.width - radius); } // Set value var $bm_rt = [thisLayer.px, thisLayer.py]; `}}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], \"x\": \"var $bm_rt = thisComp.focus ? [0.196, 0.314, 0.69] : value;\" } } ] } ] } ; var container = document.getElementById(\"level7_keyboard\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); function event_handler(ev, expression_function) { var thisComp = anim.renderer.compInterface; var time = anim.renderer.renderedFrame / anim.renderer.globalData.frameRate; if ( ev.clientX !== undefined ) { var rect = container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * thisComp.height; } expression_function(ev, thisComp, time); } for ( let [ev_type, expression] of Object.entries(json.events) ) { let expression_function = Function(\"event\", \"thisComp\", \"time\", expression); container.addEventListener(ev_type, ev => event_handler(ev, expression_function)); } })(); Level 8: Sound Effects Lottie web supports playing audio layers with the help of Howler . By default the level of control you get with sound is rather limited but we can find a way around it. The issue is audio layers don't have a scriptable property that controls playback which means we can't attach an expression to audio layers. The trick is to wrap an audio layer into a precomp and to use an expression on its time remapping property. We can then control playback as follows: if ( thisLayer.last_time === undefined ) { thisLayer.last_time = time; // This variable wil control whether the sound is played thisLayer.sound_play = 0; // This should be the time in seconds you want the sound to play for // To get the best results, it should be just short of the duration // of the audio file thisLayer.sound_duration = 1; } // Usual time management stuff if ( time < thisLayer.last_time ) thisLayer.last_time = time; var dt = time - thisLayer.last_time; thisLayer.last_time = time; // Default to not playing var $bm_rt = 0; if ( thisLayer.sound_play > 0 ) { $bm_rt = thisLayer.sound_duration - thisLayer.sound_play; thisLayer.sound_play -= dt; } In the example that follows you can click on the lottie to make it play a sound. The precomp also has a green cicle that shows playback progress. Lottie HTML Script Result { \"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 180, \"w\": 512, \"h\": 512, \"ddd\": 0, \"events\": { \"click\": \"thisComp('sound_control').sound_play = thisComp('sound_control').sound_duration\" }, \"assets\": [ { \"id\": \"sound\", \"u\": \"/lottie-docs/examples/\", \"p\": \"sound.mp3\", \"e\": 0 }, { \"id\": \"precomp\", \"layers\": [ { \"nm\": \"a\", \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"el\", \"p\": {\"a\": 1, \"k\": [ { \"t\": 0, \"s\": [0, 256], \"i\": {\"x\": 0, \"y\": 0}, \"o\": {\"x\": 1, \"y\": 1}, }, { \"t\": 60, \"s\": [512, 256], } ]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, }, { \"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0, 1, 0]}, \"o\": {\"a\": 0, \"k\": 100}, } ] }, { \"ty\": 6, \"ip\": 1, \"op\": 60, \"st\": 1, \"refId\": \"sound\", \"au\": { \"lv\": {\"a\": 0, \"k\": [100, 100]} } } ] } ], \"markers\": [], \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 180, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": { \"a\": 1, \"k\": [ { \"t\": 0, \"s\": [0], \"i\": {\"x\": 0, \"y\": 0}, \"o\": {\"x\": 1, \"y\": 1} }, { \"t\": 180, \"s\": [360] } ] }, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 1], \"x\": ` var amount = thisComp('sound_control').sound_play ?? 0; var $bm_rt = [amount, 0, 0]; `, } } ] }, { \"nm\": \"sound_control\", \"ty\": 0, \"ip\": 0, \"op\": 180, \"st\": 0, \"ks\": {}, \"refId\": \"precomp\", \"w\": 512, \"h\": 512, \"tm\": { \"a\": 1, \"k\": [{ \"t\": 0, \"s\": [0], \"i\": {\"x\": 0, \"y\": 0}, \"o\": {\"x\": 1, \"y\": 1} }, { \"t\": 180, \"s\": [0] } ], \"x\": ` if ( thisLayer.last_time === undefined ) { thisLayer.last_time = time; // This variable wil control whether the sound is played thisLayer.sound_play = 0; // This should be the time in seconds you want the sound to play for thisLayer.sound_duration = 1; } // Usual time management stuff if ( time < thisLayer.last_time ) thisLayer.last_time = time; var dt = time - thisLayer.last_time; thisLayer.last_time = time; // Default to not playing var $bm_rt = 100; if ( thisLayer.sound_play > 0 ) { $bm_rt = thisLayer.sound_duration - thisLayer.sound_play; thisLayer.sound_play -= dt; }` } } ] } <div id=\"level8\"></div> var container = document.getElementById(\"level8\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); function event_handler(ev, expression_function) { var thisComp = anim.renderer.compInterface; var time = anim.renderer.renderedFrame / anim.renderer.globalData.frameRate; if ( ev.clientX !== undefined ) { var rect = container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * thisComp.height; } expression_function(ev, thisComp, time); } for ( let [ev_type, expression] of Object.entries(json.events) ) { let expression_function = Function(\"event\", \"thisComp\", \"time\", expression); container.addEventListener(ev_type, ev => event_handler(ev, expression_function)); } (function(){var json = { \"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 180, \"w\": 512, \"h\": 512, \"ddd\": 0, \"events\": { \"click\": \"thisComp('sound_control').sound_play = thisComp('sound_control').sound_duration\" }, \"assets\": [ { \"id\": \"sound\", \"u\": \"/lottie-docs/examples/\", \"p\": \"sound.mp3\", \"e\": 0 }, { \"id\": \"precomp\", \"layers\": [ { \"nm\": \"a\", \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"el\", \"p\": {\"a\": 1, \"k\": [ { \"t\": 0, \"s\": [0, 256], \"i\": {\"x\": 0, \"y\": 0}, \"o\": {\"x\": 1, \"y\": 1}, }, { \"t\": 60, \"s\": [512, 256], } ]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, }, { \"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0, 1, 0]}, \"o\": {\"a\": 0, \"k\": 100}, } ] }, { \"ty\": 6, \"ip\": 1, \"op\": 60, \"st\": 1, \"refId\": \"sound\", \"au\": { \"lv\": {\"a\": 0, \"k\": [100, 100]} } } ] } ], \"markers\": [], \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 180, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": { \"a\": 1, \"k\": [ { \"t\": 0, \"s\": [0], \"i\": {\"x\": 0, \"y\": 0}, \"o\": {\"x\": 1, \"y\": 1} }, { \"t\": 180, \"s\": [360] } ] }, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 1], \"x\": ` var amount = thisComp('sound_control').sound_play ?? 0; var $bm_rt = [amount, 0, 0]; `, } } ] }, { \"nm\": \"sound_control\", \"ty\": 0, \"ip\": 0, \"op\": 180, \"st\": 0, \"ks\": {}, \"refId\": \"precomp\", \"w\": 512, \"h\": 512, \"tm\": { \"a\": 1, \"k\": [{ \"t\": 0, \"s\": [0], \"i\": {\"x\": 0, \"y\": 0}, \"o\": {\"x\": 1, \"y\": 1} }, { \"t\": 180, \"s\": [0] } ], \"x\": ` if ( thisLayer.last_time === undefined ) { thisLayer.last_time = time; // This variable wil control whether the sound is played thisLayer.sound_play = 0; // This should be the time in seconds you want the sound to play for thisLayer.sound_duration = 1; } // Usual time management stuff if ( time < thisLayer.last_time ) thisLayer.last_time = time; var dt = time - thisLayer.last_time; thisLayer.last_time = time; // Default to not playing var $bm_rt = 100; if ( thisLayer.sound_play > 0 ) { $bm_rt = thisLayer.sound_duration - thisLayer.sound_play; thisLayer.sound_play -= dt; }` } } ] } ; var container = document.getElementById(\"level8\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); function event_handler(ev, expression_function) { var thisComp = anim.renderer.compInterface; var time = anim.renderer.renderedFrame / anim.renderer.globalData.frameRate; if ( ev.clientX !== undefined ) { var rect = container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * thisComp.height; } expression_function(ev, thisComp, time); } for ( let [ev_type, expression] of Object.entries(json.events) ) { let expression_function = Function(\"event\", \"thisComp\", \"time\", expression); container.addEventListener(ev_type, ev => event_handler(ev, expression_function)); } })(); Interlude: Writing a Small Wrapper Follows a JavaScript class that sets everything we've seen until now in a self-contained object. class LottieInteractionPlayer { constructor(container, custom_options={}) { if ( typeof container == \"string\" ) this.container = document.getElementById(container); else this.container = container; this.anim = null; this.custom_options = custom_options; // needed by keyup/down if ( !container.hasAttribute(\"tabindex\") ) container.setAttribute(\"tabindex\", \"0\"); this.handlers = {}; this._container_event_listener = this.container_event.bind(this); } // Deep copy lottie JSON lottie_clone(json) { return JSON.parse(JSON.stringify(json)); } load(lottie, resize = true) { // Options var options = { container: this.container, renderer: 'svg', loop: true, autoplay: true, // Clone because the player modifies the passed object animationData = this.lottie_clone(lottie); ...this.custom_options, }; if ( resize ) { this.container.style.width = lottie.w + \"px\"; this.container.style.height = lottie.h + \"px\"; } // Clean up this.clear(); // Setup handlers this.handlers = {}; if ( lottie.events ) { for ( var [name, func] of Object.entries(lottie.events) ) { this.handlers[name] = this.expression_to_event_handler(func); this.container.addEventListener(name, this._container_event_listener); } } // Create lottie player this.anim = bodymovin.loadAnimation(options); } // Destroy the animation clear() { if ( this.anim != null ) { try { this.anim.destroy(); this.anim = null; } catch ( e ) {} } for ( let name of Object.keys(this.handlers) ) this.container.removeEventListener(name, this._container_event_listener); } // Get the expression `thisComp` global get thisComp() { return this.anim.renderer.compInterface; } // Get the expression `time` global get time() { return this.anim.renderer.renderedFrame / this.anim.renderer.globalData.frameRate; } // Get an expression layer layer(name) { return this.thisComp(name); } // Handles an event from the container element container_event(ev) { this.prepare_lottie_event(ev); if ( this.handlers[ev.type] ) this.handle_lottie_event(ev, this.handlers[ev.type]); } // Adds useful attributes to an event object prepare_lottie_event(ev) { if ( ev.clientX !== undefined ) { var rect = this.container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * this.thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * this.thisComp.height; } } // Handles an event given a handler handle_lottie_event(ev, handler) { handler(ev, this.thisComp, this.time); } // Sets up an event handler expression_to_event_handler(expr) { return Function(\"event\", \"thisComp\", \"time\", expr); } } Level 9: Patching the Renderer So far we've used the vanilla lottie-web player without modifications. This is good for the interactions described until now but for more advanced stuff we need to patch the player. The code in this level assumes you have a wrapper class similar to the one described in the interlude. Why Follows a description of some use cases that don't work with the current approach. Initializing Values So far we've initialized custom layer attributes in the expressions using them. We started by checking if time is 0: // Initialize everything at the start if ( time == 0 ) { thisLayer.my_value = size[0] / 2; thisLayer.speed = 60; thisLayer.direction = 1; thisLayer.prev_time = 0; } Since that isn't always reliable, we moved on to checking if the attributes are undefined: // Initialization if ( thisLayer.px === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; } While this works, it's a bit annoying because you don't know if you can access another layer's custom attributes on frame 0, so it would be nice to have an event for this: { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"events\": { \"load\": \"thisComp('mylayer').value = 123;\" } } We have the options of the DOMLoaded event from bodymovin: load(lottie, resize = true) { // (omitted the part of the code that's the same as before) // Create lottie player this.anim = bodymovin.loadAnimation(options); this.anim.addEventListener(\"DOMLoaded\", this._lottie_loaded_event.bind(this)); } _lottie_loaded_event() { // Create a dummy event object and invoke the this.container.dispatchEvent(new Event(\"load\"), {}); } The issue with this is such event can only be fired after the first frame has been renderer (and expressions have been evaluated at least once). DOM Events from Layers Until now the event handling has been done on the container element. Since all the layers result in DOM elements, it would be nice to be able to listen to events from those elements and handle them based on expressions defined on each layer. { \"ty\": 4, \"nm\": \"My layer\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": {}, \"shapes\": [], \"events\": { \"click\": \"thisLayer.clicked = true;\" } } To do this we need a way of mapping the layer in the JSON to the DOM element and the value for the expression thisLayer . All this information is within the lottie-web SVG renderer but we need to find a way of accessing it. The first step is to allow a layer object to be passed to the events: // Handles an event from the container element container_event(ev) { this.prepare_lottie_event(ev); if ( this.handlers[ev.type] ) this.handle_lottie_event(ev, this.handlers[ev.type], null); } // Handles an event given a handler handle_lottie_event(ev, handler, layer) { handler(ev, this.thisComp, this.time, layer); } // Sets up an event handler expression_to_event_handler(expr) { return Function(\"event\", \"thisComp\", \"time\", \"thisLayer\", expr); } How The gist of it is we need to path the renderer object and inject our code in some of its methods. Luckily we can do this on the fly: load(lottie, resize = true) { // (omitted the part of the code that's the same as before) // Create lottie player this.anim = bodymovin.loadAnimation(options); this._patch_renderer(); } _patch_renderer() { // We patch initItems to trigger an event before any expression is evaluated: var old_init = this.anim.renderer.initItems.bind(this.anim.renderer); var post_init = this._lottie_load_event.bind(this) this.anim.renderer.initItems = function(){ old_init(); post_init(); }; // We patch createItem to add event listener. // It takes the JSON layer as input and returns the renderer later object this.layer_elements = []; var old_create = this.anim.renderer.createItem.bind(this.anim.renderer); this.anim.renderer.createItem = (function(layer){ var item = old_create(layer); this._create_item_event(layer, item); return item; }).bind(this); } _lottie_load_event() { let ev = new Event(\"load\", {}); this.container.dispatchEvent(ev); for ( let layer of this.layer_elements ) layer.dispatchEvent(ev); } _create_item_event(lottie, item) { // lottie is the JSON layer // item.layerElement is the DOM element for this layer // item.layerInterface is the expression thisLayer object if ( !lottie.events ) return; // Create a dummy element for Null layers and the like, // it makes it easier to listen for `load` events let element = item.layerElement ?? document.createElement(\"div\"); // Keep track of layer elements so they can have the `load` event too this.layer_elements.push(element); for ( let [name, func] of Object.entries(lottie.events) ) { let handler = this.expression_to_event_handler(func); function listener(ev) { this.prepare_lottie_event(ev); this.handle_lottie_event(ev, handler, item.layerInterface); } element.addEventListener(name, listener.bind(this)); } } Now that the renderer has been patched can we be assured the patching is done before the functions we are patching have been called? The short answer is No, but we can have a look at how we can achieve this. Abusing Font Loading When a lottie has external fonts, the lottie-web player waits for every font to be loaded before initializing the renderer. Which means when you have text layers, the code above works perfectly. This is nice but not all lotties need text so we'll need something better. Deferring Animation Load The trick is to not pass the lottie JSON to lottie-web until after we've patched the renderer. This is easy enough because if you call bodymovin.loadAnimation without path or animationData everything will be initialized (including the renderer) and only the JSON loading step is missing. We can use this to patch the renderer before loading the animation: load(lottie, resize = true) { // Options var options = { container: this.container, renderer: 'svg', loop: true, autoplay: true, ...this.custom_options, // Note that animationData is deferred }; if ( resize ) { this.container.style.width = lottie.w + \"px\"; this.container.style.height = lottie.h + \"px\"; } // Clean up this.clear(); // Setup handlers this.handlers = {}; if ( lottie.events ) { for ( var [name, func] of Object.entries(lottie.events) ) { this.handlers[name] = this.expression_to_event_handler(func); this.container.addEventListener(name, this._container_event_listener); } } // Create lottie player this.anim = bodymovin.loadAnimation(options); this._patch_renderer(); this.anim.addEventListener(\"DOMLoaded\", this._lottie_loaded_event.bind(this)); // Clone because the player modifies the passed object var animation_data = this.lottie_clone(lottie); // Load animation separately so we can patch the renderer this.anim.setupAnimation(animation_data); } Note that anim.setupAnimation is available from lottie-web version 5.8.0. If you have earlier versions, you should call anim.configAnimation instead. Triggering new events We know how to make the lottie react to DOM events, but what if we want to make the DOM react to events triggered from the lottie? We can use the patching setup just discussed to also add events on the other direction, the only thing we need is adding a method to thisComp , so it's invokable from the expressions and make it trigger DOM events. The trick is to patch thisComp in the right place, fortunately we've already done the bulk of the work so we just need to add some more code when the animation has been loaded: _lottie_load_event() { let ev = new Event(\"load\", {}); this.container.dispatchEvent(ev); for ( let layer of this.layer_elements ) layer.dispatchEvent(ev); // We add a method for triggering events from the lottie this.thisComp.trigger_event = (function(type, detail){ this.container.dispatchEvent(new CustomEvent(\"lottie.\" + type, {detail})); }).bind(this); } Then you can add event listeners to the element containing the lottie animation. Resulting Wrapper Here's the same wrapper class as described earlier, but with patching code applied to support the load event and layer events. class LottieInteractionPlayer { constructor(container, custom_options={}) { if ( typeof container == \"string\" ) this.container = document.getElementById(container); else this.container = container; this.anim = null; this.custom_options = custom_options; // needed by keyup/down if ( !container.hasAttribute(\"tabindex\") ) container.setAttribute(\"tabindex\", \"0\"); this.handlers = {}; this._container_event_listener = this.container_event.bind(this); } // Deep copy lottie JSON lottie_clone(json) { return JSON.parse(JSON.stringify(json)); } load(lottie, resize = true) { // Options var options = { container: this.container, renderer: 'svg', loop: true, autoplay: true, ...this.custom_options, // Note that animationData is deferred }; if ( resize ) { this.container.style.width = lottie.w + \"px\"; this.container.style.height = lottie.h + \"px\"; } // Clean up this.clear(); // Setup handlers this.handlers = {}; if ( lottie.events ) { for ( var [name, func] of Object.entries(lottie.events) ) { this.handlers[name] = this.expression_to_event_handler(func); this.container.addEventListener(name, this._container_event_listener); } } // Create lottie player this.anim = bodymovin.loadAnimation(options); this._patch_renderer(); // Clone because the player modifies the passed object var animation_data = this.lottie_clone(lottie); // Load animation separately so we can patch the renderer this.anim.setupAnimation(animation_data); } _patch_renderer() { // We patch initItems to trigger an event before any expression is evaluated: var old_init = this.anim.renderer.initItems.bind(this.anim.renderer); var post_init = this._lottie_load_event.bind(this) this.anim.renderer.initItems = function(){ old_init(); post_init(); }; // We patch createItem to add event listener. // It takes the JSON layer as input and returns the renderer later object this.layer_elements = []; var old_create = this.anim.renderer.createItem.bind(this.anim.renderer); this.anim.renderer.createItem = (function(layer){ var item = old_create(layer); this._create_item_event(layer, item); return item; }).bind(this); } _create_item_event(lottie, item) { // lottie is the JSON layer // item.layerElement is the DOM element for this layer // item.layerInterface is the expression thisLayer object if ( !lottie.events ) return; // Create a dummy element for Null layers and the like, // it makes it easier to listen for `load` events let element = item.layerElement ?? document.createElement(\"div\"); // Keep track of layer elements so they can have the `load` event too this.layer_elements.push(element); for ( let [name, func] of Object.entries(lottie.events) ) { let handler = this.expression_to_event_handler(func); function listener(ev) { this.prepare_lottie_event(ev); this.handle_lottie_event(ev, handler, item.layerInterface); } element.addEventListener(name, listener.bind(this)); } } _lottie_load_event() { let ev = new Event(\"load\", {}); this.container.dispatchEvent(ev); for ( let layer of this.layer_elements ) layer.dispatchEvent(ev); // We add a method for triggering events from the lottie this.thisComp.trigger_event = (function(type, detail){ this.container.dispatchEvent(new CustomEvent(\"lottie.\" + type, {detail})); }).bind(this); } // Destroy the animation clear() { if ( this.anim != null ) { try { this.anim.destroy(); this.anim = null; } catch ( e ) {} } for ( let name of Object.keys(this.handlers) ) this.container.removeEventListener(name, this._container_event_listener); } // Get the expression `thisComp` global get thisComp() { return this.anim.renderer.compInterface; } // Get the expression `time` global get time() { return this.anim.renderer.renderedFrame / this.anim.renderer.globalData.frameRate; } // Get an expression layer layer(name) { return this.thisComp(name); } // Handles an event from the container element container_event(ev) { this.prepare_lottie_event(ev); if ( this.handlers[ev.type] ) this.handle_lottie_event(ev, this.handlers[ev.type], null); } // Adds useful attributes to an event object prepare_lottie_event(ev) { if ( ev.clientX !== undefined ) { var rect = this.container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * this.thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * this.thisComp.height; } } // Handles an event given a handler handle_lottie_event(ev, handler, layer) { handler(ev, this.thisComp, this.time, layer); } // Sets up an event handler expression_to_event_handler(expr) { return Function(\"event\", \"thisComp\", \"time\", \"thisLayer\", expr); } } class LottieInteractionPlayer { constructor(container, custom_options={}) { if ( typeof container == \"string\" ) this.container = document.getElementById(container); else this.container = container; this.anim = null; this.custom_options = custom_options; // needed by keyup/down if ( !container.hasAttribute(\"tabindex\") ) container.setAttribute(\"tabindex\", \"0\"); this.handlers = {}; this._container_event_listener = this.container_event.bind(this); } // Deep copy lottie JSON lottie_clone(json) { return JSON.parse(JSON.stringify(json)); } load(lottie, resize = true) { // Options var options = { container: this.container, renderer: 'svg', loop: true, autoplay: true, ...this.custom_options, // Note that animationData is deferred }; if ( resize ) { this.container.style.width = lottie.w + \"px\"; this.container.style.height = lottie.h + \"px\"; } // Clean up this.clear(); // Setup handlers this.handlers = {}; if ( lottie.events ) { for ( var [name, func] of Object.entries(lottie.events) ) { this.handlers[name] = this.expression_to_event_handler(func); this.container.addEventListener(name, this._container_event_listener); } } // Create lottie player this.anim = bodymovin.loadAnimation(options); this._patch_renderer(); // Clone because the player modifies the passed object var animation_data = this.lottie_clone(lottie); // Load animation separately so we can patch the renderer this.anim.setupAnimation(animation_data); } _patch_renderer() { // We patch initItems to trigger an event before any expression is evaluated: var old_init = this.anim.renderer.initItems.bind(this.anim.renderer); var post_init = this._lottie_load_event.bind(this) this.anim.renderer.initItems = function(){ old_init(); post_init(); }; // We patch createItem to add event listener. // It takes the JSON layer as input and returns the renderer later object this.layer_elements = []; var old_create = this.anim.renderer.createItem.bind(this.anim.renderer); this.anim.renderer.createItem = (function(layer){ var item = old_create(layer); this._create_item_event(layer, item); return item; }).bind(this); } _create_item_event(lottie, item) { // lottie is the JSON layer // item.layerElement is the DOM element for this layer // item.layerInterface is the expression thisLayer object if ( !lottie.events ) return; // Create a dummy element for Null layers and the like, // it makes it easier to listen for `load` events let element = item.layerElement ?? document.createElement(\"div\"); // Keep track of layer elements so they can have the `load` event too this.layer_elements.push(element); for ( let [name, func] of Object.entries(lottie.events) ) { let handler = this.expression_to_event_handler(func); function listener(ev) { this.prepare_lottie_event(ev); this.handle_lottie_event(ev, handler, item.layerInterface); } element.addEventListener(name, listener.bind(this)); } } _lottie_load_event() { let ev = new Event(\"load\", {}); this.container.dispatchEvent(ev); for ( let layer of this.layer_elements ) layer.dispatchEvent(ev); // We add a method for triggering events from the lottie this.thisComp.trigger_event = (function(type, detail){ this.container.dispatchEvent(new CustomEvent(\"lottie.\" + type, {detail})); }).bind(this); } // Destroy the animation clear() { if ( this.anim != null ) { try { this.anim.destroy(); this.anim = null; } catch ( e ) {} } for ( let name of Object.keys(this.handlers) ) this.container.removeEventListener(name, this._container_event_listener); } // Get the expression `thisComp` global get thisComp() { return this.anim.renderer.compInterface; } // Get the expression `time` global get time() { return this.anim.renderer.renderedFrame / this.anim.renderer.globalData.frameRate; } // Get an expression layer layer(name) { return this.thisComp(name); } // Handles an event from the container element container_event(ev) { this.prepare_lottie_event(ev); if ( this.handlers[ev.type] ) this.handle_lottie_event(ev, this.handlers[ev.type], null); } // Adds useful attributes to an event object prepare_lottie_event(ev) { if ( ev.clientX !== undefined ) { var rect = this.container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * this.thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * this.thisComp.height; } } // Handles an event given a handler handle_lottie_event(ev, handler, layer) { handler(ev, this.thisComp, this.time, layer); } // Sets up an event handler expression_to_event_handler(expr) { return Function(\"event\", \"thisComp\", \"time\", \"thisLayer\", expr); } } Animation or Interaction It's possible to use the custom load to detect whether the lottie is being played in an environment that supports the custom events. The following example is similar to the click example from level 7 but when a player doesn't have interaction support, the star moves around on its own. Lottie HTML CSS Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"events\": { \"click\": \"var star = thisComp('star'); star.px = event.lottie_x; star.py = event.lottie_y;\", \"load\": \"thisComp('star').interactive = true;\" }, \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 0], \"x\": ` // Initialization if ( thisLayer.px === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; if ( !thisLayer.interactive ) { thisLayer.dx = 1; thisLayer.dy = 1; thisLayer.prev_time = 0; } } if ( !thisLayer.interactive ) { if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; thisLayer.px += thisLayer.dx * dt * 100; thisLayer.py += thisLayer.dy * dt * 120; var radius = thisLayer.content(1).outerRadius; if ( thisLayer.px < radius ) thisLayer.dx = 1; else if ( thisLayer.px > thisComp.width - radius ) thisLayer.dx = -1; if ( thisLayer.py < radius ) thisLayer.dy = 1; else if ( thisLayer.py > thisComp.height - radius ) thisLayer.dy = -1; } // Set value var $bm_rt = [thisLayer.px, thisLayer.py]; `}}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], } } ] } ] } <div id=\"level9_parent\"> <div id=\"level9_not_interactive\"></div> <div id=\"level9_interactive\"></div> </div> #level9_parent { display: flex; } #level9_interactive, #level9_not_interactive { border: 1px solid #ccc; width: 50%; box-sizing: border-box; } var options = { container: document.getElementById(\"level9_not_interactive\"), renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); var player = new LottieInteractionPlayer(document.getElementById(\"level9_interactive\")); player.load(json, false); #level9_parent { display: flex; } #level9_interactive, #level9_not_interactive { border: 1px solid #ccc; width: 50%; box-sizing: border-box; } (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"events\": { \"click\": \"var star = thisComp('star'); star.px = event.lottie_x; star.py = event.lottie_y;\", \"load\": \"thisComp('star').interactive = true;\" }, \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 0], \"x\": ` // Initialization if ( thisLayer.px === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; if ( !thisLayer.interactive ) { thisLayer.dx = 1; thisLayer.dy = 1; thisLayer.prev_time = 0; } } if ( !thisLayer.interactive ) { if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; thisLayer.px += thisLayer.dx * dt * 100; thisLayer.py += thisLayer.dy * dt * 120; var radius = thisLayer.content(1).outerRadius; if ( thisLayer.px < radius ) thisLayer.dx = 1; else if ( thisLayer.px > thisComp.width - radius ) thisLayer.dx = -1; if ( thisLayer.py < radius ) thisLayer.dy = 1; else if ( thisLayer.py > thisComp.height - radius ) thisLayer.dy = -1; } // Set value var $bm_rt = [thisLayer.px, thisLayer.py]; `}}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], } } ] } ] } ; var options = { container: document.getElementById(\"level9_not_interactive\"), renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); var player = new LottieInteractionPlayer(document.getElementById(\"level9_interactive\")); player.load(json, false); })(); Lottie Button Example This example uses everything we discussed so far. A quick note: to avoid clicks going to the wrong layer we need to define some CSS that gets rid of pointer events for layers we don't want to click. Lottie Script HTML CSS Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"fonts\": {\"list\":[ { \"ascent\": 72, \"fFamily\": \"Roboto\", \"fName\": \"Roboto Regular\", \"fStyle\": \"Regular\", \"fPath\": \"https://fonts.googleapis.com/css2?family=Roboto&display=swap\", \"origin\": 1, } ]}, \"layers\": [ { \"ty\": 5, \"ip\": 0, \"op\": 60, \"st\": 0, \"parent\": 1, \"cl\": \"no-mouse\", \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 25]}, }, \"t\": { \"a\": [], \"d\": { \"x\": \"var $bm_rt = 'Clicks: ' + thisComp('button').clicks;\", \"k\": [ { \"s\": { \"f\": \"Roboto Regular\", \"fc\": [0, 0, 0], \"s\": 70, \"t\": \"\", \"j\": 2, }, \"t\": 0 } ] }, \"m\": { \"a\": {\"a\": 0, \"k\": [0,0]}, \"g\": 3 }, \"p\": {} } }, { \"ty\": 4, \"nm\": \"button\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ind\": 1, \"cl\": \"lottie-button\", \"events\": { \"load\": \"thisLayer.clicks = 0;\", \"click\": \"thisLayer.clicks += 1; thisComp.trigger_event('click', {clicks: thisLayer.clicks});\", \"mouseenter\": \"thisLayer.highlighted = true;\", \"mouseleave\": \"thisLayer.highlighted = false;\" }, \"ks\": { \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": { \"a\": 0, \"k\": [100, 100], \"x\": \"var sz = thisLayer.highlighted ? 120 : 100; var $bm_rt = [sz, sz];\" } }, \"shapes\": [ { \"ty\": \"rc\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [350, 90]}, \"r\": {\"a\": 0, \"k\": 3}, }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 1, 0]}, \"w\": {\"a\": 0, \"k\": 1}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 50, \"x\": \"var $bm_rt = thisLayer.highlighted ? 70 : 30;\"}, \"c\": {\"a\": 0, \"k\": [0.4, 1, 0.4]} } ] } ] } var container = document.getElementById(\"level9_button\"); var player = new LottieInteractionPlayer(container); player.load(json); container.addEventListener(\"lottie.click\", ev => document.getElementById(\"level9_outer\").innerText = `Lottie clicked ${ev.detail.clicks} times` ); <div id=\"level9_button\"></div> <div id=\"level9_outer\">Button not clicked</div> .no-mouse { pointer-events: none; } .lottie-button { cursor: pointer; } Button not clicked .no-mouse { pointer-events: none; } .lottie-button { cursor: pointer; } (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"fonts\": {\"list\":[ { \"ascent\": 72, \"fFamily\": \"Roboto\", \"fName\": \"Roboto Regular\", \"fStyle\": \"Regular\", \"fPath\": \"https://fonts.googleapis.com/css2?family=Roboto&display=swap\", \"origin\": 1, } ]}, \"layers\": [ { \"ty\": 5, \"ip\": 0, \"op\": 60, \"st\": 0, \"parent\": 1, \"cl\": \"no-mouse\", \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 25]}, }, \"t\": { \"a\": [], \"d\": { \"x\": \"var $bm_rt = 'Clicks: ' + thisComp('button').clicks;\", \"k\": [ { \"s\": { \"f\": \"Roboto Regular\", \"fc\": [0, 0, 0], \"s\": 70, \"t\": \"\", \"j\": 2, }, \"t\": 0 } ] }, \"m\": { \"a\": {\"a\": 0, \"k\": [0,0]}, \"g\": 3 }, \"p\": {} } }, { \"ty\": 4, \"nm\": \"button\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ind\": 1, \"cl\": \"lottie-button\", \"events\": { \"load\": \"thisLayer.clicks = 0;\", \"click\": \"thisLayer.clicks += 1; thisComp.trigger_event('click', {clicks: thisLayer.clicks});\", \"mouseenter\": \"thisLayer.highlighted = true;\", \"mouseleave\": \"thisLayer.highlighted = false;\" }, \"ks\": { \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": { \"a\": 0, \"k\": [100, 100], \"x\": \"var sz = thisLayer.highlighted ? 120 : 100; var $bm_rt = [sz, sz];\" } }, \"shapes\": [ { \"ty\": \"rc\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [350, 90]}, \"r\": {\"a\": 0, \"k\": 3}, }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 1, 0]}, \"w\": {\"a\": 0, \"k\": 1}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 50, \"x\": \"var $bm_rt = thisLayer.highlighted ? 70 : 30;\"}, \"c\": {\"a\": 0, \"k\": [0.4, 1, 0.4]} } ] } ] } ; var container = document.getElementById(\"level9_button\"); var player = new LottieInteractionPlayer(container); player.load(json); container.addEventListener(\"lottie.click\", ev => document.getElementById(\"level9_outer\").innerText = `Lottie clicked ${ev.detail.clicks} times` ); })(); 3D Everything discussed so far was for the lottie-web svg renderer but all the patching works with the html renderer as well. The html renderer supports 3D layers so we can make an interactive 3D scene with little effort. The main caveat is that you need to set position: relative on the container element. On the example below you can click to capture the mouse then have first-person controls. Lottie Script HTML CSS Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 180, \"fr\": 60, \"w\": 512, \"h\": 512, \"fonts\": { \"list\": [] }, \"assets\": [], \"layers\": [ { \"nm\": \"Camera\", \"ty\": 13, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ 0, 0, -10 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 0 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"pe\": { \"a\": 0, \"k\": 256 }, \"ddd\": 1 }, { \"nm\": \"Move Parent\", \"ty\": 3, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"a\": { \"a\": 0, \"k\": [ 0, 0, 0 ], \"x\": \"var dt = thisComp.time_delta(thisLayer, time);\\n\\n if ( thisComp.mouse_dx )\\n {\\n thisComp.char_angle -= dt * thisComp.mouse_dx / 8 * Math.PI;\\n thisComp.mouse_dx = 0;\\n }\\n\\n if ( thisComp.mouse_dy )\\n {\\n thisComp.look_angle += dt * thisComp.mouse_dy / 8 * Math.PI;\\n thisComp.mouse_dy = 0;\\n }\\n\\n\\n var left = thisComp.keys_pressed.ArrowLeft || thisComp.keys_pressed.a;\\n var right = thisComp.keys_pressed.ArrowRight || thisComp.keys_pressed.d;\\n var dx = 0;\\n if ( left && right )\\n dx = 0;\\n else if ( left )\\n dx = -1;\\n else if ( right )\\n dx = 1;\\n\\n var up = thisComp.keys_pressed.ArrowUp || thisComp.keys_pressed.w;\\n var down = thisComp.keys_pressed.ArrowDown || thisComp.keys_pressed.s;\\n var dz = 0;\\n if ( up && down )\\n dz = 0;\\n else if ( up )\\n dz = 1;\\n else if ( down )\\n dz = -1;\\n\\n thisLayer.char_x += dz * dt * -200 * Math.sin(thisComp.char_angle);\\n thisLayer.char_z += dz * dt * 200 * Math.cos(thisComp.char_angle);\\n\\n thisLayer.char_x += dx * dt * -200 * Math.sin(thisComp.char_angle - Math.PI / 2);\\n thisLayer.char_z += dx * dt * 200 * Math.cos(thisComp.char_angle - Math.PI / 2);\\n\\n var $bm_rt = [thisLayer.char_x, thisLayer.char_y, thisLayer.char_z];\\n \\n/**/\" }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 0 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ], \"x\": \"var $bm_rt = [thisComp.look_angle * 180 / Math.PI, thisComp.char_angle * 180 / Math.PI, 0];\\n \\n/**/\" } }, \"ind\": 1, \"ddd\": 1, \"events\": { \"load\": \"thisLayer.char_x = 0;\\n thisLayer.char_z = 0;\\n thisLayer.char_y = 0;\\n \\n/**/\" } }, { \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ 0, 0, 200 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 0 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"ddd\": 1, \"parent\": 1, \"shapes\": [ { \"ty\": \"rc\", \"s\": { \"a\": 0, \"k\": [ 200, 200 ] }, \"p\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"r\": { \"a\": 0, \"k\": 0 } }, { \"ty\": \"fl\", \"c\": { \"a\": 0, \"k\": [ 0.5, 0.5, 1 ] }, \"o\": { \"a\": 0, \"k\": 100 } } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ 0, 0, -200 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 0 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"ddd\": 1, \"parent\": 1, \"shapes\": [ { \"ty\": \"rc\", \"s\": { \"a\": 0, \"k\": [ 200, 200 ] }, \"p\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"r\": { \"a\": 0, \"k\": 0 } }, { \"ty\": \"fl\", \"c\": { \"a\": 0, \"k\": [ 0.5, 0.5, 0 ] }, \"o\": { \"a\": 0, \"k\": 100 } } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ 200, 0, 0 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 90 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"ddd\": 1, \"parent\": 1, \"shapes\": [ { \"ty\": \"rc\", \"s\": { \"a\": 0, \"k\": [ 200, 200 ] }, \"p\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"r\": { \"a\": 0, \"k\": 0 } }, { \"ty\": \"fl\", \"c\": { \"a\": 0, \"k\": [ 1, 0.5, 0.5 ] }, \"o\": { \"a\": 0, \"k\": 100 } } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ -200, 0, 0 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 90 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"ddd\": 1, \"parent\": 1, \"shapes\": [ { \"ty\": \"rc\", \"s\": { \"a\": 0, \"k\": [ 200, 200 ] }, \"p\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"r\": { \"a\": 0, \"k\": 0 } }, { \"ty\": \"fl\", \"c\": { \"a\": 0, \"k\": [ 0, 0.5, 0.5 ] }, \"o\": { \"a\": 0, \"k\": 100 } } ] } ], \"events\": { \"keydown\": \"thisComp.keys_pressed[event.key] = true;\\n\\n if ( event.key != \\\"F5\\\" )\\n event.preventDefault();\\n \\n/**/\", \"keyup\": \"thisComp.keys_pressed[event.key] = false;\\n\\n if ( event.key != \\\"F5\\\" )\\n event.preventDefault();\\n \\n/**/\", \"load\": \"thisComp.keys_pressed = {};\\n thisComp.mouse_dx = 0;\\n thisComp.mouse_dy = 0;\\n thisComp.char_angle = 0;\\n thisComp.look_angle = 0;\\n thisComp.time_delta = function (thisLayer, time) {\\n if ( thisLayer.last_time === undefined || time < thisLayer.last_time )\\n {\\n thisLayer.last_time = time;\\n return 0;\\n }\\n\\n var dt = time - thisLayer.last_time;\\n thisLayer.last_time = time;\\n return dt;\\n };\\n \\n/**/\", \"mouseenter\": \"thisComp.mouse_old_x = thisComp.mouse_x = event.lottie_x;\\n thisComp.mouse_old_y = thisComp.mouse_y = event.lottie_x;\\n \\n/**/\", \"mouseleave\": \"thisComp.mouse_old_x = thisComp.mouse_x = event.lottie_x;\\n thisComp.mouse_old_y = thisComp.mouse_y = event.lottie_x;\\n \\n/**/\", \"mousemove\": \"thisComp.mouse_dx += event.movementX;\\n thisComp.mouse_dy += event.movementY;\\n \\n/**/\" }, \"ddd\": 1 } var container = document.getElementById(\"level9_3d\"); var player = new LottieInteractionPlayer(container, {renderer: \"html\"}); player.load(json); <div id=\"level9_3d\" onclick=\"this.requestPointerLock();\"></div> #level9_3d { position: relative; } #level9_3d { position: relative; } (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 180, \"fr\": 60, \"w\": 512, \"h\": 512, \"fonts\": { \"list\": [] }, \"assets\": [], \"layers\": [ { \"nm\": \"Camera\", \"ty\": 13, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ 0, 0, -10 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 0 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"pe\": { \"a\": 0, \"k\": 256 }, \"ddd\": 1 }, { \"nm\": \"Move Parent\", \"ty\": 3, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"a\": { \"a\": 0, \"k\": [ 0, 0, 0 ], \"x\": \"var dt = thisComp.time_delta(thisLayer, time);\\n\\n if ( thisComp.mouse_dx )\\n {\\n thisComp.char_angle -= dt * thisComp.mouse_dx / 8 * Math.PI;\\n thisComp.mouse_dx = 0;\\n }\\n\\n if ( thisComp.mouse_dy )\\n {\\n thisComp.look_angle += dt * thisComp.mouse_dy / 8 * Math.PI;\\n thisComp.mouse_dy = 0;\\n }\\n\\n\\n var left = thisComp.keys_pressed.ArrowLeft || thisComp.keys_pressed.a;\\n var right = thisComp.keys_pressed.ArrowRight || thisComp.keys_pressed.d;\\n var dx = 0;\\n if ( left && right )\\n dx = 0;\\n else if ( left )\\n dx = -1;\\n else if ( right )\\n dx = 1;\\n\\n var up = thisComp.keys_pressed.ArrowUp || thisComp.keys_pressed.w;\\n var down = thisComp.keys_pressed.ArrowDown || thisComp.keys_pressed.s;\\n var dz = 0;\\n if ( up && down )\\n dz = 0;\\n else if ( up )\\n dz = 1;\\n else if ( down )\\n dz = -1;\\n\\n thisLayer.char_x += dz * dt * -200 * Math.sin(thisComp.char_angle);\\n thisLayer.char_z += dz * dt * 200 * Math.cos(thisComp.char_angle);\\n\\n thisLayer.char_x += dx * dt * -200 * Math.sin(thisComp.char_angle - Math.PI / 2);\\n thisLayer.char_z += dx * dt * 200 * Math.cos(thisComp.char_angle - Math.PI / 2);\\n\\n var $bm_rt = [thisLayer.char_x, thisLayer.char_y, thisLayer.char_z];\\n \\n/**/\" }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 0 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ], \"x\": \"var $bm_rt = [thisComp.look_angle * 180 / Math.PI, thisComp.char_angle * 180 / Math.PI, 0];\\n \\n/**/\" } }, \"ind\": 1, \"ddd\": 1, \"events\": { \"load\": \"thisLayer.char_x = 0;\\n thisLayer.char_z = 0;\\n thisLayer.char_y = 0;\\n \\n/**/\" } }, { \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ 0, 0, 200 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 0 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"ddd\": 1, \"parent\": 1, \"shapes\": [ { \"ty\": \"rc\", \"s\": { \"a\": 0, \"k\": [ 200, 200 ] }, \"p\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"r\": { \"a\": 0, \"k\": 0 } }, { \"ty\": \"fl\", \"c\": { \"a\": 0, \"k\": [ 0.5, 0.5, 1 ] }, \"o\": { \"a\": 0, \"k\": 100 } } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ 0, 0, -200 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 0 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"ddd\": 1, \"parent\": 1, \"shapes\": [ { \"ty\": \"rc\", \"s\": { \"a\": 0, \"k\": [ 200, 200 ] }, \"p\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"r\": { \"a\": 0, \"k\": 0 } }, { \"ty\": \"fl\", \"c\": { \"a\": 0, \"k\": [ 0.5, 0.5, 0 ] }, \"o\": { \"a\": 0, \"k\": 100 } } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ 200, 0, 0 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 90 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"ddd\": 1, \"parent\": 1, \"shapes\": [ { \"ty\": \"rc\", \"s\": { \"a\": 0, \"k\": [ 200, 200 ] }, \"p\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"r\": { \"a\": 0, \"k\": 0 } }, { \"ty\": \"fl\", \"c\": { \"a\": 0, \"k\": [ 1, 0.5, 0.5 ] }, \"o\": { \"a\": 0, \"k\": 100 } } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ -200, 0, 0 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 90 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"ddd\": 1, \"parent\": 1, \"shapes\": [ { \"ty\": \"rc\", \"s\": { \"a\": 0, \"k\": [ 200, 200 ] }, \"p\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"r\": { \"a\": 0, \"k\": 0 } }, { \"ty\": \"fl\", \"c\": { \"a\": 0, \"k\": [ 0, 0.5, 0.5 ] }, \"o\": { \"a\": 0, \"k\": 100 } } ] } ], \"events\": { \"keydown\": \"thisComp.keys_pressed[event.key] = true;\\n\\n if ( event.key != \\\"F5\\\" )\\n event.preventDefault();\\n \\n/**/\", \"keyup\": \"thisComp.keys_pressed[event.key] = false;\\n\\n if ( event.key != \\\"F5\\\" )\\n event.preventDefault();\\n \\n/**/\", \"load\": \"thisComp.keys_pressed = {};\\n thisComp.mouse_dx = 0;\\n thisComp.mouse_dy = 0;\\n thisComp.char_angle = 0;\\n thisComp.look_angle = 0;\\n thisComp.time_delta = function (thisLayer, time) {\\n if ( thisLayer.last_time === undefined || time < thisLayer.last_time )\\n {\\n thisLayer.last_time = time;\\n return 0;\\n }\\n\\n var dt = time - thisLayer.last_time;\\n thisLayer.last_time = time;\\n return dt;\\n };\\n \\n/**/\", \"mouseenter\": \"thisComp.mouse_old_x = thisComp.mouse_x = event.lottie_x;\\n thisComp.mouse_old_y = thisComp.mouse_y = event.lottie_x;\\n \\n/**/\", \"mouseleave\": \"thisComp.mouse_old_x = thisComp.mouse_x = event.lottie_x;\\n thisComp.mouse_old_y = thisComp.mouse_y = event.lottie_x;\\n \\n/**/\", \"mousemove\": \"thisComp.mouse_dx += event.movementX;\\n thisComp.mouse_dy += event.movementY;\\n \\n/**/\" }, \"ddd\": 1 } ; var container = document.getElementById(\"level9_3d\"); var player = new LottieInteractionPlayer(container, {renderer: \"html\"}); player.load(json); })(); document.querySelectorAll(\".nav-tabs a\").forEach( link => link.addEventListener(\"click\", e => jQuery(e.target).tab(\"show\")) );","title":"Advanced Interactions"},{"location":"advanced_interactions/#advanced-interactions","text":"This page will describe how to create lotties with advanced interactivity, specifically when used with lottie-web player. This page is divided into \"levels\", each level adds more obscure features which are less portable but add increased interaction capabilities. There are 9 levels below Regular Lottie , which is the same as the number of circles of hell in Dante's Inferno. Reader discretion is advised. The techniques described below require knowledge on the following topics: The Lottie format Lottie expressions The lottie-web player ECMAScript / JavaScript DOM and events .playground_html > div > svg { border: 1px solid #ccc; } pre { margin-top: 0; } #content-container .nav.nav-tabs { height: 45px; }","title":"Advanced Interactions"},{"location":"advanced_interactions/#level-0-regular-lotties","text":"Lotties can play an animation, loading an animation looks something like this: Lottie HTML Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 1, \"k\": [ {\"t\": 0, \"s\": [0], \"o\": {\"x\": 0, \"y\": 0}, \"i\": {\"x\": 1, \"y\": 1}}, {\"t\": 360, \"s\": [360]} ]}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 1, 0.3]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30} } ] } ] } <div id=\"level0\"></div> var container = document.getElementById(\"level0\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 1, \"k\": [ {\"t\": 0, \"s\": [0], \"o\": {\"x\": 0, \"y\": 0}, \"i\": {\"x\": 1, \"y\": 1}}, {\"t\": 360, \"s\": [360]} ]}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 1, 0.3]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30} } ] } ] } ; var container = document.getElementById(\"level0\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); })(); By themselves lotties just play an animation, but luckily lottie-web provides some utility functions, note how in the Script above we are storing the variable anim returned by bodymovin.loadAnimation .","title":"Level 0: Regular Lotties"},{"location":"advanced_interactions/#level-1-controlling-playback","text":"You can play around with the anim object like setting the current frame, pausing stopping etc. There's also the LottieFiles interactivity library that makes some of these interactions easier to create. Here's an example of a lottie changing based on mouse position: Lottie HTML Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 1, \"k\": [ {\"t\": 0, \"s\": [0], \"o\": {\"x\": 0, \"y\": 0}, \"i\": {\"x\": 1, \"y\": 1}}, {\"t\": 360, \"s\": [360]} ]}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 1, 0.3]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30} } ] } ] } <div id=\"level1\"></div> var container = document.getElementById(\"level1\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: false, animationData: json, }; var anim = bodymovin.loadAnimation(options); container.addEventListener(\"mousemove\", ev => { var rect = container.getBoundingClientRect(); var t = (ev.clientX - rect.left) / rect.width; anim.goToAndStop(t * json.op, true); }); (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 1, \"k\": [ {\"t\": 0, \"s\": [0], \"o\": {\"x\": 0, \"y\": 0}, \"i\": {\"x\": 1, \"y\": 1}}, {\"t\": 360, \"s\": [360]} ]}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 1, 0.3]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30} } ] } ] } ; var container = document.getElementById(\"level1\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: false, animationData: json, }; var anim = bodymovin.loadAnimation(options); container.addEventListener(\"mousemove\", ev => { var rect = container.getBoundingClientRect(); var t = (ev.clientX - rect.left) / rect.width; anim.goToAndStop(t * json.op, true); }); })();","title":"Level 1: Controlling Playback"},{"location":"advanced_interactions/#level-2-svg-styling","text":"When using the SVG renderer, you can make use of CSS styling by specifying a value for cl in the lottie layers. In the example below, CSS rules highlight the lottie layer showing a rectangle when the mouse is over it. Lottie CSS HTML Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [400, 300]}, \"s\": {\"a\": 0, \"k\": [150, 150]}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.769, 0.851, 0.961]} } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"cl\": \"lottie_level_2\", \"shapes\": [ { \"ty\": \"rc\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [256, 128]}, \"r\": {\"a\": 0, \"k\": 3}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.196, 0.314, 0.69]} } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [100, 200]}, \"s\": {\"a\": 0, \"k\": [150, 150]}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.769, 0.851, 0.961]} } ] } ] } .lottie_level_2:hover { opacity: 10%; } .lottie_level_2 { cursor: pointer; } <div id=\"level2\"></div> var container = document.getElementById(\"level2\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: false, animationData: json, }; var anim = bodymovin.loadAnimation(options); .lottie_level_2:hover { opacity: 10%; } .lottie_level_2 { cursor: pointer; } (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [400, 300]}, \"s\": {\"a\": 0, \"k\": [150, 150]}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.769, 0.851, 0.961]} } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"cl\": \"lottie_level_2\", \"shapes\": [ { \"ty\": \"rc\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [256, 128]}, \"r\": {\"a\": 0, \"k\": 3}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.196, 0.314, 0.69]} } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [100, 200]}, \"s\": {\"a\": 0, \"k\": [150, 150]}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.769, 0.851, 0.961]} } ] } ] } ; var container = document.getElementById(\"level2\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: false, animationData: json, }; var anim = bodymovin.loadAnimation(options); })();","title":"Level 2: SVG Styling"},{"location":"advanced_interactions/#level-3-basic-expressions","text":"Lotties can have expressions , they are basically small snippets of JavaScript code used to modify the value of animated properties. Below the star rotation is animated using an expression instead of using keyframes. Lottie HTML Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0, \"x\": \"var $bm_rt = time * 60;\"}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 1, 0.3]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30} } ] } ] } <div id=\"level3\"></div> var container = document.getElementById(\"level3\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0, \"x\": \"var $bm_rt = time * 60;\"}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 1, 0.3]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30} } ] } ] } ; var container = document.getElementById(\"level3\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); })();","title":"Level 3: Basic Expressions"},{"location":"advanced_interactions/#level-4-advanced-expressions","text":"Within expressions you can access properties from other layers, and since they are all JavaScript objects, you can add your own properties to them. You can make a layer follow the position of another: // Set the layer position to follow the X position of another layer var other_position = thisComp(\"layer_name\").transform.position; var $bm_rt = [other_position[0], value[1]]; Since property values are initialized to their non-expression value, you can't access updated value of the property you are changing from the expression. However you can work around this by storing state in the layer object. // Get size of the rect var size = thisLayer.content(1).size; // Initialize everything at the start if ( time == 0 ) { thisLayer.my_value = size[0] / 2; thisLayer.speed = 60; thisLayer.direction = 1; thisLayer.prev_time = 0; } // Handle the case when the lottie has looped and time has reset // as it might not be exactly 0 if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; // Find the time delta to keep constant speed var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; // Increment x thisLayer.my_value += dt * thisLayer.speed * thisLayer.direction; var x = thisLayer.my_value; if ( x >= thisComp.width - size[0] / 2) thisLayer.direction = -1; else if ( x <= size[0] / 2 ) thisLayer.direction = 1; // Calculate y based on x var y = value[1] + Math.sin((x / thisComp.width) * Math.PI * 2) * (thisComp.height - size[1]) / 2; var $bm_rt = [x, y]; Here's an example: Note that the JSON uses ECMAScript's backtick string syntax for clarity, in a real Lottie file you'd need to put it into a single line. Newlines in the expression string work fine as long as the last line of the expression doesn't end in a single line comment. Lottie HTML Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 60, \"st\": 0, \"nm\": \"layer_name\", \"ks\": { \"p\": { \"a\": 0, \"k\": [0, 256], \"x\": ` // Get size of the rect var size = thisLayer.content(1).size; // Initialize everything at the start if ( time == 0 ) { thisLayer.my_value = size[0] / 2; thisLayer.speed = 120; thisLayer.direction = 1; thisLayer.prev_time = 0; } // Handle the case when the lottie has looped and time has reset // as it might not be exactly 0 if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; // Find the time delta to keep constant speed var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; // Increment x thisLayer.my_value += dt * thisLayer.speed * thisLayer.direction; var x = thisLayer.my_value; if ( x >= thisComp.width - size[0] / 2) thisLayer.direction = -1; else if ( x <= size[0] / 2 ) thisLayer.direction = 1; // Calculate y based on x var y = value[1] + Math.sin((x / thisComp.width) * Math.PI * 2) * (thisComp.height - size[1]) / 2; var $bm_rt = [x, y]; ` } }, \"shapes\": [ { \"ty\": \"rc\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [80, 80]}, \"r\": {\"a\": 0, \"k\": 3}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.196, 0.314, 0.69]} } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 3600, \"st\": 0, \"ks\": { \"p\": { \"a\": 0, \"k\": [0, 256], \"x\": ` // Set the layer position to follow the X position of another layer var other_position = thisComp(\"layer_name\").transform.position; var $bm_rt = [other_position[0], value[1]]; ` } }, \"shapes\": [ { \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [150, 150]}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.769, 0.851, 0.961]} } ] } ] } <div id=\"level4\"></div> var container = document.getElementById(\"level4\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 60, \"st\": 0, \"nm\": \"layer_name\", \"ks\": { \"p\": { \"a\": 0, \"k\": [0, 256], \"x\": ` // Get size of the rect var size = thisLayer.content(1).size; // Initialize everything at the start if ( time == 0 ) { thisLayer.my_value = size[0] / 2; thisLayer.speed = 120; thisLayer.direction = 1; thisLayer.prev_time = 0; } // Handle the case when the lottie has looped and time has reset // as it might not be exactly 0 if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; // Find the time delta to keep constant speed var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; // Increment x thisLayer.my_value += dt * thisLayer.speed * thisLayer.direction; var x = thisLayer.my_value; if ( x >= thisComp.width - size[0] / 2) thisLayer.direction = -1; else if ( x <= size[0] / 2 ) thisLayer.direction = 1; // Calculate y based on x var y = value[1] + Math.sin((x / thisComp.width) * Math.PI * 2) * (thisComp.height - size[1]) / 2; var $bm_rt = [x, y]; ` } }, \"shapes\": [ { \"ty\": \"rc\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [80, 80]}, \"r\": {\"a\": 0, \"k\": 3}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.196, 0.314, 0.69]} } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 3600, \"st\": 0, \"ks\": { \"p\": { \"a\": 0, \"k\": [0, 256], \"x\": ` // Set the layer position to follow the X position of another layer var other_position = thisComp(\"layer_name\").transform.position; var $bm_rt = [other_position[0], value[1]]; ` } }, \"shapes\": [ { \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [150, 150]}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.769, 0.851, 0.961]} } ] } ] } ; var container = document.getElementById(\"level4\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); })();","title":"Level 4: Advanced Expressions"},{"location":"advanced_interactions/#level-5-breaking-time","text":"In the previous examples, we had a condition at the start of some expressions initializing custom attributes when time is equal to 0. if ( time == 0 ) thisLayer.my_property = \"some value\"; This works because the first frame is always at time 0 but it isn't a super reliable check: when the player loops, the time can go back to 0 which would result in your properties being initialized again. If you want your interactions to carry over across loops, a better approach is to use a condition where you check for undefined layer properties: if ( thisLayer.my_property === undefined ) thisLayer.my_property = \"some value\"; For smooth value increments, we need to properly handle the time variable within expressions. Similarly to what we've done before the following example shows how to initialize and update a variable over time; // Initialization if ( thisLayer.last_time === undefined ) { thisLayer.last_time = time; thisLayer.value = 0; thisLayer.speed = 600; } // Handle looping if ( time < thisLayer.last_time ) thisLayer.last_time = time; // `dt` is the time since the last expression evaluation in seconds var dt = time - thisLayer.last_time; // Update the time management variable thisLayer.last_time = time; // Increment thisLayer.value = dt * thisLayer.speed; This approach allows you to change values regardless of playback speed and framerate. I also allows you to continue the movement when the lottie reaches its last frame and starts looping. In the following example, the lottie is set to loop every second but it keeps going indefinitely because of the time management setup: Lottie HTML Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 0], \"x\": ` // Initialization if ( thisLayer.prev_time === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; thisLayer.dx = 1; thisLayer.dy = 1; thisLayer.prev_time = 0; } // Time management if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; // Animation thisLayer.px += thisLayer.dx * dt * 100; thisLayer.py += thisLayer.dy * dt * 120; var radius = thisLayer.content(1).outerRadius; if ( thisLayer.px < radius ) thisLayer.dx = 1; else if ( thisLayer.px > thisComp.width - radius ) thisLayer.dx = -1; if ( thisLayer.py < radius ) thisLayer.dy = 1; else if ( thisLayer.py > thisComp.height - radius ) thisLayer.dy = -1; // Set value var $bm_rt = [thisLayer.px, thisLayer.py]; `}}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], } } ] } ] } <div id=\"level5\"></div> var options = { container: document.getElementById(\"level5\"), renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 0], \"x\": ` // Initialization if ( thisLayer.prev_time === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; thisLayer.dx = 1; thisLayer.dy = 1; thisLayer.prev_time = 0; } // Time management if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; // Animation thisLayer.px += thisLayer.dx * dt * 100; thisLayer.py += thisLayer.dy * dt * 120; var radius = thisLayer.content(1).outerRadius; if ( thisLayer.px < radius ) thisLayer.dx = 1; else if ( thisLayer.px > thisComp.width - radius ) thisLayer.dx = -1; if ( thisLayer.py < radius ) thisLayer.dy = 1; else if ( thisLayer.py > thisComp.height - radius ) thisLayer.dy = -1; // Set value var $bm_rt = [thisLayer.px, thisLayer.py]; `}}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], } } ] } ] } ; var options = { container: document.getElementById(\"level5\"), renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); })();","title":"Level 5: Breaking Time"},{"location":"advanced_interactions/#level-6-injecting-data","text":"Remember the anim object we get from lottie-web? It's the key for more advanced interactions. Internally it stores its lottie structure and the objects being passed to expression as thisComp and thisLayer . Being able to access these objects allows us to pass data directly to the lottie expressions. The object corresponding to thisComp can be accessed as anim.renderer.compInterface , and from there you can get the layers by name or index (see the Composition expression object). In the example below the rotation direction and color of the star change based on whether the mouse is over the element containing the lottie. // Time management as before if ( time == 0 ) { thisLayer.angle = 0; thisLayer.prev_time = 0; } if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; var direction = thisComp.counter_clockwise ? -1 : 1; thisLayer.angle += dt * direction * 60; var $bm_rt = thisLayer.angle; Lottie HTML Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0, \"x\": ` // Time management as before if ( thisLayer.prev_time === undefined ) { thisLayer.angle = 0; thisLayer.prev_time = 0; } if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; var direction = thisComp.mouse_is_over ? -1 : 1; thisLayer.angle += dt * direction * 60; var $bm_rt = thisLayer.angle; `}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], \"x\": \"var $bm_rt = thisComp.mouse_is_over ? [0.196, 0.314, 0.69] : value;\" }, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30} } ] } ] } <div id=\"level6\"></div> var container = document.getElementById(\"level6\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); container.addEventListener(\"mouseenter\", () => { anim.renderer.compInterface.mouse_is_over = true; }); container.addEventListener(\"mouseleave\", () => { anim.renderer.compInterface.mouse_is_over = false; }); (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0, \"x\": ` // Time management as before if ( thisLayer.prev_time === undefined ) { thisLayer.angle = 0; thisLayer.prev_time = 0; } if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; var direction = thisComp.mouse_is_over ? -1 : 1; thisLayer.angle += dt * direction * 60; var $bm_rt = thisLayer.angle; `}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], \"x\": \"var $bm_rt = thisComp.mouse_is_over ? [0.196, 0.314, 0.69] : value;\" }, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30} } ] } ] } ; var container = document.getElementById(\"level6\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); container.addEventListener(\"mouseenter\", () => { anim.renderer.compInterface.mouse_is_over = true; }); container.addEventListener(\"mouseleave\", () => { anim.renderer.compInterface.mouse_is_over = false; }); })();","title":"Level 6: Injecting Data"},{"location":"advanced_interactions/#level-7-automatic-event-handlers","text":"So far the interaction logic has been done by JavaScript on the browser. In this section we'll add all the logic in the JSON itself and write a wrapper script that sets up the animation. This allows you to have self-contained lotties you can embed in a web page that will handle events on their own.","title":"Level 7: Automatic Event Handlers"},{"location":"advanced_interactions/#lottie-json-extension","text":"First thing is to write the expressions in the Lottie itself. Since Lottie is just a JSON file, it's easy to add custom values: { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"events\": { \"click\": \"/*event handler code*/\" } } Now we need to add some JavaScript so we can listen to the events fired by the DOM and execute expressions: for ( let [ev_type, expression] of Object.entries(json.events) ) { let expression_function = Function(\"event\", expression); container.addEventListener(ev_type, expression_function); }","title":"Lottie JSON Extension"},{"location":"advanced_interactions/#preparing-globals","text":"While the above would work, we should expose some objects for it to be useful. The lottie player define a bunch of objects and functions for expressions, but we don't really need all of them since the even handlers only need to pass along the information that an event has occurred. We will define thisComp and time to be the same as the globals of the same name you'd expect to find an expressions, and pass them to the event handling function: function event_handler(ev, expression_function) { var thisComp = anim.renderer.compInterface; var time = anim.renderer.renderedFrame / anim.renderer.globalData.frameRate; expression_function(ev, thisComp, time); } for ( let [ev_type, expression] of Object.entries(json.events) ) { let expression_function = Function(\"event\", \"thisComp\", \"time\", expression); container.addEventListener(ev_type, ev => event_handler(ev, expression_function)); } After this step, you're all set to hanle DOM events automatically from a lottie. The next couple steps add some polish to the event interface for a smoother experience.","title":"Preparing Globals"},{"location":"advanced_interactions/#mouse-events","text":"Events like click , mousemove , etc. provide the mouse coordinates, which you might want to access from within the lottie. By default these coordinates aren't in the same space as the values inside the lottie so we need to scale them appropriately: function event_handler(ev, expression_function) { var thisComp = anim.renderer.compInterface; var time = anim.renderer.renderedFrame / anim.renderer.globalData.frameRate; if ( ev.clientX !== undefined ) { var rect = container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * thisComp.height; } expression_function(ev, thisComp, time); } for ( let [ev_type, expression] of Object.entries(json.events) ) { let expression_function = Function(\"event\", \"thisComp\", \"time\", expression); container.addEventListener(ev_type, ev => event_handler(ev, expression_function)); } Now we can reference the position in the lottie expression: { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"events\": { \"click\": ` var star = thisComp(\"star\"); star.px = event.lottie_x; star.py = event.lottie_y; ` } } In the example below you can click to move the star to a given position: Lottie HTML Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"events\": { \"click\": ` var star = thisComp(\"star\"); star.px = event.lottie_x; star.py = event.lottie_y; ` }, \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 0], \"x\": ` // Initialization if ( thisLayer.px === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; } // Set value var $bm_rt = [thisLayer.px, thisLayer.py]; `}}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], } } ] } ] } <div id=\"level7_mouse\"></div> var container = document.getElementById(\"level7_mouse\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); function event_handler(ev, expression_function) { var thisComp = anim.renderer.compInterface; var time = anim.renderer.renderedFrame / anim.renderer.globalData.frameRate; if ( ev.clientX !== undefined ) { var rect = container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * thisComp.height; } expression_function(ev, thisComp, time); } for ( let [ev_type, expression] of Object.entries(json.events) ) { let expression_function = Function(\"event\", \"thisComp\", \"time\", expression); container.addEventListener(ev_type, ev => event_handler(ev, expression_function)); } (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"events\": { \"click\": ` var star = thisComp(\"star\"); star.px = event.lottie_x; star.py = event.lottie_y; ` }, \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 0], \"x\": ` // Initialization if ( thisLayer.px === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; } // Set value var $bm_rt = [thisLayer.px, thisLayer.py]; `}}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], } } ] } ] } ; var container = document.getElementById(\"level7_mouse\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); function event_handler(ev, expression_function) { var thisComp = anim.renderer.compInterface; var time = anim.renderer.renderedFrame / anim.renderer.globalData.frameRate; if ( ev.clientX !== undefined ) { var rect = container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * thisComp.height; } expression_function(ev, thisComp, time); } for ( let [ev_type, expression] of Object.entries(json.events) ) { let expression_function = Function(\"event\", \"thisComp\", \"time\", expression); container.addEventListener(ev_type, ev => event_handler(ev, expression_function)); } })();","title":"Mouse Events"},{"location":"advanced_interactions/#keyboard-events","text":"To allow keyboard events to be fired correctly, you need to ensure the element containing the lottie is focusable. You can do this by setting the tabindex attribute in HTML or with JavaScript. <div id=\"level7_keyboard\" tabindex=\"0\"></div> or container.setAttribute(\"tabindex\", \"0\"); In the example below we'll move a layer based on whether the user is pressing the left and right arrow keys. A good solution for this is to keep track of which key has been pressed and react accordingly. The event handler code is simple enough: For keydown : if ( event.key == \"ArrowLeft\" ) thisComp(\"star\").left = true; else if ( event.key == \"ArrowRight\" ) thisComp(\"star\").right = true; // Prevent scrolling and other browser shortcuts event.preventDefault(); keyup : if ( event.key == \"ArrowLeft\" ) thisComp(\"star\").left = false; else if ( event.key == \"ArrowRight\" ) thisComp(\"star\").right = false; // Prevent scrolling and other browser shortcuts event.preventDefault(); We should also reset these when the lottie element loses focus: focusout : thisComp(\"star\").left = false; thisComp(\"star\").right = false; We need to add some logic to the layer position property: // Initialization if ( thisLayer.px === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; thisLayer.left = false; thisLayer.right = false; thisLayer.prev_time = 0; } // Handle time wrapping around if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; // Time delta var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; // Figure which direction to move var direction = 0; if ( thisLayer.left && thisLayer.right ) direction = 0; else if ( thisLayer.left ) direction = -1; else if ( thisLayer.right ) direction = 1; // Move if ( direction != 0 ) { // 600 is the \"speed\", you need to consider that dt is the time // in seconds since the previous frame so it's usally a rather small value thisLayer.px += direction * dt * 600; var radius = thisLayer.content(1).outerRadius; thisLayer.px = clamp(thisLayer.px, radius, thisComp.width - radius); } // Set value var $bm_rt = [thisLayer.px, thisLayer.py]; The example below shows how to handle keyboard event. Focusing on the element changes the star color. When focused (blue star) left and right arrow keys move the star in the corresponding direction. Lottie HTML Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"events\": { \"keydown\": ` if ( event.key == \"ArrowLeft\" ) thisComp(\"star\").left = true; else if ( event.key == \"ArrowRight\" ) thisComp(\"star\").right = true; // Prevent scrolling and other browser shortcuts event.preventDefault(); `, \"keyup\": ` if ( event.key == \"ArrowLeft\" ) thisComp(\"star\").left = false; else if ( event.key == \"ArrowRight\" ) thisComp(\"star\").right = false; // Prevent scrolling and other browser shortcuts event.preventDefault(); `, \"focusin\": \"thisComp.focus = true;\", \"focusout\": ` thisComp(\"star\").left = false; thisComp(\"star\").right = false; thisComp.focus = false; `, }, \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 0], \"x\": ` // Initialization if ( thisLayer.px === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; thisLayer.left = false; thisLayer.right = false; thisLayer.prev_time = 0; } // Handle time wrapping around if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; // Time delta var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; // Figure which direction to move var direction = 0; if ( thisLayer.left && thisLayer.right ) direction = 0; else if ( thisLayer.left ) direction = -1; else if ( thisLayer.right ) direction = 1; // Move if ( direction != 0 ) { // 600 is the \"speed\", you need to consider that dt is the time // in seconds since the previous frame so it's usally a rather small value thisLayer.px += direction * dt * 600; var radius = thisLayer.content(1).outerRadius; thisLayer.px = clamp(thisLayer.px, radius, thisComp.width - radius); } // Set value var $bm_rt = [thisLayer.px, thisLayer.py]; `}}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], \"x\": \"var $bm_rt = thisComp.focus ? [0.196, 0.314, 0.69] : value;\" } } ] } ] } <div id=\"level7_keyboard\" tabindex=\"0\"></div> var container = document.getElementById(\"level7_keyboard\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); function event_handler(ev, expression_function) { var thisComp = anim.renderer.compInterface; var time = anim.renderer.renderedFrame / anim.renderer.globalData.frameRate; if ( ev.clientX !== undefined ) { var rect = container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * thisComp.height; } expression_function(ev, thisComp, time); } for ( let [ev_type, expression] of Object.entries(json.events) ) { let expression_function = Function(\"event\", \"thisComp\", \"time\", expression); container.addEventListener(ev_type, ev => event_handler(ev, expression_function)); } (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"events\": { \"keydown\": ` if ( event.key == \"ArrowLeft\" ) thisComp(\"star\").left = true; else if ( event.key == \"ArrowRight\" ) thisComp(\"star\").right = true; // Prevent scrolling and other browser shortcuts event.preventDefault(); `, \"keyup\": ` if ( event.key == \"ArrowLeft\" ) thisComp(\"star\").left = false; else if ( event.key == \"ArrowRight\" ) thisComp(\"star\").right = false; // Prevent scrolling and other browser shortcuts event.preventDefault(); `, \"focusin\": \"thisComp.focus = true;\", \"focusout\": ` thisComp(\"star\").left = false; thisComp(\"star\").right = false; thisComp.focus = false; `, }, \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 0], \"x\": ` // Initialization if ( thisLayer.px === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; thisLayer.left = false; thisLayer.right = false; thisLayer.prev_time = 0; } // Handle time wrapping around if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; // Time delta var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; // Figure which direction to move var direction = 0; if ( thisLayer.left && thisLayer.right ) direction = 0; else if ( thisLayer.left ) direction = -1; else if ( thisLayer.right ) direction = 1; // Move if ( direction != 0 ) { // 600 is the \"speed\", you need to consider that dt is the time // in seconds since the previous frame so it's usally a rather small value thisLayer.px += direction * dt * 600; var radius = thisLayer.content(1).outerRadius; thisLayer.px = clamp(thisLayer.px, radius, thisComp.width - radius); } // Set value var $bm_rt = [thisLayer.px, thisLayer.py]; `}}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], \"x\": \"var $bm_rt = thisComp.focus ? [0.196, 0.314, 0.69] : value;\" } } ] } ] } ; var container = document.getElementById(\"level7_keyboard\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); function event_handler(ev, expression_function) { var thisComp = anim.renderer.compInterface; var time = anim.renderer.renderedFrame / anim.renderer.globalData.frameRate; if ( ev.clientX !== undefined ) { var rect = container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * thisComp.height; } expression_function(ev, thisComp, time); } for ( let [ev_type, expression] of Object.entries(json.events) ) { let expression_function = Function(\"event\", \"thisComp\", \"time\", expression); container.addEventListener(ev_type, ev => event_handler(ev, expression_function)); } })();","title":"Keyboard Events"},{"location":"advanced_interactions/#level-8-sound-effects","text":"Lottie web supports playing audio layers with the help of Howler . By default the level of control you get with sound is rather limited but we can find a way around it. The issue is audio layers don't have a scriptable property that controls playback which means we can't attach an expression to audio layers. The trick is to wrap an audio layer into a precomp and to use an expression on its time remapping property. We can then control playback as follows: if ( thisLayer.last_time === undefined ) { thisLayer.last_time = time; // This variable wil control whether the sound is played thisLayer.sound_play = 0; // This should be the time in seconds you want the sound to play for // To get the best results, it should be just short of the duration // of the audio file thisLayer.sound_duration = 1; } // Usual time management stuff if ( time < thisLayer.last_time ) thisLayer.last_time = time; var dt = time - thisLayer.last_time; thisLayer.last_time = time; // Default to not playing var $bm_rt = 0; if ( thisLayer.sound_play > 0 ) { $bm_rt = thisLayer.sound_duration - thisLayer.sound_play; thisLayer.sound_play -= dt; } In the example that follows you can click on the lottie to make it play a sound. The precomp also has a green cicle that shows playback progress. Lottie HTML Script Result { \"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 180, \"w\": 512, \"h\": 512, \"ddd\": 0, \"events\": { \"click\": \"thisComp('sound_control').sound_play = thisComp('sound_control').sound_duration\" }, \"assets\": [ { \"id\": \"sound\", \"u\": \"/lottie-docs/examples/\", \"p\": \"sound.mp3\", \"e\": 0 }, { \"id\": \"precomp\", \"layers\": [ { \"nm\": \"a\", \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"el\", \"p\": {\"a\": 1, \"k\": [ { \"t\": 0, \"s\": [0, 256], \"i\": {\"x\": 0, \"y\": 0}, \"o\": {\"x\": 1, \"y\": 1}, }, { \"t\": 60, \"s\": [512, 256], } ]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, }, { \"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0, 1, 0]}, \"o\": {\"a\": 0, \"k\": 100}, } ] }, { \"ty\": 6, \"ip\": 1, \"op\": 60, \"st\": 1, \"refId\": \"sound\", \"au\": { \"lv\": {\"a\": 0, \"k\": [100, 100]} } } ] } ], \"markers\": [], \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 180, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": { \"a\": 1, \"k\": [ { \"t\": 0, \"s\": [0], \"i\": {\"x\": 0, \"y\": 0}, \"o\": {\"x\": 1, \"y\": 1} }, { \"t\": 180, \"s\": [360] } ] }, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 1], \"x\": ` var amount = thisComp('sound_control').sound_play ?? 0; var $bm_rt = [amount, 0, 0]; `, } } ] }, { \"nm\": \"sound_control\", \"ty\": 0, \"ip\": 0, \"op\": 180, \"st\": 0, \"ks\": {}, \"refId\": \"precomp\", \"w\": 512, \"h\": 512, \"tm\": { \"a\": 1, \"k\": [{ \"t\": 0, \"s\": [0], \"i\": {\"x\": 0, \"y\": 0}, \"o\": {\"x\": 1, \"y\": 1} }, { \"t\": 180, \"s\": [0] } ], \"x\": ` if ( thisLayer.last_time === undefined ) { thisLayer.last_time = time; // This variable wil control whether the sound is played thisLayer.sound_play = 0; // This should be the time in seconds you want the sound to play for thisLayer.sound_duration = 1; } // Usual time management stuff if ( time < thisLayer.last_time ) thisLayer.last_time = time; var dt = time - thisLayer.last_time; thisLayer.last_time = time; // Default to not playing var $bm_rt = 100; if ( thisLayer.sound_play > 0 ) { $bm_rt = thisLayer.sound_duration - thisLayer.sound_play; thisLayer.sound_play -= dt; }` } } ] } <div id=\"level8\"></div> var container = document.getElementById(\"level8\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); function event_handler(ev, expression_function) { var thisComp = anim.renderer.compInterface; var time = anim.renderer.renderedFrame / anim.renderer.globalData.frameRate; if ( ev.clientX !== undefined ) { var rect = container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * thisComp.height; } expression_function(ev, thisComp, time); } for ( let [ev_type, expression] of Object.entries(json.events) ) { let expression_function = Function(\"event\", \"thisComp\", \"time\", expression); container.addEventListener(ev_type, ev => event_handler(ev, expression_function)); } (function(){var json = { \"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 180, \"w\": 512, \"h\": 512, \"ddd\": 0, \"events\": { \"click\": \"thisComp('sound_control').sound_play = thisComp('sound_control').sound_duration\" }, \"assets\": [ { \"id\": \"sound\", \"u\": \"/lottie-docs/examples/\", \"p\": \"sound.mp3\", \"e\": 0 }, { \"id\": \"precomp\", \"layers\": [ { \"nm\": \"a\", \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"el\", \"p\": {\"a\": 1, \"k\": [ { \"t\": 0, \"s\": [0, 256], \"i\": {\"x\": 0, \"y\": 0}, \"o\": {\"x\": 1, \"y\": 1}, }, { \"t\": 60, \"s\": [512, 256], } ]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, }, { \"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0, 1, 0]}, \"o\": {\"a\": 0, \"k\": 100}, } ] }, { \"ty\": 6, \"ip\": 1, \"op\": 60, \"st\": 1, \"refId\": \"sound\", \"au\": { \"lv\": {\"a\": 0, \"k\": [100, 100]} } } ] } ], \"markers\": [], \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 180, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": { \"a\": 1, \"k\": [ { \"t\": 0, \"s\": [0], \"i\": {\"x\": 0, \"y\": 0}, \"o\": {\"x\": 1, \"y\": 1} }, { \"t\": 180, \"s\": [360] } ] }, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 1], \"x\": ` var amount = thisComp('sound_control').sound_play ?? 0; var $bm_rt = [amount, 0, 0]; `, } } ] }, { \"nm\": \"sound_control\", \"ty\": 0, \"ip\": 0, \"op\": 180, \"st\": 0, \"ks\": {}, \"refId\": \"precomp\", \"w\": 512, \"h\": 512, \"tm\": { \"a\": 1, \"k\": [{ \"t\": 0, \"s\": [0], \"i\": {\"x\": 0, \"y\": 0}, \"o\": {\"x\": 1, \"y\": 1} }, { \"t\": 180, \"s\": [0] } ], \"x\": ` if ( thisLayer.last_time === undefined ) { thisLayer.last_time = time; // This variable wil control whether the sound is played thisLayer.sound_play = 0; // This should be the time in seconds you want the sound to play for thisLayer.sound_duration = 1; } // Usual time management stuff if ( time < thisLayer.last_time ) thisLayer.last_time = time; var dt = time - thisLayer.last_time; thisLayer.last_time = time; // Default to not playing var $bm_rt = 100; if ( thisLayer.sound_play > 0 ) { $bm_rt = thisLayer.sound_duration - thisLayer.sound_play; thisLayer.sound_play -= dt; }` } } ] } ; var container = document.getElementById(\"level8\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); function event_handler(ev, expression_function) { var thisComp = anim.renderer.compInterface; var time = anim.renderer.renderedFrame / anim.renderer.globalData.frameRate; if ( ev.clientX !== undefined ) { var rect = container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * thisComp.height; } expression_function(ev, thisComp, time); } for ( let [ev_type, expression] of Object.entries(json.events) ) { let expression_function = Function(\"event\", \"thisComp\", \"time\", expression); container.addEventListener(ev_type, ev => event_handler(ev, expression_function)); } })();","title":"Level 8: Sound Effects"},{"location":"advanced_interactions/#interlude-writing-a-small-wrapper","text":"Follows a JavaScript class that sets everything we've seen until now in a self-contained object. class LottieInteractionPlayer { constructor(container, custom_options={}) { if ( typeof container == \"string\" ) this.container = document.getElementById(container); else this.container = container; this.anim = null; this.custom_options = custom_options; // needed by keyup/down if ( !container.hasAttribute(\"tabindex\") ) container.setAttribute(\"tabindex\", \"0\"); this.handlers = {}; this._container_event_listener = this.container_event.bind(this); } // Deep copy lottie JSON lottie_clone(json) { return JSON.parse(JSON.stringify(json)); } load(lottie, resize = true) { // Options var options = { container: this.container, renderer: 'svg', loop: true, autoplay: true, // Clone because the player modifies the passed object animationData = this.lottie_clone(lottie); ...this.custom_options, }; if ( resize ) { this.container.style.width = lottie.w + \"px\"; this.container.style.height = lottie.h + \"px\"; } // Clean up this.clear(); // Setup handlers this.handlers = {}; if ( lottie.events ) { for ( var [name, func] of Object.entries(lottie.events) ) { this.handlers[name] = this.expression_to_event_handler(func); this.container.addEventListener(name, this._container_event_listener); } } // Create lottie player this.anim = bodymovin.loadAnimation(options); } // Destroy the animation clear() { if ( this.anim != null ) { try { this.anim.destroy(); this.anim = null; } catch ( e ) {} } for ( let name of Object.keys(this.handlers) ) this.container.removeEventListener(name, this._container_event_listener); } // Get the expression `thisComp` global get thisComp() { return this.anim.renderer.compInterface; } // Get the expression `time` global get time() { return this.anim.renderer.renderedFrame / this.anim.renderer.globalData.frameRate; } // Get an expression layer layer(name) { return this.thisComp(name); } // Handles an event from the container element container_event(ev) { this.prepare_lottie_event(ev); if ( this.handlers[ev.type] ) this.handle_lottie_event(ev, this.handlers[ev.type]); } // Adds useful attributes to an event object prepare_lottie_event(ev) { if ( ev.clientX !== undefined ) { var rect = this.container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * this.thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * this.thisComp.height; } } // Handles an event given a handler handle_lottie_event(ev, handler) { handler(ev, this.thisComp, this.time); } // Sets up an event handler expression_to_event_handler(expr) { return Function(\"event\", \"thisComp\", \"time\", expr); } }","title":"Interlude: Writing a Small Wrapper"},{"location":"advanced_interactions/#level-9-patching-the-renderer","text":"So far we've used the vanilla lottie-web player without modifications. This is good for the interactions described until now but for more advanced stuff we need to patch the player. The code in this level assumes you have a wrapper class similar to the one described in the interlude.","title":"Level 9: Patching the Renderer"},{"location":"advanced_interactions/#why","text":"Follows a description of some use cases that don't work with the current approach.","title":"Why"},{"location":"advanced_interactions/#initializing-values","text":"So far we've initialized custom layer attributes in the expressions using them. We started by checking if time is 0: // Initialize everything at the start if ( time == 0 ) { thisLayer.my_value = size[0] / 2; thisLayer.speed = 60; thisLayer.direction = 1; thisLayer.prev_time = 0; } Since that isn't always reliable, we moved on to checking if the attributes are undefined: // Initialization if ( thisLayer.px === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; } While this works, it's a bit annoying because you don't know if you can access another layer's custom attributes on frame 0, so it would be nice to have an event for this: { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"events\": { \"load\": \"thisComp('mylayer').value = 123;\" } } We have the options of the DOMLoaded event from bodymovin: load(lottie, resize = true) { // (omitted the part of the code that's the same as before) // Create lottie player this.anim = bodymovin.loadAnimation(options); this.anim.addEventListener(\"DOMLoaded\", this._lottie_loaded_event.bind(this)); } _lottie_loaded_event() { // Create a dummy event object and invoke the this.container.dispatchEvent(new Event(\"load\"), {}); } The issue with this is such event can only be fired after the first frame has been renderer (and expressions have been evaluated at least once).","title":"Initializing Values"},{"location":"advanced_interactions/#dom-events-from-layers","text":"Until now the event handling has been done on the container element. Since all the layers result in DOM elements, it would be nice to be able to listen to events from those elements and handle them based on expressions defined on each layer. { \"ty\": 4, \"nm\": \"My layer\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": {}, \"shapes\": [], \"events\": { \"click\": \"thisLayer.clicked = true;\" } } To do this we need a way of mapping the layer in the JSON to the DOM element and the value for the expression thisLayer . All this information is within the lottie-web SVG renderer but we need to find a way of accessing it. The first step is to allow a layer object to be passed to the events: // Handles an event from the container element container_event(ev) { this.prepare_lottie_event(ev); if ( this.handlers[ev.type] ) this.handle_lottie_event(ev, this.handlers[ev.type], null); } // Handles an event given a handler handle_lottie_event(ev, handler, layer) { handler(ev, this.thisComp, this.time, layer); } // Sets up an event handler expression_to_event_handler(expr) { return Function(\"event\", \"thisComp\", \"time\", \"thisLayer\", expr); }","title":"DOM Events from Layers"},{"location":"advanced_interactions/#how","text":"The gist of it is we need to path the renderer object and inject our code in some of its methods. Luckily we can do this on the fly: load(lottie, resize = true) { // (omitted the part of the code that's the same as before) // Create lottie player this.anim = bodymovin.loadAnimation(options); this._patch_renderer(); } _patch_renderer() { // We patch initItems to trigger an event before any expression is evaluated: var old_init = this.anim.renderer.initItems.bind(this.anim.renderer); var post_init = this._lottie_load_event.bind(this) this.anim.renderer.initItems = function(){ old_init(); post_init(); }; // We patch createItem to add event listener. // It takes the JSON layer as input and returns the renderer later object this.layer_elements = []; var old_create = this.anim.renderer.createItem.bind(this.anim.renderer); this.anim.renderer.createItem = (function(layer){ var item = old_create(layer); this._create_item_event(layer, item); return item; }).bind(this); } _lottie_load_event() { let ev = new Event(\"load\", {}); this.container.dispatchEvent(ev); for ( let layer of this.layer_elements ) layer.dispatchEvent(ev); } _create_item_event(lottie, item) { // lottie is the JSON layer // item.layerElement is the DOM element for this layer // item.layerInterface is the expression thisLayer object if ( !lottie.events ) return; // Create a dummy element for Null layers and the like, // it makes it easier to listen for `load` events let element = item.layerElement ?? document.createElement(\"div\"); // Keep track of layer elements so they can have the `load` event too this.layer_elements.push(element); for ( let [name, func] of Object.entries(lottie.events) ) { let handler = this.expression_to_event_handler(func); function listener(ev) { this.prepare_lottie_event(ev); this.handle_lottie_event(ev, handler, item.layerInterface); } element.addEventListener(name, listener.bind(this)); } } Now that the renderer has been patched can we be assured the patching is done before the functions we are patching have been called? The short answer is No, but we can have a look at how we can achieve this.","title":"How"},{"location":"advanced_interactions/#abusing-font-loading","text":"When a lottie has external fonts, the lottie-web player waits for every font to be loaded before initializing the renderer. Which means when you have text layers, the code above works perfectly. This is nice but not all lotties need text so we'll need something better.","title":"Abusing Font Loading"},{"location":"advanced_interactions/#deferring-animation-load","text":"The trick is to not pass the lottie JSON to lottie-web until after we've patched the renderer. This is easy enough because if you call bodymovin.loadAnimation without path or animationData everything will be initialized (including the renderer) and only the JSON loading step is missing. We can use this to patch the renderer before loading the animation: load(lottie, resize = true) { // Options var options = { container: this.container, renderer: 'svg', loop: true, autoplay: true, ...this.custom_options, // Note that animationData is deferred }; if ( resize ) { this.container.style.width = lottie.w + \"px\"; this.container.style.height = lottie.h + \"px\"; } // Clean up this.clear(); // Setup handlers this.handlers = {}; if ( lottie.events ) { for ( var [name, func] of Object.entries(lottie.events) ) { this.handlers[name] = this.expression_to_event_handler(func); this.container.addEventListener(name, this._container_event_listener); } } // Create lottie player this.anim = bodymovin.loadAnimation(options); this._patch_renderer(); this.anim.addEventListener(\"DOMLoaded\", this._lottie_loaded_event.bind(this)); // Clone because the player modifies the passed object var animation_data = this.lottie_clone(lottie); // Load animation separately so we can patch the renderer this.anim.setupAnimation(animation_data); } Note that anim.setupAnimation is available from lottie-web version 5.8.0. If you have earlier versions, you should call anim.configAnimation instead.","title":"Deferring Animation Load"},{"location":"advanced_interactions/#triggering-new-events","text":"We know how to make the lottie react to DOM events, but what if we want to make the DOM react to events triggered from the lottie? We can use the patching setup just discussed to also add events on the other direction, the only thing we need is adding a method to thisComp , so it's invokable from the expressions and make it trigger DOM events. The trick is to patch thisComp in the right place, fortunately we've already done the bulk of the work so we just need to add some more code when the animation has been loaded: _lottie_load_event() { let ev = new Event(\"load\", {}); this.container.dispatchEvent(ev); for ( let layer of this.layer_elements ) layer.dispatchEvent(ev); // We add a method for triggering events from the lottie this.thisComp.trigger_event = (function(type, detail){ this.container.dispatchEvent(new CustomEvent(\"lottie.\" + type, {detail})); }).bind(this); } Then you can add event listeners to the element containing the lottie animation.","title":"Triggering new events"},{"location":"advanced_interactions/#resulting-wrapper","text":"Here's the same wrapper class as described earlier, but with patching code applied to support the load event and layer events. class LottieInteractionPlayer { constructor(container, custom_options={}) { if ( typeof container == \"string\" ) this.container = document.getElementById(container); else this.container = container; this.anim = null; this.custom_options = custom_options; // needed by keyup/down if ( !container.hasAttribute(\"tabindex\") ) container.setAttribute(\"tabindex\", \"0\"); this.handlers = {}; this._container_event_listener = this.container_event.bind(this); } // Deep copy lottie JSON lottie_clone(json) { return JSON.parse(JSON.stringify(json)); } load(lottie, resize = true) { // Options var options = { container: this.container, renderer: 'svg', loop: true, autoplay: true, ...this.custom_options, // Note that animationData is deferred }; if ( resize ) { this.container.style.width = lottie.w + \"px\"; this.container.style.height = lottie.h + \"px\"; } // Clean up this.clear(); // Setup handlers this.handlers = {}; if ( lottie.events ) { for ( var [name, func] of Object.entries(lottie.events) ) { this.handlers[name] = this.expression_to_event_handler(func); this.container.addEventListener(name, this._container_event_listener); } } // Create lottie player this.anim = bodymovin.loadAnimation(options); this._patch_renderer(); // Clone because the player modifies the passed object var animation_data = this.lottie_clone(lottie); // Load animation separately so we can patch the renderer this.anim.setupAnimation(animation_data); } _patch_renderer() { // We patch initItems to trigger an event before any expression is evaluated: var old_init = this.anim.renderer.initItems.bind(this.anim.renderer); var post_init = this._lottie_load_event.bind(this) this.anim.renderer.initItems = function(){ old_init(); post_init(); }; // We patch createItem to add event listener. // It takes the JSON layer as input and returns the renderer later object this.layer_elements = []; var old_create = this.anim.renderer.createItem.bind(this.anim.renderer); this.anim.renderer.createItem = (function(layer){ var item = old_create(layer); this._create_item_event(layer, item); return item; }).bind(this); } _create_item_event(lottie, item) { // lottie is the JSON layer // item.layerElement is the DOM element for this layer // item.layerInterface is the expression thisLayer object if ( !lottie.events ) return; // Create a dummy element for Null layers and the like, // it makes it easier to listen for `load` events let element = item.layerElement ?? document.createElement(\"div\"); // Keep track of layer elements so they can have the `load` event too this.layer_elements.push(element); for ( let [name, func] of Object.entries(lottie.events) ) { let handler = this.expression_to_event_handler(func); function listener(ev) { this.prepare_lottie_event(ev); this.handle_lottie_event(ev, handler, item.layerInterface); } element.addEventListener(name, listener.bind(this)); } } _lottie_load_event() { let ev = new Event(\"load\", {}); this.container.dispatchEvent(ev); for ( let layer of this.layer_elements ) layer.dispatchEvent(ev); // We add a method for triggering events from the lottie this.thisComp.trigger_event = (function(type, detail){ this.container.dispatchEvent(new CustomEvent(\"lottie.\" + type, {detail})); }).bind(this); } // Destroy the animation clear() { if ( this.anim != null ) { try { this.anim.destroy(); this.anim = null; } catch ( e ) {} } for ( let name of Object.keys(this.handlers) ) this.container.removeEventListener(name, this._container_event_listener); } // Get the expression `thisComp` global get thisComp() { return this.anim.renderer.compInterface; } // Get the expression `time` global get time() { return this.anim.renderer.renderedFrame / this.anim.renderer.globalData.frameRate; } // Get an expression layer layer(name) { return this.thisComp(name); } // Handles an event from the container element container_event(ev) { this.prepare_lottie_event(ev); if ( this.handlers[ev.type] ) this.handle_lottie_event(ev, this.handlers[ev.type], null); } // Adds useful attributes to an event object prepare_lottie_event(ev) { if ( ev.clientX !== undefined ) { var rect = this.container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * this.thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * this.thisComp.height; } } // Handles an event given a handler handle_lottie_event(ev, handler, layer) { handler(ev, this.thisComp, this.time, layer); } // Sets up an event handler expression_to_event_handler(expr) { return Function(\"event\", \"thisComp\", \"time\", \"thisLayer\", expr); } } class LottieInteractionPlayer { constructor(container, custom_options={}) { if ( typeof container == \"string\" ) this.container = document.getElementById(container); else this.container = container; this.anim = null; this.custom_options = custom_options; // needed by keyup/down if ( !container.hasAttribute(\"tabindex\") ) container.setAttribute(\"tabindex\", \"0\"); this.handlers = {}; this._container_event_listener = this.container_event.bind(this); } // Deep copy lottie JSON lottie_clone(json) { return JSON.parse(JSON.stringify(json)); } load(lottie, resize = true) { // Options var options = { container: this.container, renderer: 'svg', loop: true, autoplay: true, ...this.custom_options, // Note that animationData is deferred }; if ( resize ) { this.container.style.width = lottie.w + \"px\"; this.container.style.height = lottie.h + \"px\"; } // Clean up this.clear(); // Setup handlers this.handlers = {}; if ( lottie.events ) { for ( var [name, func] of Object.entries(lottie.events) ) { this.handlers[name] = this.expression_to_event_handler(func); this.container.addEventListener(name, this._container_event_listener); } } // Create lottie player this.anim = bodymovin.loadAnimation(options); this._patch_renderer(); // Clone because the player modifies the passed object var animation_data = this.lottie_clone(lottie); // Load animation separately so we can patch the renderer this.anim.setupAnimation(animation_data); } _patch_renderer() { // We patch initItems to trigger an event before any expression is evaluated: var old_init = this.anim.renderer.initItems.bind(this.anim.renderer); var post_init = this._lottie_load_event.bind(this) this.anim.renderer.initItems = function(){ old_init(); post_init(); }; // We patch createItem to add event listener. // It takes the JSON layer as input and returns the renderer later object this.layer_elements = []; var old_create = this.anim.renderer.createItem.bind(this.anim.renderer); this.anim.renderer.createItem = (function(layer){ var item = old_create(layer); this._create_item_event(layer, item); return item; }).bind(this); } _create_item_event(lottie, item) { // lottie is the JSON layer // item.layerElement is the DOM element for this layer // item.layerInterface is the expression thisLayer object if ( !lottie.events ) return; // Create a dummy element for Null layers and the like, // it makes it easier to listen for `load` events let element = item.layerElement ?? document.createElement(\"div\"); // Keep track of layer elements so they can have the `load` event too this.layer_elements.push(element); for ( let [name, func] of Object.entries(lottie.events) ) { let handler = this.expression_to_event_handler(func); function listener(ev) { this.prepare_lottie_event(ev); this.handle_lottie_event(ev, handler, item.layerInterface); } element.addEventListener(name, listener.bind(this)); } } _lottie_load_event() { let ev = new Event(\"load\", {}); this.container.dispatchEvent(ev); for ( let layer of this.layer_elements ) layer.dispatchEvent(ev); // We add a method for triggering events from the lottie this.thisComp.trigger_event = (function(type, detail){ this.container.dispatchEvent(new CustomEvent(\"lottie.\" + type, {detail})); }).bind(this); } // Destroy the animation clear() { if ( this.anim != null ) { try { this.anim.destroy(); this.anim = null; } catch ( e ) {} } for ( let name of Object.keys(this.handlers) ) this.container.removeEventListener(name, this._container_event_listener); } // Get the expression `thisComp` global get thisComp() { return this.anim.renderer.compInterface; } // Get the expression `time` global get time() { return this.anim.renderer.renderedFrame / this.anim.renderer.globalData.frameRate; } // Get an expression layer layer(name) { return this.thisComp(name); } // Handles an event from the container element container_event(ev) { this.prepare_lottie_event(ev); if ( this.handlers[ev.type] ) this.handle_lottie_event(ev, this.handlers[ev.type], null); } // Adds useful attributes to an event object prepare_lottie_event(ev) { if ( ev.clientX !== undefined ) { var rect = this.container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * this.thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * this.thisComp.height; } } // Handles an event given a handler handle_lottie_event(ev, handler, layer) { handler(ev, this.thisComp, this.time, layer); } // Sets up an event handler expression_to_event_handler(expr) { return Function(\"event\", \"thisComp\", \"time\", \"thisLayer\", expr); } }","title":"Resulting Wrapper"},{"location":"advanced_interactions/#animation-or-interaction","text":"It's possible to use the custom load to detect whether the lottie is being played in an environment that supports the custom events. The following example is similar to the click example from level 7 but when a player doesn't have interaction support, the star moves around on its own. Lottie HTML CSS Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"events\": { \"click\": \"var star = thisComp('star'); star.px = event.lottie_x; star.py = event.lottie_y;\", \"load\": \"thisComp('star').interactive = true;\" }, \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 0], \"x\": ` // Initialization if ( thisLayer.px === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; if ( !thisLayer.interactive ) { thisLayer.dx = 1; thisLayer.dy = 1; thisLayer.prev_time = 0; } } if ( !thisLayer.interactive ) { if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; thisLayer.px += thisLayer.dx * dt * 100; thisLayer.py += thisLayer.dy * dt * 120; var radius = thisLayer.content(1).outerRadius; if ( thisLayer.px < radius ) thisLayer.dx = 1; else if ( thisLayer.px > thisComp.width - radius ) thisLayer.dx = -1; if ( thisLayer.py < radius ) thisLayer.dy = 1; else if ( thisLayer.py > thisComp.height - radius ) thisLayer.dy = -1; } // Set value var $bm_rt = [thisLayer.px, thisLayer.py]; `}}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], } } ] } ] } <div id=\"level9_parent\"> <div id=\"level9_not_interactive\"></div> <div id=\"level9_interactive\"></div> </div> #level9_parent { display: flex; } #level9_interactive, #level9_not_interactive { border: 1px solid #ccc; width: 50%; box-sizing: border-box; } var options = { container: document.getElementById(\"level9_not_interactive\"), renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); var player = new LottieInteractionPlayer(document.getElementById(\"level9_interactive\")); player.load(json, false); #level9_parent { display: flex; } #level9_interactive, #level9_not_interactive { border: 1px solid #ccc; width: 50%; box-sizing: border-box; } (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"events\": { \"click\": \"var star = thisComp('star'); star.px = event.lottie_x; star.py = event.lottie_y;\", \"load\": \"thisComp('star').interactive = true;\" }, \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 0], \"x\": ` // Initialization if ( thisLayer.px === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; if ( !thisLayer.interactive ) { thisLayer.dx = 1; thisLayer.dy = 1; thisLayer.prev_time = 0; } } if ( !thisLayer.interactive ) { if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; thisLayer.px += thisLayer.dx * dt * 100; thisLayer.py += thisLayer.dy * dt * 120; var radius = thisLayer.content(1).outerRadius; if ( thisLayer.px < radius ) thisLayer.dx = 1; else if ( thisLayer.px > thisComp.width - radius ) thisLayer.dx = -1; if ( thisLayer.py < radius ) thisLayer.dy = 1; else if ( thisLayer.py > thisComp.height - radius ) thisLayer.dy = -1; } // Set value var $bm_rt = [thisLayer.px, thisLayer.py]; `}}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], } } ] } ] } ; var options = { container: document.getElementById(\"level9_not_interactive\"), renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); var player = new LottieInteractionPlayer(document.getElementById(\"level9_interactive\")); player.load(json, false); })();","title":"Animation or Interaction"},{"location":"advanced_interactions/#lottie-button-example","text":"This example uses everything we discussed so far. A quick note: to avoid clicks going to the wrong layer we need to define some CSS that gets rid of pointer events for layers we don't want to click. Lottie Script HTML CSS Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"fonts\": {\"list\":[ { \"ascent\": 72, \"fFamily\": \"Roboto\", \"fName\": \"Roboto Regular\", \"fStyle\": \"Regular\", \"fPath\": \"https://fonts.googleapis.com/css2?family=Roboto&display=swap\", \"origin\": 1, } ]}, \"layers\": [ { \"ty\": 5, \"ip\": 0, \"op\": 60, \"st\": 0, \"parent\": 1, \"cl\": \"no-mouse\", \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 25]}, }, \"t\": { \"a\": [], \"d\": { \"x\": \"var $bm_rt = 'Clicks: ' + thisComp('button').clicks;\", \"k\": [ { \"s\": { \"f\": \"Roboto Regular\", \"fc\": [0, 0, 0], \"s\": 70, \"t\": \"\", \"j\": 2, }, \"t\": 0 } ] }, \"m\": { \"a\": {\"a\": 0, \"k\": [0,0]}, \"g\": 3 }, \"p\": {} } }, { \"ty\": 4, \"nm\": \"button\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ind\": 1, \"cl\": \"lottie-button\", \"events\": { \"load\": \"thisLayer.clicks = 0;\", \"click\": \"thisLayer.clicks += 1; thisComp.trigger_event('click', {clicks: thisLayer.clicks});\", \"mouseenter\": \"thisLayer.highlighted = true;\", \"mouseleave\": \"thisLayer.highlighted = false;\" }, \"ks\": { \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": { \"a\": 0, \"k\": [100, 100], \"x\": \"var sz = thisLayer.highlighted ? 120 : 100; var $bm_rt = [sz, sz];\" } }, \"shapes\": [ { \"ty\": \"rc\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [350, 90]}, \"r\": {\"a\": 0, \"k\": 3}, }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 1, 0]}, \"w\": {\"a\": 0, \"k\": 1}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 50, \"x\": \"var $bm_rt = thisLayer.highlighted ? 70 : 30;\"}, \"c\": {\"a\": 0, \"k\": [0.4, 1, 0.4]} } ] } ] } var container = document.getElementById(\"level9_button\"); var player = new LottieInteractionPlayer(container); player.load(json); container.addEventListener(\"lottie.click\", ev => document.getElementById(\"level9_outer\").innerText = `Lottie clicked ${ev.detail.clicks} times` ); <div id=\"level9_button\"></div> <div id=\"level9_outer\">Button not clicked</div> .no-mouse { pointer-events: none; } .lottie-button { cursor: pointer; } Button not clicked .no-mouse { pointer-events: none; } .lottie-button { cursor: pointer; } (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"fonts\": {\"list\":[ { \"ascent\": 72, \"fFamily\": \"Roboto\", \"fName\": \"Roboto Regular\", \"fStyle\": \"Regular\", \"fPath\": \"https://fonts.googleapis.com/css2?family=Roboto&display=swap\", \"origin\": 1, } ]}, \"layers\": [ { \"ty\": 5, \"ip\": 0, \"op\": 60, \"st\": 0, \"parent\": 1, \"cl\": \"no-mouse\", \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 25]}, }, \"t\": { \"a\": [], \"d\": { \"x\": \"var $bm_rt = 'Clicks: ' + thisComp('button').clicks;\", \"k\": [ { \"s\": { \"f\": \"Roboto Regular\", \"fc\": [0, 0, 0], \"s\": 70, \"t\": \"\", \"j\": 2, }, \"t\": 0 } ] }, \"m\": { \"a\": {\"a\": 0, \"k\": [0,0]}, \"g\": 3 }, \"p\": {} } }, { \"ty\": 4, \"nm\": \"button\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ind\": 1, \"cl\": \"lottie-button\", \"events\": { \"load\": \"thisLayer.clicks = 0;\", \"click\": \"thisLayer.clicks += 1; thisComp.trigger_event('click', {clicks: thisLayer.clicks});\", \"mouseenter\": \"thisLayer.highlighted = true;\", \"mouseleave\": \"thisLayer.highlighted = false;\" }, \"ks\": { \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": { \"a\": 0, \"k\": [100, 100], \"x\": \"var sz = thisLayer.highlighted ? 120 : 100; var $bm_rt = [sz, sz];\" } }, \"shapes\": [ { \"ty\": \"rc\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [350, 90]}, \"r\": {\"a\": 0, \"k\": 3}, }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 1, 0]}, \"w\": {\"a\": 0, \"k\": 1}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 50, \"x\": \"var $bm_rt = thisLayer.highlighted ? 70 : 30;\"}, \"c\": {\"a\": 0, \"k\": [0.4, 1, 0.4]} } ] } ] } ; var container = document.getElementById(\"level9_button\"); var player = new LottieInteractionPlayer(container); player.load(json); container.addEventListener(\"lottie.click\", ev => document.getElementById(\"level9_outer\").innerText = `Lottie clicked ${ev.detail.clicks} times` ); })();","title":"Lottie Button Example"},{"location":"advanced_interactions/#3d","text":"Everything discussed so far was for the lottie-web svg renderer but all the patching works with the html renderer as well. The html renderer supports 3D layers so we can make an interactive 3D scene with little effort. The main caveat is that you need to set position: relative on the container element. On the example below you can click to capture the mouse then have first-person controls. Lottie Script HTML CSS Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 180, \"fr\": 60, \"w\": 512, \"h\": 512, \"fonts\": { \"list\": [] }, \"assets\": [], \"layers\": [ { \"nm\": \"Camera\", \"ty\": 13, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ 0, 0, -10 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 0 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"pe\": { \"a\": 0, \"k\": 256 }, \"ddd\": 1 }, { \"nm\": \"Move Parent\", \"ty\": 3, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"a\": { \"a\": 0, \"k\": [ 0, 0, 0 ], \"x\": \"var dt = thisComp.time_delta(thisLayer, time);\\n\\n if ( thisComp.mouse_dx )\\n {\\n thisComp.char_angle -= dt * thisComp.mouse_dx / 8 * Math.PI;\\n thisComp.mouse_dx = 0;\\n }\\n\\n if ( thisComp.mouse_dy )\\n {\\n thisComp.look_angle += dt * thisComp.mouse_dy / 8 * Math.PI;\\n thisComp.mouse_dy = 0;\\n }\\n\\n\\n var left = thisComp.keys_pressed.ArrowLeft || thisComp.keys_pressed.a;\\n var right = thisComp.keys_pressed.ArrowRight || thisComp.keys_pressed.d;\\n var dx = 0;\\n if ( left && right )\\n dx = 0;\\n else if ( left )\\n dx = -1;\\n else if ( right )\\n dx = 1;\\n\\n var up = thisComp.keys_pressed.ArrowUp || thisComp.keys_pressed.w;\\n var down = thisComp.keys_pressed.ArrowDown || thisComp.keys_pressed.s;\\n var dz = 0;\\n if ( up && down )\\n dz = 0;\\n else if ( up )\\n dz = 1;\\n else if ( down )\\n dz = -1;\\n\\n thisLayer.char_x += dz * dt * -200 * Math.sin(thisComp.char_angle);\\n thisLayer.char_z += dz * dt * 200 * Math.cos(thisComp.char_angle);\\n\\n thisLayer.char_x += dx * dt * -200 * Math.sin(thisComp.char_angle - Math.PI / 2);\\n thisLayer.char_z += dx * dt * 200 * Math.cos(thisComp.char_angle - Math.PI / 2);\\n\\n var $bm_rt = [thisLayer.char_x, thisLayer.char_y, thisLayer.char_z];\\n \\n/**/\" }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 0 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ], \"x\": \"var $bm_rt = [thisComp.look_angle * 180 / Math.PI, thisComp.char_angle * 180 / Math.PI, 0];\\n \\n/**/\" } }, \"ind\": 1, \"ddd\": 1, \"events\": { \"load\": \"thisLayer.char_x = 0;\\n thisLayer.char_z = 0;\\n thisLayer.char_y = 0;\\n \\n/**/\" } }, { \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ 0, 0, 200 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 0 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"ddd\": 1, \"parent\": 1, \"shapes\": [ { \"ty\": \"rc\", \"s\": { \"a\": 0, \"k\": [ 200, 200 ] }, \"p\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"r\": { \"a\": 0, \"k\": 0 } }, { \"ty\": \"fl\", \"c\": { \"a\": 0, \"k\": [ 0.5, 0.5, 1 ] }, \"o\": { \"a\": 0, \"k\": 100 } } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ 0, 0, -200 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 0 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"ddd\": 1, \"parent\": 1, \"shapes\": [ { \"ty\": \"rc\", \"s\": { \"a\": 0, \"k\": [ 200, 200 ] }, \"p\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"r\": { \"a\": 0, \"k\": 0 } }, { \"ty\": \"fl\", \"c\": { \"a\": 0, \"k\": [ 0.5, 0.5, 0 ] }, \"o\": { \"a\": 0, \"k\": 100 } } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ 200, 0, 0 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 90 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"ddd\": 1, \"parent\": 1, \"shapes\": [ { \"ty\": \"rc\", \"s\": { \"a\": 0, \"k\": [ 200, 200 ] }, \"p\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"r\": { \"a\": 0, \"k\": 0 } }, { \"ty\": \"fl\", \"c\": { \"a\": 0, \"k\": [ 1, 0.5, 0.5 ] }, \"o\": { \"a\": 0, \"k\": 100 } } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ -200, 0, 0 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 90 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"ddd\": 1, \"parent\": 1, \"shapes\": [ { \"ty\": \"rc\", \"s\": { \"a\": 0, \"k\": [ 200, 200 ] }, \"p\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"r\": { \"a\": 0, \"k\": 0 } }, { \"ty\": \"fl\", \"c\": { \"a\": 0, \"k\": [ 0, 0.5, 0.5 ] }, \"o\": { \"a\": 0, \"k\": 100 } } ] } ], \"events\": { \"keydown\": \"thisComp.keys_pressed[event.key] = true;\\n\\n if ( event.key != \\\"F5\\\" )\\n event.preventDefault();\\n \\n/**/\", \"keyup\": \"thisComp.keys_pressed[event.key] = false;\\n\\n if ( event.key != \\\"F5\\\" )\\n event.preventDefault();\\n \\n/**/\", \"load\": \"thisComp.keys_pressed = {};\\n thisComp.mouse_dx = 0;\\n thisComp.mouse_dy = 0;\\n thisComp.char_angle = 0;\\n thisComp.look_angle = 0;\\n thisComp.time_delta = function (thisLayer, time) {\\n if ( thisLayer.last_time === undefined || time < thisLayer.last_time )\\n {\\n thisLayer.last_time = time;\\n return 0;\\n }\\n\\n var dt = time - thisLayer.last_time;\\n thisLayer.last_time = time;\\n return dt;\\n };\\n \\n/**/\", \"mouseenter\": \"thisComp.mouse_old_x = thisComp.mouse_x = event.lottie_x;\\n thisComp.mouse_old_y = thisComp.mouse_y = event.lottie_x;\\n \\n/**/\", \"mouseleave\": \"thisComp.mouse_old_x = thisComp.mouse_x = event.lottie_x;\\n thisComp.mouse_old_y = thisComp.mouse_y = event.lottie_x;\\n \\n/**/\", \"mousemove\": \"thisComp.mouse_dx += event.movementX;\\n thisComp.mouse_dy += event.movementY;\\n \\n/**/\" }, \"ddd\": 1 } var container = document.getElementById(\"level9_3d\"); var player = new LottieInteractionPlayer(container, {renderer: \"html\"}); player.load(json); <div id=\"level9_3d\" onclick=\"this.requestPointerLock();\"></div> #level9_3d { position: relative; } #level9_3d { position: relative; } (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 180, \"fr\": 60, \"w\": 512, \"h\": 512, \"fonts\": { \"list\": [] }, \"assets\": [], \"layers\": [ { \"nm\": \"Camera\", \"ty\": 13, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ 0, 0, -10 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 0 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"pe\": { \"a\": 0, \"k\": 256 }, \"ddd\": 1 }, { \"nm\": \"Move Parent\", \"ty\": 3, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"a\": { \"a\": 0, \"k\": [ 0, 0, 0 ], \"x\": \"var dt = thisComp.time_delta(thisLayer, time);\\n\\n if ( thisComp.mouse_dx )\\n {\\n thisComp.char_angle -= dt * thisComp.mouse_dx / 8 * Math.PI;\\n thisComp.mouse_dx = 0;\\n }\\n\\n if ( thisComp.mouse_dy )\\n {\\n thisComp.look_angle += dt * thisComp.mouse_dy / 8 * Math.PI;\\n thisComp.mouse_dy = 0;\\n }\\n\\n\\n var left = thisComp.keys_pressed.ArrowLeft || thisComp.keys_pressed.a;\\n var right = thisComp.keys_pressed.ArrowRight || thisComp.keys_pressed.d;\\n var dx = 0;\\n if ( left && right )\\n dx = 0;\\n else if ( left )\\n dx = -1;\\n else if ( right )\\n dx = 1;\\n\\n var up = thisComp.keys_pressed.ArrowUp || thisComp.keys_pressed.w;\\n var down = thisComp.keys_pressed.ArrowDown || thisComp.keys_pressed.s;\\n var dz = 0;\\n if ( up && down )\\n dz = 0;\\n else if ( up )\\n dz = 1;\\n else if ( down )\\n dz = -1;\\n\\n thisLayer.char_x += dz * dt * -200 * Math.sin(thisComp.char_angle);\\n thisLayer.char_z += dz * dt * 200 * Math.cos(thisComp.char_angle);\\n\\n thisLayer.char_x += dx * dt * -200 * Math.sin(thisComp.char_angle - Math.PI / 2);\\n thisLayer.char_z += dx * dt * 200 * Math.cos(thisComp.char_angle - Math.PI / 2);\\n\\n var $bm_rt = [thisLayer.char_x, thisLayer.char_y, thisLayer.char_z];\\n \\n/**/\" }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 0 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ], \"x\": \"var $bm_rt = [thisComp.look_angle * 180 / Math.PI, thisComp.char_angle * 180 / Math.PI, 0];\\n \\n/**/\" } }, \"ind\": 1, \"ddd\": 1, \"events\": { \"load\": \"thisLayer.char_x = 0;\\n thisLayer.char_z = 0;\\n thisLayer.char_y = 0;\\n \\n/**/\" } }, { \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ 0, 0, 200 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 0 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"ddd\": 1, \"parent\": 1, \"shapes\": [ { \"ty\": \"rc\", \"s\": { \"a\": 0, \"k\": [ 200, 200 ] }, \"p\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"r\": { \"a\": 0, \"k\": 0 } }, { \"ty\": \"fl\", \"c\": { \"a\": 0, \"k\": [ 0.5, 0.5, 1 ] }, \"o\": { \"a\": 0, \"k\": 100 } } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ 0, 0, -200 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 0 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"ddd\": 1, \"parent\": 1, \"shapes\": [ { \"ty\": \"rc\", \"s\": { \"a\": 0, \"k\": [ 200, 200 ] }, \"p\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"r\": { \"a\": 0, \"k\": 0 } }, { \"ty\": \"fl\", \"c\": { \"a\": 0, \"k\": [ 0.5, 0.5, 0 ] }, \"o\": { \"a\": 0, \"k\": 100 } } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ 200, 0, 0 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 90 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"ddd\": 1, \"parent\": 1, \"shapes\": [ { \"ty\": \"rc\", \"s\": { \"a\": 0, \"k\": [ 200, 200 ] }, \"p\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"r\": { \"a\": 0, \"k\": 0 } }, { \"ty\": \"fl\", \"c\": { \"a\": 0, \"k\": [ 1, 0.5, 0.5 ] }, \"o\": { \"a\": 0, \"k\": 100 } } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ -200, 0, 0 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 90 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"ddd\": 1, \"parent\": 1, \"shapes\": [ { \"ty\": \"rc\", \"s\": { \"a\": 0, \"k\": [ 200, 200 ] }, \"p\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"r\": { \"a\": 0, \"k\": 0 } }, { \"ty\": \"fl\", \"c\": { \"a\": 0, \"k\": [ 0, 0.5, 0.5 ] }, \"o\": { \"a\": 0, \"k\": 100 } } ] } ], \"events\": { \"keydown\": \"thisComp.keys_pressed[event.key] = true;\\n\\n if ( event.key != \\\"F5\\\" )\\n event.preventDefault();\\n \\n/**/\", \"keyup\": \"thisComp.keys_pressed[event.key] = false;\\n\\n if ( event.key != \\\"F5\\\" )\\n event.preventDefault();\\n \\n/**/\", \"load\": \"thisComp.keys_pressed = {};\\n thisComp.mouse_dx = 0;\\n thisComp.mouse_dy = 0;\\n thisComp.char_angle = 0;\\n thisComp.look_angle = 0;\\n thisComp.time_delta = function (thisLayer, time) {\\n if ( thisLayer.last_time === undefined || time < thisLayer.last_time )\\n {\\n thisLayer.last_time = time;\\n return 0;\\n }\\n\\n var dt = time - thisLayer.last_time;\\n thisLayer.last_time = time;\\n return dt;\\n };\\n \\n/**/\", \"mouseenter\": \"thisComp.mouse_old_x = thisComp.mouse_x = event.lottie_x;\\n thisComp.mouse_old_y = thisComp.mouse_y = event.lottie_x;\\n \\n/**/\", \"mouseleave\": \"thisComp.mouse_old_x = thisComp.mouse_x = event.lottie_x;\\n thisComp.mouse_old_y = thisComp.mouse_y = event.lottie_x;\\n \\n/**/\", \"mousemove\": \"thisComp.mouse_dx += event.movementX;\\n thisComp.mouse_dy += event.movementY;\\n \\n/**/\" }, \"ddd\": 1 } ; var container = document.getElementById(\"level9_3d\"); var player = new LottieInteractionPlayer(container, {renderer: \"html\"}); player.load(json); })(); document.querySelectorAll(\".nav-tabs a\").forEach( link => link.addEventListener(\"click\", e => jQuery(e.target).tab(\"show\")) );","title":"3D"},{"location":"aep/","text":"Parsing AEP Files AfterEffects Project files are the proprietary file format used by Adobe AfterEffects. It's a binary format based on the RIFX container format. The structure resembles that of a Lottie JSON exported from AE. RIFF A RIFF is composed of \"chunks\" with the following format Field Size Description Header 4 ASCII name describing the type of the chunk Size 4 uint32 size of the data section Data Size Data within the chunk RIFX is an extension of the RIFF format, the difference being RIFX uses big-endian notation for integers. A RIFF file will be structured in the same way as a chunk: Field Size Description Header 4 RIFF or RIFX Size 4 uint32 size of the chunk Format 4 Format Identifier Chunks * Rest of the chunks AEP-Specific Parsing It should always be RIFX format (big endian). The format identifier for AEP is Egg! . When parsing the RIFF structure, keep in mind the following chunks will contain other chunks: tdsn fnam pdnm And that LIST btdk contains data in a different format, and it should not be parsed as a RIFF LIST . At the end of the RIFF data, the AEP file has some XML-encoded metadata. Basic Types In the chunk data descriptions, the types described below will be used to show how to interpret the raw binary data. Type Size Description id 4 ASCII-encoded chunk identifier uint16 2 Unsigned integer uint32 4 Unsigned integer sint16 2 Twos-complement signed integer float32 4 IEEE float float64 8 IEEE float string * Text, usually utf-8 encoded string0 * NUL terminated string, note that you might find junk data after the NUL (This can be caused by renaming something to a shorter name) bytes * Unformatted / unknown data Time Time values are stored as uint16 . they are scaled by a factor you can find in cdta . To get the actual value in frames you need to do the following: time_frames = time_value / cdta.time_scale Additionally, layers specify a start time, which shifts all the time values by a fixed amount. If you are within a layer the expression looks like this: time_frames = (time_value + ldta.start_time) / (cdta.time_scale) Flags Flags is byte data, that will be specified using two integers: byte and bit index. You'll get the value of the flag you'll need to do the following: flag = (flags[byte] & (1 << bit)) != 0 The index of the byte here is in file order so a byte of 0 is the most significant byte. AfterEffects Logic This section assumes the file has already been parsed into RIFF chunks. Objects described here will have a nested list showing which chunks are used to represent them, you can click on the link pointing to the chunk details to get the data layout within that chunk. File Structure LIST EfdG : Effect definitions LIST ExEn Utf8 : Language used in expressions (eg: javascript-1.0 ) LIST Fold : Root folder LIST Item : Folder item (repeated, see below) Folder Item LIST Item idta : Item data Utf8 : Name cmta : (optional) Comment fiac Whether the item is the active item idta will cointain the ID of the item (referenced by layers) and the item type. The following sections descript each type of item in detail Folders idta type 1 . These contain additional items inside them. LIST Item idta : Item data (type and ID). Utf8 : Name LIST Sfdr : Folder items LIST Item : Child item (repeated) Compositions idta has type of 4 . You need to know which composition to extract as a lottie corresponds to a specific comp (with other compositions showing as assets for precomps). Structure: LIST Item idta : Item data (type and ID). Utf8 : Name cdta : Composition data LIST Layr : Layer (repeated) Each layer will show as a LIST Layr in the LIST Item . The composition will also have other type of layer LIST s: LIST DLay : Default view LIST CLay : Custom views LIST SLay : Side views LIST SecL : Composition markers layer If the comp uses essential graphics , it will have the appropriate LIST s as well. Assets idta type 7 . These can have different kinds of contents. Look for sspc to get the size for visual assets. The type of asset is defined in the first 4 bytes of opti . Solids For some the Item has an Utf8 but it seems to always be empty need to find the name from opti . LIST Item idta : Item data (type and ID). Utf8 : Name (not used for solids) LIST Pin sspc : Contains info like width / height) opti : Data Files LIST Item idta : Item data (type and ID). Utf8 : Name LIST Pin sspc : Contains info like width / height) opti : Check this to tell files apart from solids LIST Als2 alas : File info as JSON. LIST CLRS Utf8 : JSON containing base64-encoded ICC color profiles. The Uft8 in Item only has a value if the user has set an explicit value for the name. The file path is in alas , parse it as JSON and get fullpath . the first 4 bytes of opti will change based on the file format. Layers LIST Layr : Layer ldta : Common layer data, including layer type. Utf8 : Name cmta : (optional) Comment LIST tdgp : Property group When parsing layer transforms, keep in mind the default position is the center of the comp. For shape layers, the default anchor is [0, 0]; for precomp layers the default anchor is the center of the comp (same as position). Asset Layer Layer type 0 . (Also known as AVLayer in AE) They have a non-zero Source ID in ldta . Precomp, image, and similar layers will point to an appropriate asset. Several layer types point to a solid asset, you need to check the layer attributes to distinguish between them: Solid layers Null layers Adjustment layers Light Layer Layer type 1 . For light settings look for the match name ADBE Light Options Group . Camera Layer Layer type 2 . For camera settings look for the match name ADBE Camera Options Group . Text Layer Layer type 3 . For text contents look for the match name ADBE Text Properties . Shape Layer Layer type 4 . For shapes look for the match name ADBE Root Vectors Group . Property Groups Most objects are described as a property groups. These have the following structure: LIST tdgp : Property group tdsb : Flags tdsn > Utf8 : Name ... (properties) tdmn : ADBE Group End (marks the end of the group) Then follows a list of properties, all introduced by their match name ( tdmn ). After a match name, you'll find the data for the property, which might be an actual propert (see the section below), other groups, or layer effects. This structure is used both for objects (that have a fixed set of properties) and groups/collections whose contents might vary. For objects with fixed properties you will not find duplicate match names but you might find duplicates within collections. Properties Properties, like objects are introduced by their match name, the chunks following that depends on the type of property. The core of a property is defined in LIST tdbs with the following structure: LIST tdbs : Property definition tdb4 : Tells you the type, number of components, whether it's animated cdat : Value (if not animated) tdsn : Utf8 : Human-readable Name Utf8 : Optional expression LIST list : Keyframes (if animated) lhd3 : Tells you the number of keyframes ldat : Keyframe data and values For simple properties, with vector or scalar values, you get the structure above. For more complex properties, you get an outer object that contains that data as well as a list of values. You'll get the value for the keyframes (or the static value) from that list. Color properties are laid out as ARGB floats in [0, 255]. Note that the keyframe structure in ldat changes based on the info found in tdb4 . Shape LIST om-s LIST tdbs : Property definition LIST omks : Keyframe values LIST shap : Bezier Data (repeated) shph : Bezier metadata (whether it's closed and bounding box) LIST list lhd3 : Bezier point list metadata ldat : Bezier points relative to shph Gradient Colors LIST GCst LIST tdbs : Property definition LIST GCky : Keyframe values Utf8 Gradient XML (repeated) Orientation LIST otst LIST tdbs : Property definition LIST otky : Keyframe values otda 3D vector (repeated) Marker LIST mrst LIST tdbs : Property definition LIST mrky : Keyframe values Nmrd Marker (repeated) NmHd Marker properties Utf8 Name Text Document LIST btds LIST tdbs : Property definition LIST btdk : COS-encoded data Layer Follows the usual LIST tdbs , check tdb4 for the \"Integer\" property type. LIST tdbs tdb4 cdat : Should always be [0.0] tdpi : Layer index tdps : Layer source Mask Index Follows the usual LIST tdbs , check tdb4 for the \"Integer\" property type. LIST tdbs tdb4 cdat : Should always be [0.0] tdli : Mask index Mask mkif : Basic mask properties LIST tdgp : Animated properties Layer Overrides LIST OvG2 CprC : uint32 ? Layer Source Alternate blsv : uint32 Layer index? blsi : uint32 Chunk naming Most of property related chunks seem to contain the prefix td in their name: tdgp : property group tdsb : property group flags tdsn : property group name tdmn : property match name tdbs : property definition tdb4 : property details I'm not sure what td stands for my best guess would be \"Track Data\". For properties with external values, the naming convention generally is XXst for the parent chunk and XXky for the values (where XX changes depending on the type and its meaning is fairly obvious). I'm not sure what st stands for, ky most likely stands for \"keyframes\" Expressions Bodymovin modifies expressions when converting into lottie, if you add expressions but fail to convert them, the animation might not play properly. Assets Image Defined within LIST Item , it will have idta with type 7 . Within that there's a LIST Pin , containing the following: LIST Als2 with alas , which in turn has some JSON. Inside the JSON you can get fullpath . opti : Contains the asset name. LIST CLRS , the last Utf8 here has some JSON with a base64-encoded color profile. Shapes Stroke Dashes Look for the match name ADBE Vector Stroke Dashes . Inside of it you'll find a bunch of properties with match name ADBE Vector Stroke Dash n or ADBE Vector Stroke Gap n , where n is an ineger starting from 1. You will also find a single ADBE Vector Stroke Offset . They are all animatable lengths and fairly straighforward. Note that lottie-web wants a unique \"name\" for these, and the file doesn't provide this but you can generate one based on the match name. Transforms Split Position When a position is split the Position attribute is removed and you can get the data from Position_0 and Position_1. For some reason Position_0 and Position_1 are present (with value 0 ) even when the position is not split. Their tdsb seems to change from 1 (not split) to 3 (split). Effects The effects used in by the file are defined in the top-level chunk LIST EfdG , instanciations of these effects are present in the layers that use them. LIST EfdG : Effect definitions EfDC : Effect definition count (number of definitions) LIST EfDf : Effect definition (one per effect type used in the document) tdmn : Effect match name LIST sspc fnam > Utf8 : Effect name LIST parT : Effect parameters parn : Number of parameters tdmn : Parameter match name pard : Parameter definition pdnm : (optional) Parameter control strings You get tdmn and pard (optionally followed by pdnm for each parameter LIST tdgp : Contains the values of the first instance of this effect, can be ignored Note that the first paramter in an effect should be ignored. The effects in a later are listed under ADBE Effect Parade : tdmn : Effect match name, you'll need to find the matching definition LIST sspc fnam > Utf8 : Effect name LIST parT : You might find this here as well but it isn't consistent. Refer to LIST EfdG for the definition LIST tdgp : Parameter values, works like any other property list Essential Graphics Definition Essential graphics are defined in the following chunks inside the comp's LIST Item : LIST CIF0 LIST CIF2 LIST CIF3 They seem to have the same structure and (almost) identical values. But only CIF3 has data about groups: LIST CIF3 LIST CpS2 CsCt : seems to always have the value 0x1000000 . Utf8 : Name (Defaults to Untitled ) Utf8 : Locale? ( en_US ) CapS CsCt : seems to always have the value 0x1000000 . CapL : seems to always have the value 0 . Utf8 : Name (again, same value as before) LIST CCtl : Item (repeated) Items have the following common structure LIST CCtl LIST CpS2 Utf8 : Name LIST CapS Utf8 : Name (again) Utf8 : UUID CTyp : item type CprC : Flags Type-specific data Comment CTyp : 8 Utf8 : Comment string Utf8 : Comment string (again) CprC : 0 Group CTyp : 8 LIST StVc : Items StVS : Count Utf8 : UUID of child items (repeated) CprC : 0 Property CVal : Value CDef : Default Value Smin : Slider min value (only for scalar properties) Smax : Slider max value (only for scalar properties) CDim : Number of dimenstions (only for vector properties) LIST StVc : Enum values (only for enum properties) StVS : Count Utf8 : Value name (repeated) CprC : 1 LIST CPrp CCId : Composition ID (same as the one in idta ). CLId : Layer ID (same as the one in ldta ). Utf8 : JSON-ecoded path. The JSON is a dict where the key is a string containing a number and the values are dicts like this: index : Index for like shape groups and such, or the value 4294967295 ( 0xffffffff ) is used when there is no index matchName : Match name as per usual To find the property, something like this might work: CCId = 15 CLId = 18 json_data = { \"0\": { \"index\":4294967295, \"matchName\":\"ADBE Root Vectors Group\" }, \"1\": { \"index\":0, \"matchName\":\"ADBE Vector Group\" }, \"2\": { \"index\":4294967295, \"matchName\":\"ADBE Vectors Group\" }, \"3\": { \"index\":2, \"matchName\":\"ADBE Vector Graphic - Fill\" }, \"4\": { \"index\":4294967295, \"matchName\":\"ADBE Vector Fill Opacity\" } } property = get_layer(CCId, CLId) for item in json_data.values(): if item[\"index\"] == 0xffffffff: property = property.property(item[\"matchName\"]) else: property = property.properties[item[\"index\"]] The values in Smin , Smax , CVal , CDef depends on the type, refer to CTyp for their representation. Overrides Defined in the precomp layer under match name ADBE Layer Overrides tdmn : ADBE Layer Overrides LIST OvG2 LIST CPrp : (repeated) Utf8 : UUID of the essential property LIST tdgp : Property groups with the matching properties defined as usual. Match Names Follows a list of known match names grouped by object type. For properties that specify a default value, you should assume they have the specified value if they are not present in the AEP file. Layers Match Name Description Default ADBE Root Vectors Group shapes ADBE Layer Styles styles ADBE Transform Group ks ADBE Layer Styles sy ADBE Extrsn Options Group ADBE Material Options Group ADBE Audio Group ADBE Layer Sets ADBE Time Remapping tm ADBE Effect Parade ef ADBE Marker Markers ADBE Mask Parade masksProperties ADBE Plane Options Group ADBE Data Group ADBE Layer Overrides Essential graphincs values ADBE Source Options Group Match Name Description Default ADBE Camera Options Group Camera Layer Marks a layer as a camera layer ADBE Camera Aperture pe ADBE Camera Zoom ADBE Camera Focus Distance Match Name Description Default ADBE Mask Atom Mask ADBE Mask Shape pt ADBE Mask Offset x 0 ADBE Mask Feather [0, 0] ADBE Mask Opacity 0 100 Match Name Description Default ADBE Extrsn Options Group ADBE Bevel Direction Match Name Description Default ADBE Material Options Group ADBE Appears in Reflections ADBE Reflection Coefficient ADBE Glossiness Coefficient ADBE Fresnel Coefficient ADBE Transparency Coefficient ADBE Transp Rolloff ADBE Index of Refraction Match Name Description Default ADBE Source Options Group ADBE Layer Source Alternate Match Name Description Default ADBE Layer Styles ADBE Blend Options Group Match Name Description Default ADBE Blend Options Group ADBE Adv Blend Group Shapes Match Name Description Default ADBE Vector Group Group ADBE Vector Blend Mode bm 1 2 ADBE Vectors Group it ADBE Vector Transform Group Transform ADBE Vector Materials Group Match Name Description Default ADBE Vector Shape - Rect Rectangle ADBE Vector Shape Direction d 1 ADBE Vector Rect Position p ADBE Vector Rect Size s ADBE Vector Rect Roundness r Match Name Description Default ADBE Vector Shape - Ellipse Ellipse ADBE Vector Shape Direction d 1 ADBE Vector Ellipse Position p ADBE Vector Ellipse Size s Match Name Description Default ADBE Vector Shape - Star PolyStar ADBE Vector Shape Direction d 1 ADBE Vector Star Type sy 1 ADBE Vector Star Points pt 3 ADBE Vector Star Position p ADBE Vector Star Rotation r ADBE Vector Star Inner Radius ir ADBE Vector Star Outer Radius or ADBE Vector Star Inner Roundess is ADBE Vector Star Outer Roundess os Match Name Description Default ADBE Vector Shape - Group Path ADBE Vector Shape Direction d 1 ADBE Vector Shape ks 4 Shape Styles Match Name Description Default ADBE Vector Graphic - Fill Fill ADBE Vector Blend Mode bm 1 2 ADBE Vector Fill Color c 5 [255, 255, 0, 0] ADBE Vector Fill Opacity o 100 ADBE Vector Fill Rule r 1 1 ADBE Vector Composite Order if 2, it should be drawn over the previous shape 1 Match Name Description Default ADBE Vector Graphic - Stroke Stroke ADBE Vector Blend Mode bm 1 2 ADBE Vector Stroke Color c 5 [255, 255, 255, 255, ] ADBE Vector Stroke Opacity o 100 ADBE Vector Stroke Width w 2 ADBE Vector Stroke Line Cap lc 1 1 ADBE Vector Stroke Line Join lj 1 1 ADBE Vector Stroke Miter Limit ml2 4 ADBE Vector Stroke Dashes d ADBE Vector Stroke Taper ADBE Vector Stroke Wave ADBE Vector Composite Order if 2, it should be drawn over the previous shape 1 Match Name Description Default ADBE Vector Stroke Taper All properties are percentages in [0, 100] ADBE Vector Taper Start Length ADBE Vector Taper End Length ADBE Vector Taper Start Width ADBE Vector Taper End Width ADBE Vector Taper Start Ease ADBE Vector Taper End Ease Match Name Description Default ADBE Vector Stroke Wave ADBE Vector Taper Wave Amount ADBE Vector Taper Wave Units 1 for pixels, 2 for cycles ADBE Vector Taper Wavelength ADBE Vector Taper Wave Phase Match Name Description Default ADBE Vector Stroke Dashes ADBE Vector Stroke Offset ADBE Vector Stroke Gap # ADBE Vector Stroke Dash # Match Name Description Default ADBE Vector Graphic - G-Fill Gradient Fill ADBE Vector Blend Mode bm 1 2 ADBE Vector Grad Type t 1 ADBE Vector Grad Start Pt s ADBE Vector Grad End Pt e [100, 0] ADBE Vector Grad HiLite Length h ADBE Vector Grad HiLite Angle a ADBE Vector Grad Colors g 6 ADBE Vector Fill Opacity o 100 ADBE Vector Fill Rule r 1 1 ADBE Vector Composite Order if 2, it should be drawn over the previous shape 1 Match Name Description Default ADBE Vector Graphic - G-Stroke Gradient Stroke ADBE Vector Blend Mode bm 1 2 ADBE Vector Grad Type t 1 ADBE Vector Grad Start Pt s ADBE Vector Grad End Pt e ADBE Vector Grad HiLite Length h ADBE Vector Grad HiLite Angle a ADBE Vector Grad Colors g 6 ADBE Vector Stroke Opacity o 100 ADBE Vector Stroke Width w 2 ADBE Vector Stroke Line Cap lc 1 1 ADBE Vector Stroke Line Join lj 1 1 ADBE Vector Stroke Miter Limit ml2 ADBE Vector Stroke Dashes d ADBE Vector Stroke Taper ADBE Vector Stroke Wave ADBE Vector Composite Order if 2, it should be drawn over the previous shape 1 Shape Modifiers Match Name Description Default ADBE Vector Filter - Merge Merge ADBE Vector Merge Type mm Match Name Description Default ADBE Vector Filter - Offset Offset Path ADBE Vector Offset Amount a ADBE Vector Offset Line Join lj 1 ADBE Vector Offset Miter Limit ml Match Name Description Default ADBE Vector Filter - PB Pucker Bloat ADBE Vector PuckerBloat Amount a Match Name Description Default ADBE Vector Filter - Repeater Repeater ADBE Vector Repeater Transform tr ADBE Vector Repeater Copies c 3 ADBE Vector Repeater Offset o ADBE Vector Repeater Order m 1 Match Name Description Default ADBE Vector Filter - RC Rounded Corners ADBE Vector RoundCorner Radius r 10 Match Name Description Default ADBE Vector Filter - Trim Trim ADBE Vector Trim Start s ADBE Vector Trim End e ADBE Vector Trim Offset o ADBE Vector Trim Type m 1 Match Name Description Default ADBE Vector Filter - Twist Twist ADBE Vector Twist Angle a ADBE Vector Twist Center c Match Name Description Default ADBE Vector Filter - Roughen ADBE Vector Roughen Size ADBE Vector Roughen Detail ADBE Vector Roughen Points ADBE Vector Temporal Freq ADBE Vector Correlation ADBE Vector Temporal Phase ADBE Vector Spatial Phase ADBE Vector Random Seed Match Name Description Default ADBE Vector Filter - Wiggler ADBE Vector Xform Temporal Freq ADBE Vector Correlation ADBE Vector Temporal Phase ADBE Vector Spatial Phase ADBE Vector Random Seed ADBE Vector Wiggler Transform Match Name Description Default ADBE Vector Filter - Zigzag Zig Zag ADBE Vector Zigzag Size s 10 ADBE Vector Zigzag Detail r 5 ADBE Vector Zigzag Points pt 1 Transforms Match Name Description Default ADBE Transform Group Transform ADBE Anchor Point a 8 [0, 0] ADBE Position p Half of the comp size ADBE Position_0 Split position X ADBE Position_1 Split position Y ADBE Position_2 Split position Z ADBE Scale s 7 [1, 1] ADBE Orientation or ADBE Rotate X rx ADBE Rotate Y ry ADBE Rotate Z rz or just normal rotation 0 ADBE Opacity o 7 1 ADBE Envir Appear in Reflect Single float, probably a boolean? Match Name Description Default ADBE Vector Transform Group Transform Shape ADBE Vector Anchor Point a ADBE Vector Anchor a probably an outdated name ADBE Vector Position p ADBE Vector Scale s [100, 100] ADBE Vector Rotate X rx ADBE Vector Rotate Y ry ADBE Vector Rotate Z rz or just normal rotation ADBE Vector Rotation r ADBE Vector Skew sk ADBE Vector Skew Axis sa ADBE Vector Group Opacity o 100 Match Name Description Default ADBE Vector Repeater Transform Repeater Transform ADBE Vector Repeater Anchor Point a ADBE Vector Repeater Position p ADBE Vector Repeater Scale s 7 ADBE Vector Repeater Rotation r ADBE Vector Repeater Start Opacity so 7 1 ADBE Vector Repeater End Opacity so 7 1 Effects Match Name Description Default ADBE Tint Tint Effect ty = 20 ADBE Fill Fill Effect ty = 21 ADBE Stroke Stroke Effect ty = 22 ADBE Tritone Tritone Effect ty = 23 ADBE Pro Levels2 Pro Levels Effect ty = 24 ADBE Drop Shadow Drop Shadow Effect ty = 25 ADBE Radial Wipe Radial Wipe ty = 26 ADBE Displacement Map Displacement Map Effect ty = 27 ADBE Set Matte3 Set Matte Effect ty = 28 ADBE Gaussian Blur 2 Gaussian Blur Effect ty = 29 ADBE Twirl Twirl Effect ty = 30 ADBE MESH WARP Mesh Warp Effect ty = 31 ADBE Ripple Wavy Effect ty = 32 ADBE Spherize Spherize Effect ty = 33 ADBE FreePin3 Puppet Effect ty = 34 Match Name Description Default ADBE Effect Built In Params Marks a LIST tdgp with built-in effect properties ADBE Effect Mask Opacity Match Name Description Default ADBE Paint Group Data for the paint effect ADBE Paint Atom Contains the following properties ADBE Paint Duration ADBE Paint Shape ADBE Paint Transform Same as other transform but match names starting with ADBE Paint ADBE Paint Properties contains the following ADBE Paint Clone Layer Text Match Name Description Default ADBE Text Properties Text Data ADBE Text Document d ADBE Text Path Options p ADBE Text More Options m ADBE Text Animators a Match Name Description Default ADBE Text Animator Text Range ADBE Text Selectors s (list) ADBE Text Animator Properties a Match Name Description Default ADBE Text Selector Text Range Selector ADBE Text Percent Start s 0 ADBE Text Percent End e 100 ADBE Text Percent Offset o 0 ADBE Text Index Start s ADBE Text Index End e ADBE Text Index Offset o ADBE Text Range Advanced ADBE Text Selector Max Amount a ADBE Text Selector Smoothness sm ADBE Text Levels Max Ease xe ADBE Text Levels Min Ease ne ADBE Text Random Seed rn Match Name Description Default ADBE Text Animator Properties Text Style ADBE Text Anchor Point 3D a ADBE Text Position 3D p ADBE Text Scale 3D s ADBE Text Skew sk ADBE Text Skew Axis sa ADBE Text Rotation X rx ADBE Text Rotation Y ry ADBE Text Rotation r ADBE Text Opacity o ADBE Text Fill Color fc ADBE Text Fill Opacity fo ADBE Text Fill Hue fh ADBE Text Fill Saturation fs ADBE Text Fill Brightness fb ADBE Text Stroke Color sc ADBE Text Stroke Opacity so ADBE Text Stroke Hue sh ADBE Text Stroke Saturation ss ADBE Text Stroke Brightness sb ADBE Text Stroke Width sw ADBE Text Line Spacing ls ADBE Text Line Anchor ADBE Text Track Type ADBE Text Tracking Amount ADBE Text Character Replace ADBE Text Character Offset ADBE Text Blur Match Name Description Default ADBE Text Path Options Text Follow Path ADBE Text Path m ADBE Text Reverse Path r ADBE Text Perpendicular To Path p ADBE Text Force Align Path a ADBE Text First Margin f ADBE Text Last Margin l Match Name Description Default ADBE Text More Options Text Alignment Options ADBE Text Anchor Point Option g 1 ADBE Text Anchor Point Align a [0, 0] ADBE Text Render Order 1 ADBE Text Character Blend Mode 1 Misc Match Name Description Default ADBE Group End Indicates the end of a LIST tdgp Notes Enumerations needs to be converted from floats, but the values match. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 Blend mode has different values than Lottie, see the section below for details. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 Needs to be converted from float to int . \u21a9 \u21a9 How to parse this? \u21a9 Colors are defined as 4 floats (ARGB) in [0, 255]. \u21a9 \u21a9 Colors defined as XML . \u21a9 \u21a9 You need to multiply by 100 to get the lottie value. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 For asset layers, the anchor point is relative to the size of the asset (eg: (0.5, 0.5) would be the center). \u21a9 Enumerations Most enumerated values are the same in Lottie and AEP, this section lists the exceptions to this and enums not in lottie Blend Mode Name AEP Lottie Normal 1 0 Darken 3 4 Multiply 4 1 Color Burn 5 7 Linear Burn 6 Darker Color 7 Lighten 9 5 Screen 10 2 Color Dodge 11 6 Linear Dodge 12 Lighter Color 13 Overlay 15 3 Soft Light 16 9 Hard Light 17 8 Linear Light 18 Vivid Light 19 Pin Light 20 Hard Mix 21 16 Difference 23 10 Exclusion 24 11 Hue 26 12 Saturation 27 13 Color 28 14 Luminosity 29 15 Label Colors Value Name Default Color 0 None (shows as grey) 1 Red #b4393b 2 Yellow #e2d759 3 Aqua #abcbc8 4 Pink #e5bcca 5 Lavender #a9aac9 6 Peach #e5c19f 7 Sea Foam #b4c7b4 8 Blue #687fdd 9 Green #4ea350 10 Purple #8d3299 11 Orange #e79228 12 Brown #7e442c 13 Fuchsia #f371d5 14 Cyan #43a2a4 15 Sandstone #a7967a 16 Dark Green #203f1f Text Render Oder Per character palette Fills over strokes Strokes over fills Chunk Data Note that chunks might have extra data after what is described here, always parse exactly as many bytes as specified in the chunk header. LIST This chunk is defined by the RIFF specs, its data has the following format: Starts with an id , specifying the type of the list, then followed by sub-chunks. The format of specific LIST types are described later in this document. Note that the LIST btdk doesn't conform to RIFF, so take care to not read over the chunk length. Utf8 Contains utf-8 encoded text. Sometimes it contains the string -_0_/- which (I guess) is used as a placeholder for objects lacking a name. tdsn / fnam / pdnm Contains a Utf8 chunk, used for object names tdmn Contains a NUL-terminated string (You'll need to strip excess \\0 ) and defines a Match Name . cmta Comment, NUL-terminated string. The size seems to be variable but rounded to 4 bytes. fdta Folder data. cdta Composition data. Field Name Size Type Description X Resolution 2 uint16 Y Resolution 2 uint16 1 Time Scale 2 uint16 How much Time values are scaled by 14 Playhead 2 Time Playhead time 6 In Time 2 Time Same as ip in Lottie 6 Out Time 2 Time Same as op in Lottie 6 Comp duration 2 Time Duration setting in AE 5 Color 3 bytes Color as 24 bit RGB 84 Attributes 1 Flags Width 2 uint16 Same as w in Lottie Height 2 uint16 Same as h in Lottie Pixel Ratio Width 4 uint32 Pixel Ratio Height 4 uint32 12 Framerate 2 uint16 Same as fr in Lottie 16 Shutter Angle 2 uint16 Shutter Phase 4 sint16 16 Samples Limit 4 sint16 Samples per frame 4 sint16 Note that End Time might have a value of FFFF, if that's the case assume it to be the same as Comp Duration. The X/Y resolution represent a divisor of the size in that direction used for rendering. For example a X Resolution of 5, with a width of 500 will yield an output of 100px. The pixel ratio is represented as a fraction of width/height, if both values are 1 you get square pixels. Attributes: Shy: (0, 0): Hides Shy layers from the timeline Motion Blur: (0, 3): Allows layers to enable motion blur Frame Blending: (0, 4): Allows layers to enable frame blending Preserve Framerate: (0, 5): Something about nested render queues Preserve Resolution: (0, 7): Something about nested render queues ldta Layer data, it seems that AE23 adds 4 extra 00 bytes at the end compared to older versions. Field Name Size Type Description Layer ID 4 uint32 Quality 2 uint16 0 : Wireframe, 1 : Draft, 2 : Best 4 Stretch Numerator 2 uint16 1 Start Time 2 sint16 Time offset for times withing the layer 6 In Time 2 Time Same as ip in Lottie 6 Out Time 2 Time Same as op in Lottie 6 Attributes 3 Flags Source ID 4 uint32 Item id for the used asset 17 Label Color Index 1 uint8 Label Colors 2 Layer Name 32 string0 It's repeated in the Utf8 chunk right after 11 Matte Mode 1 uint8 2 Stretch Denominator 2 uint16 19 Layer Type 1 uint8 Parent ID 4 uint32 ID of the parent layer, if any 24 Matte Layer ID 4 uint32 Id of the layer masking the current layer, if any (only for AE >= 23) With the following Attributes: Guide : (0, 1) Guide layers aren't rendered Bicubic Sampling : (0, 6) Auto Orient : (1, 0) Adjustment : (1, 1) Whether it's an adjustment layer Threedimensional : (1, 2) Solo : (1, 3) (UI thing, only displays that layer) Null : (1, 7) Whether it's a null layer Visible : (2, 0) Effects : (2, 2) Motion Blur : (2, 3) Locked : (2, 5) Shy : (2, 6) (Used to hide some layers in the AE UI) Conitnuosly Rasterize (vector) / Collapse Transform (comps): (2, 7) Layer Types: 0: Asset Layer 1: Light Layer 2: Camera Layer 3: Text Layer 4: Shape Layer Matte Modes: No Matte Alpha Inverted Alpha Luma Inverted Luma Time streching is defined as a fraction of Stretch Numerator / Stretch Denominator idta Item data. Field Name Size Type Description Type 2 uint16 14 ID 4 uint32 ID used to reference this item 38 Label Color 1 uint8 Label Colors The Type field above can have the following values: 1 : Folder 4 : Composition 7 : Footage The last 2 bytes of this field seem to change every time you make a change. tdb4 Property metadata. Field Name Size Type Description 2 Always db 99 ? Components 2 uint16 Number of values in a multi-dimensional Attributes 2 Flags 1 1 Some sort of flag, it has value 03 for position properties 2 2 2 Always 0000 ? 2 2nd most significant bit always on, perhaps some kind of flag 8 float64 Most of the time 0.0001 8 float64 Most of the time 1.0 , sometimes 1.777 8 float64 Always 1.0 ? 8 float64 Always 1.0 ? 8 float64 Always 1.0 ? Type? 4 Flags See below 1 Seems correlated with the previous byte, it's set for 04 for enum properties 7 Bunch of 00 Animated 1 Set to 1 when animated, kinda the reverse of the Static bit in Attributes 7 Bunch of 00 4 Usually 0, probs flags 4 Mst likely flags, only last byte seems to contain data 8 float64 Always 0.0 ? 8 float64 Mostly 0.0 , sometimes 0.333 8 float64 Always 0.0 ? 8 float64 Mostly 0.0 , sometimes 0.333 4 Probs some flags 4 Probs some flags Attributes: Position : (1, 3). When true , this is a position property, which changes how animated values are parsed. Static : (1, 0). When false , the property is animated and it will have a cdat . Types: No Value : (1, 0). Used for properties like shapes, gradients, etc, where the values are not in the keyframe. Integer : (3, 2). Vector ?: (3, 3). Color : (3, 0). Set for color properties (they have a different keyframe format). For Integer type, you might have indexed values: For layers, the value will be in tdpi / tdps , for masks it will be in tdli . cdat Property static value. For multi-dimensional properties, you look at the number of components in tdb4 and parse that many float64 , that's the value of the property. shph Header for bezier shape data, contained within LIST shap . It's followed by a LIST list with bezier data. Field Name Size Type Description 3 Attributes 1 Flags Top Left 2 float32 Top-left corner of the shape area, relative to the layer position Bottom Right 2 float32 Bottom-right corner of the shape area, relative to the layer position 4 Flags: Open : (0, 3). When true , the shape is open (it's missing the segment connecting the last point to the first) lhd3 Inside a LIST list , defines the data format, followed by ldat . Field Name Size Type Description 4 Seems to always be 00 d0 0b ee 6 All 00 Count 2 uint16 Number of items 4 The last byte is the only one that changes, greatest variation is on shapes 2 All 00 Item Size 2 uint16 Size of an item in the list 3 All 00 Type? 1 4 00 00 00 01 2 All 00 2 Some kind of flags 20 All 00 Item Type Size Type Gide 00 01 02 LItm 00 80 01 LRdr 08 c6 01 Color Kf 00 98 04 1D Kf 00 30 04 2D Kf 00 58 04 2D pos Kf 00 68 04 3D Kf 00 80 04 3D pos Kf 00 80 04 Marker Kf 00 10 04 Orientation Kf 00 50 04 No Value Kf 00 40 04 The corresponding ldat should have Item Size * Count bytes, and it's omitted if Count is 0. ldat Inside a LIST list , contains the list data, preceded by lhd3 . The number of element is the one defined in lhd3 . It has a different format based on certain conditions, follow some of the possible element formats. The size of an item is found like so: item_size = ldat_chunk_length / lhd3_count Keyframe (common) All keyframe items start like this: Field Name Size Type Description 1 Time 2 Time Time of the keyframe, seems they always start from 0. 2 Ease Mode 1 uint8 Label Color 1 uint8 Label Colors Attributes 1 Flags Ease Mode: 1. Linear 2. Ease 3. Hold Attributes: Least significant 3 bits seems to always be on. Continuous Bezier (0, 3) Auto Bezier (0, 4) Roving across time (0, 5) Keyframe - Multi-Dimensional Given n as the number of dimensions found in tdb4 (eg: 3 for 3D positions): Field Name Size Type Description Value 8* n float64[n] Value In Speed 8* n float64[n] In Influence 8* n float64[n] Out Speed 8* n float64[n] Out Influence 8* n float64[n] Keyframe - Position If the property is an animated position, the keyframe is formatted like so: Field Name Size Type Description 8 8 float64 In Speed 8 float64 In Influence 8 float64 Out Speed 8 float64 Out Influence 8 float64 Value 8* n float64[n] Value Tan In 8* n float64[n] Spatial tangents Tan Out 8* n float64[n] Spatial tangents Keyframe - No Value Used for shapes and gradients ( Special set in tdb4 ) Field Name Size Type Description 8 8 float64 In Speed 8 float64 In Influence 8 float64 Out Speed 8 float64 Out Influence 8 float64 8 Keyframe - Color Field Name Size Type Description 8 8 float64 In Speed 8 float64 In Influence 8 float64 Out Speed 8 float64 Out Influence 8 float64 Value 8*4 float64[4] ARGB 255 8*8 float64[8] Shape Data Bezier data, positions are relative to the area defined by shph . The list is a sequence of points, appearing in this order: Vertex 0 Out Tangent 0 In Tangent 1 Vertex 1 Out Tangent 1 ... Note that all coordinates are relative to the area in shph but not to each other. A coordinate of [0, 0] will correspond to the top-left corner in shph , and [1, 1] corresponds to the bottom-right. Field Name Size Type Description X 4 float32 X Coordinate XY 4 float32 X Coordinate pprf Color profile information as ICC data. fiac Folder item active, uint8 if it's 1 the previous List Item is the active item. wsnm Worspace name. Utf-16 encoded string, contains the name of the \"workspace\" (window layout in AE) It's always followed by an Utf8 with the same content. tdum / tduM float64 values often found inside LIST tdbs . In some cases they seem to indicate minimum and maximum values for that property but there are some cases in which they are both 0.0 . ppSn Contains a float64 , unknown meaning. otda Orientation data Field Name Size Type Description X 8 float64 X Coordinate Y 8 float64 Y Coordinate Z 8 float64 Z Coordinate opti Asset data, format depends on type Field Name Size Type Description Type 4 string Asset type Solid Type Soli , data for solid layers. Field Name Size Type Description 6 Alpha 4 float32 Red 4 float32 Green 4 float32 Blue 4 float32 Name 256 string0 Color components are in [0, 1]. sspc Footage / asset data. Field Name Size Type Description 32 Width 2 uint16 2 Height 2 uint16 alas JSON string containing external asset info. Field Name Type Description ascendcount_base number ascendcount_target number fullpath string The absolute path to the file platform number Operating system (see below) server_name string Hostname (?) server_volume_name string target_is_folder boolean Whether the file is a folder platform values: 1 is Windows, other values are for Unix and MacOS, but the values are to be discovered head Field Name Size Type Description AE Version? 6 12 File Revision? 2 uint16 Increases by 2 every time you save Seems the first 6 bytes contain AE version information. I haven't been able to decode it fully but here's a list of values encountered in the wild: Version Bytes 15.0 5c 06 07 38 06 b4 16.0 5d 04 0b 00 06 eb 16.0.1 5d 04 0b 00 0e 30 16.1.2 5d 05 0b 00 96 37 16.1.3 5d 05 0b 00 9e 05 17.0 5d 09 4b 08 06 2b 17.0.4 5d 0b 0b 08 26 3b 18.2.1 5d 1b 0b 11 0e 08 18.4 5d 1d 0b 12 06 26 22.0 5d 1d 0b 70 06 6f 22.6 5d 2b 0b 33 06 3b 23.2.1 5e 03 0b 39 0e 03 It's possible the 3rd to the 5th bytes encode some kind of internal build number that gets mapped to AE versions somehow... EfDC The first byte contains the number of LIST EfDf in a LIST EfdG parn Contains a uint64 with the number of parameters in a LIST parT . pard Effect parameter definition. Field Name Size Type Description 15 Type 1 uint8 Parameter type Name 32 string0 8 Types: Type Name AEP Lottie Lottie Object Layer 0 10 Effect Value Layer Scalar 2 0 Effect Value Slider Angle 3 1 Effect Value Angle Boolean 4 4 Effect Value Checkbox Color 5 2 Effect Value Color 2D 6 3 Effect Value Point Enum 7 7 Effect Value Drop Down Paint Group 9 Slider 10 0 Effect Value Slider Group 13 5 Custom Effect Unknown 15 6 Effect No Value 3D 18 3 Effect Value Point After the data above, there is more data that depends on the type Layer Doesn't seem to have much data Scalar / Angle Field Name Size Type Description Last value 4 sint32 4 64 4 Min Value 2 sint16 2 Max Value 2 sint16 To get the last value, you need to divide the raw value by 0x10000 . Boolean Field Name Size Type Description Last used value 4 uint32 Default 1 uint8 3 64 4 float32 4 4 float32 Color Field Name Size Type Description Last used value 4 uint8[4] ARGB Default 4 uint8[4] ARGB 64 Max Value 4 uint8[4] ARGB 2D Field Name Size Type Description Last value X 4 sint32 Last value Y 4 sint32 Last value x/y are multiplied by 0x80, so divide them to get the right value. Enum Field Name Size Type Description Last used value 4 uint32 Option count 2 uint16 Default 2 uint16 Slider Field Name Size Type Description Last used value 8 float64 44 4 float32 4 Max Value 4 float32 3D Point Field Name Size Type Description Last value X 8 float64 Last value Y 8 float64 Last value Z 8 float64 You need to multiply the \"Last value\" components by 512 to get the actual values. pdnm Effect parameter definition name / strings. This will contain strings used by the widget in the effect controls of the preceding pard . For example if the type in the pard is 4 (Boolean) the name of the parameter might be empty and it will be in pdnm as that's how AE displays it. For Enum (type 7 ), you get the drop down strings separated by | . tdpi Layer index for index properties ( uint32 ). tdps Layer source for index properties ( sint32 ). 0 : Layer -1 : Effects & Masks -2 : Masks tdli Mask index for index properties ( uint32 ). prin Seems to always have the same content: 4 00 bytes, the string ADBE Escher , 37 00 , the string Classic 3D , 41 00 , and ends with 01 . prda Seems to always have the same content: 3 00 , a 01 , 8 00 . NmHd Marker attributes Name Size Type Description 3 Attributes 1 Flags Duration 4 uint32 Duration in frames 4 Label Color 1 uint8 Label Colors Flags: Protected : (0, 1) The marker signals a protected region ??? : (0, 2) This flags seems to always be on tdsb 4 bytes specifying flags for a tdgp . 0x00'00'00'01 - object is visible 0x00'00'00'02 - split position 0x00'00'20'00 - locked x/y ratio mkif Mask properties. Name Size Type Inverted 1 uint8 Locked 1 uint8 4 Mode 2 uint16 Mask Modes: 0: None 1: Add 2: Subtract 3: Intersect 4: Darken 5: Lighten 6: Difference CCId Composition ID for essential graphics properties ( uint32 ) CLId Layer ID for essential graphics properties ( uint32 ) Smin Essential graphics slider minimum value. Representation depends on the value of the previous CTyp . Smax Essential graphics slider maximum value. Representation depends on the value of the previous CTyp . CVal Essential graphics property current value. Representation depends on the value of the previous CTyp . CDef Essential graphics property default value. Representation depends on the value of the previous CTyp . CTyp uint32 with the essential graphics item type Name Type Value Format Scalar 2 float64 Color 4 float32[4] RGBA Position 5 float64[2] Comment 8 Vector 9 float64[4] Group 10 Enum 13 uint32 CprC Essential graphics flags (4bytes) Is property (3, 0) StVS Essential graphics group item count Name Size Type Count 1 uint8 3 CDim uint32 number of dimensions for an essential vector property. fips Contained in LIST Fold contains preview settings. The chunk is repeated multiple times but only the first one seems to be relevant. Name Size Type 15 Flags 1 uint8 Flags Show alpha grid (0, 7) LIST Fold Top level item. LIST Item Item, you can check its properties with idta contained inside it. LIST Layr Defines a layer. Layer metadata is found in a ldta , the layer name is in a Utf8 . Go through its LIST tdgp to get shapes and transforms. You will find the following match names within it: ADBE Root Vectors Group : Contains shape data (shape layer in lottie) ADBE Camera Options Group : Lottie camera layer ADBE Transform Group : Layer transform ADBE Layer Styles : Layer styles LIST tdgp Defines an object / property group. Flags for the objects are in tdsb . The name of the object is in tdsn > Utf8 . Then follows a sequence of properties / objects defined as such: tdmn specifies the match name of the object, then it's followed by chunks that describe said object (usually more LIST s). Usually the last chunk here is a tdmn with value ADBE Group End . LIST tdbs Defines an object's property. To know which property, you need to check the tdmn preceding this chunk. It will contain a tdb4 , and usually cdat (static) or a List list (animated). For properties with expressions, it will have a Utf8 with the expression code. LIST GCst Defines a gradient. Contains a LIST tdbs and a LIST GCky . LIST GCky Gradient color keyframes. Contains a sequence of Utf8 formatted in XML with the gradient definition for each keyframe. LIST om-s Contains a LIST tdbs and a LIST omks to define a shape property. LIST omks Bezier shape data. Contains a sequence of LIST shap with the shape data for each keyframe. LIST shap Contains a shph and a LIST list with the shape data. LIST CPPl Contains a pprf . LIST list For animated properties it replaces cdat . The list header is defined in the chunk lhd3 , the list data in ldat . LIST SLay / LIST DLay / LIST CLay They seem to be camera layers used to store internal views, not exported to lottie. SLay (Side views?) have names like \"Top\" and \"Front\", perhaps they define 3d views. CLay : Custom views. DLay : Default views. LIST SecL Composition Markers Layer. Contains ldta and like other layers. in LIST tbgp look for the match name ADBE Marker , the data is in the LIST mrst . LIST mrst Marker property. Contains a LIST tdbs that defines the property, which should always be animated when present. Marker keyframe values are available in LIST mrky . LIST mrky Marker keyframes. contains a LIST Nmrd for each keyframe LIST Nmrd Marker data There's a NmHd with the attributes. The marker comment is in the first Utf8 LIST otst Orientation property. Contains a LIST tdbs and a LIST otky to define a shape property. LIST otky Contains a sequence of otda with the orientation data for each keyframe. LIST Als2 Contains alas for external assets. LIST Sfdr Asset folder contents, contains several LIST Item . LIST btdk For some reason this doesn't conform to the RIFX specs, instead of a list its data is encoded in Carousel Object Structure (COS). The COS format is the same used in PDF but it's extremely difficult to find detailed information on it, the best technical specs is this very old PDF 1.7 specification . Once you parse the COS, you can find the following data: 0.1.0 : Array of available fonts: 0.99 : CoolTypeFont 0.0.0 : Font family (seems to have bold/italic encoded in the name) 0.0.2 : 0 or 1 ? 1.1 : Array of text documents (one for each keyframe) in this format: 0.0 : Text 0.5.0 : Array of paragraph styles 0.0.5 Paragraph Style: 0 : Text align ( 0 : left, 1 : right, 2 : center) 1 : Length (in characters) the style applies to 0.6.0 : Array of character styles: 0.0.6 : Character Style: 0 : Index of the font from the array of available fonts 1 : Font size 2 : Faux Bold 3 : Faux Italic 12 : 0 : Normal, 1 : Small caps, 2 : All caps 13 : 0 : Normal, 1 : Superscript, 2 : Subscript 53.0.1 : Fill color in ARGB [0, 1] 54.0.1 : Stroke color in ARGB [0, 1] 57 : Stroke enabled 58 : Stroke over fill 63 : Stroke width 1 : Length (in characters) the style applies to LIST sspc Effect Definiton. The generic effect name is in fnam > Utf8 . The effect parameters are defined in LIST parT . If the effect type has already been encountered, you might not find the LIST parT here, you might need to match the name to an entry in LIST EfdG . It finally contains a LIST tdgp where the effect properties are present like any other animated property. You can also find the name of the effect object in fnam > Utf8 . Inside there you can also find a match name with ADBE Effect Built In Params which will contain values for built-in effect parameters. LIST parT Effect parameters. Contains a parn with the number of parameters, then follows a list of tdmn with the match name of the parameter followed by pard with its definition. Enum parameters have their values in a pdnm separated by | pipes. The first property seems to be a dummy? LIST EfdG Effect definitions. This is where effect types used by the project are defined. Basically it repeats the first instance of any effect found in the layers. it contains a EfDC with the number of effects, and that many LIST EfDf . LIST EfDf Effect type definition. Contains a tdmn with the match name of the effect and a LIST sspc . LIST ExEn Contains a Utf8 with the expression language (eg: javascript-1.0 ). LIST PRin Contains a prin and a prda . LIST Pin Asset properties. Contains: sspc with some common properties Utf8 with the name (except for solids) opti with asset data LIST CIF0 See LIST CIF3 . LIST CIF2 See LIST CIF3 . LIST CIF3 Essential Graphics Definition. LIST CCtl Essential graphics item. LIST CpS2 Essential graphics header. LIST StVc Essential graphics group items LIST CPrp Essential graphics property definition LIST OvG2 Essential graphics override property identifiers LIST CPrp Essential graphics override property identifier LIST LRdr Render queue data. this is a top-level chunk. Items are stored in LIST LItm . LIST LItm Render Queue items, contains a sequence of LIST list and LIST LOm , the latter having information on the render item (one per job). LIST LOm Render list item, contains the following chunks: Roou Output options? Ropt Render options? LIST Als2 Selected output file Utf8 Name of the template applied to the item Utf8 File name template Gradient XML Gradient data seems to be stored in a convoluted XML structure. The easiest way to describe it is as a mapping, the elements can be parsed like so: Tag Name Logical Type Description prop.map Top-level, just get its first child prop.list dict Mapping of key-value pairs prop.pair Item in prop.list key str Property key array list Array of values, the first item is array.type which specifies the type int int float float string str If you interpret the XML as a mapping, you can gather the following info: { \"Gradient Color Data\": { \"Alpha Stops\": { \"Stops List\": { \"Stop-0\": { \"Stops Alpha\": [ 0.0, // offset 0.5, // midpoint 1.0 // alpha ] }, // More stops defined the same way... } \"Stops Size\": 2 // Number of stops }, \"Color Stops\": { \"Stops List\": { \"Stop-0\": { \"Stops Color\": [ 0.0, // offset 0.5, // midpoint 0.0, // red 0.0, // green 0.5, // blue 1.0 // alpha? ] }, // More stops defined the same way... } \"Stops Size\": 2 // Number of stops } }, \"Gradient Colors\": \"1.0\" // Version? } Midpoint You should use the \"midpoint\" values to add an additional color which is halfway between the other two. For example given these stops: \"Stop-0\": { \"Stops Color\": [ 0.0, // offset 0.5, // midpoint 0.1, // red 0.2, // green 0.3, // blue 1.0 // alpha? ] }, \"Stop-0\": { \"Stops Color\": [ 0.6, // offset 0.5, // midpoint 0.3, // red 0.4, // green 0.5, // blue 1.0 // alpha? ] }, The final gradient will look like this: [ // stop 0 0.0, // offset_0 0.1, // red_0 0.2, // green_0 0.3, // blue_0 // midpoint stop 0.3, // offset_0 * (1 - midpoint_0) + offset_1 * midpoint_0 0.2, // (red_0 + red_1) / 2 0.3, // (green_0 + green_1) / 2 0.4, // (blue_0 + blue_1) / 2 // stop 1 0.6, // offset_1 0.5, // midpoint_1 0.3, // red_1 0.4, // green_1 0.5, // blue_1 ] Opacity For some reason in AE gradients alpha is independent from the color, so you have separate stops for color and opacity. You should treat the midpoint value for opacity stops in a similar way as to the color ones. Once you have both the color and opacity values, the final lottie array is simply a concatenation of the two. XMP Metadata After the RIFX data, an AEP file also contains some XML in the XMP format. This section contains the version of AfterEffects, when the file has been created and modified, and related info. XML Project Format Aftereffects allows you to save the project as XML. This is basically as the RIFX but with a different container format and binary data encoded as hex. Conversion notes for elements are provided below AfterEffectsProject Root element, same as RIFX . ProjectXMPMetadata In the RIFX file this is dumped at the end without a chunk. string Used instead of Utf8 . numS / ppSn For some reason they have their value in a <string> but are not string in the RIFX. tdsn / fnam / pdnm These elements contain children but they are not LIST in RIFX, that's the only thing of note. Child elements If an element has children. it's the same as the equivalent LIST in RIFX. bdata Elements with the bdata attribute have their binary data hex encoded in said attribute. You can parse their data the same way as you'd do in RIFX. Resources aftereffects-aep-parser A basic AEP parser written in Go. Multimedia Programming Interface and Data Specifications 1.0 RIFF specs PDF. Floating Point to Hex Converter Float to hex converter. bodymovin-extension AE extensions that exports to Lottie After Effects Scripting Guide Shape Layer Match Names Portable document format \u2014 Part 1: PDF 1.7 The only COS reference I've found","title":"Parsing AEP Files"},{"location":"aep/#parsing-aep-files","text":"AfterEffects Project files are the proprietary file format used by Adobe AfterEffects. It's a binary format based on the RIFX container format. The structure resembles that of a Lottie JSON exported from AE.","title":"Parsing AEP Files"},{"location":"aep/#riff","text":"A RIFF is composed of \"chunks\" with the following format Field Size Description Header 4 ASCII name describing the type of the chunk Size 4 uint32 size of the data section Data Size Data within the chunk RIFX is an extension of the RIFF format, the difference being RIFX uses big-endian notation for integers. A RIFF file will be structured in the same way as a chunk: Field Size Description Header 4 RIFF or RIFX Size 4 uint32 size of the chunk Format 4 Format Identifier Chunks * Rest of the chunks","title":"RIFF"},{"location":"aep/#aep-specific-parsing","text":"It should always be RIFX format (big endian). The format identifier for AEP is Egg! . When parsing the RIFF structure, keep in mind the following chunks will contain other chunks: tdsn fnam pdnm And that LIST btdk contains data in a different format, and it should not be parsed as a RIFF LIST . At the end of the RIFF data, the AEP file has some XML-encoded metadata.","title":"AEP-Specific Parsing"},{"location":"aep/#basic-types","text":"In the chunk data descriptions, the types described below will be used to show how to interpret the raw binary data. Type Size Description id 4 ASCII-encoded chunk identifier uint16 2 Unsigned integer uint32 4 Unsigned integer sint16 2 Twos-complement signed integer float32 4 IEEE float float64 8 IEEE float string * Text, usually utf-8 encoded string0 * NUL terminated string, note that you might find junk data after the NUL (This can be caused by renaming something to a shorter name) bytes * Unformatted / unknown data","title":"Basic Types"},{"location":"aep/#time","text":"Time values are stored as uint16 . they are scaled by a factor you can find in cdta . To get the actual value in frames you need to do the following: time_frames = time_value / cdta.time_scale Additionally, layers specify a start time, which shifts all the time values by a fixed amount. If you are within a layer the expression looks like this: time_frames = (time_value + ldta.start_time) / (cdta.time_scale)","title":"Time"},{"location":"aep/#flags","text":"Flags is byte data, that will be specified using two integers: byte and bit index. You'll get the value of the flag you'll need to do the following: flag = (flags[byte] & (1 << bit)) != 0 The index of the byte here is in file order so a byte of 0 is the most significant byte.","title":"Flags"},{"location":"aep/#aftereffects-logic","text":"This section assumes the file has already been parsed into RIFF chunks. Objects described here will have a nested list showing which chunks are used to represent them, you can click on the link pointing to the chunk details to get the data layout within that chunk.","title":"AfterEffects Logic"},{"location":"aep/#file-structure","text":"LIST EfdG : Effect definitions LIST ExEn Utf8 : Language used in expressions (eg: javascript-1.0 ) LIST Fold : Root folder LIST Item : Folder item (repeated, see below)","title":"File Structure"},{"location":"aep/#folder-item","text":"LIST Item idta : Item data Utf8 : Name cmta : (optional) Comment fiac Whether the item is the active item idta will cointain the ID of the item (referenced by layers) and the item type. The following sections descript each type of item in detail","title":"Folder Item"},{"location":"aep/#folders","text":"idta type 1 . These contain additional items inside them. LIST Item idta : Item data (type and ID). Utf8 : Name LIST Sfdr : Folder items LIST Item : Child item (repeated)","title":"Folders"},{"location":"aep/#compositions","text":"idta has type of 4 . You need to know which composition to extract as a lottie corresponds to a specific comp (with other compositions showing as assets for precomps). Structure: LIST Item idta : Item data (type and ID). Utf8 : Name cdta : Composition data LIST Layr : Layer (repeated) Each layer will show as a LIST Layr in the LIST Item . The composition will also have other type of layer LIST s: LIST DLay : Default view LIST CLay : Custom views LIST SLay : Side views LIST SecL : Composition markers layer If the comp uses essential graphics , it will have the appropriate LIST s as well.","title":"Compositions"},{"location":"aep/#assets","text":"idta type 7 . These can have different kinds of contents. Look for sspc to get the size for visual assets. The type of asset is defined in the first 4 bytes of opti .","title":"Assets"},{"location":"aep/#solids","text":"For some the Item has an Utf8 but it seems to always be empty need to find the name from opti . LIST Item idta : Item data (type and ID). Utf8 : Name (not used for solids) LIST Pin sspc : Contains info like width / height) opti : Data","title":"Solids"},{"location":"aep/#files","text":"LIST Item idta : Item data (type and ID). Utf8 : Name LIST Pin sspc : Contains info like width / height) opti : Check this to tell files apart from solids LIST Als2 alas : File info as JSON. LIST CLRS Utf8 : JSON containing base64-encoded ICC color profiles. The Uft8 in Item only has a value if the user has set an explicit value for the name. The file path is in alas , parse it as JSON and get fullpath . the first 4 bytes of opti will change based on the file format.","title":"Files"},{"location":"aep/#layers","text":"LIST Layr : Layer ldta : Common layer data, including layer type. Utf8 : Name cmta : (optional) Comment LIST tdgp : Property group When parsing layer transforms, keep in mind the default position is the center of the comp. For shape layers, the default anchor is [0, 0]; for precomp layers the default anchor is the center of the comp (same as position).","title":"Layers"},{"location":"aep/#asset-layer","text":"Layer type 0 . (Also known as AVLayer in AE) They have a non-zero Source ID in ldta . Precomp, image, and similar layers will point to an appropriate asset. Several layer types point to a solid asset, you need to check the layer attributes to distinguish between them: Solid layers Null layers Adjustment layers","title":"Asset Layer"},{"location":"aep/#light-layer","text":"Layer type 1 . For light settings look for the match name ADBE Light Options Group .","title":"Light Layer"},{"location":"aep/#camera-layer","text":"Layer type 2 . For camera settings look for the match name ADBE Camera Options Group .","title":"Camera Layer"},{"location":"aep/#text-layer","text":"Layer type 3 . For text contents look for the match name ADBE Text Properties .","title":"Text Layer"},{"location":"aep/#shape-layer","text":"Layer type 4 . For shapes look for the match name ADBE Root Vectors Group .","title":"Shape Layer"},{"location":"aep/#property-groups","text":"Most objects are described as a property groups. These have the following structure: LIST tdgp : Property group tdsb : Flags tdsn > Utf8 : Name ... (properties) tdmn : ADBE Group End (marks the end of the group) Then follows a list of properties, all introduced by their match name ( tdmn ). After a match name, you'll find the data for the property, which might be an actual propert (see the section below), other groups, or layer effects. This structure is used both for objects (that have a fixed set of properties) and groups/collections whose contents might vary. For objects with fixed properties you will not find duplicate match names but you might find duplicates within collections.","title":"Property Groups"},{"location":"aep/#properties","text":"Properties, like objects are introduced by their match name, the chunks following that depends on the type of property. The core of a property is defined in LIST tdbs with the following structure: LIST tdbs : Property definition tdb4 : Tells you the type, number of components, whether it's animated cdat : Value (if not animated) tdsn : Utf8 : Human-readable Name Utf8 : Optional expression LIST list : Keyframes (if animated) lhd3 : Tells you the number of keyframes ldat : Keyframe data and values For simple properties, with vector or scalar values, you get the structure above. For more complex properties, you get an outer object that contains that data as well as a list of values. You'll get the value for the keyframes (or the static value) from that list. Color properties are laid out as ARGB floats in [0, 255]. Note that the keyframe structure in ldat changes based on the info found in tdb4 .","title":"Properties"},{"location":"aep/#shape","text":"LIST om-s LIST tdbs : Property definition LIST omks : Keyframe values LIST shap : Bezier Data (repeated) shph : Bezier metadata (whether it's closed and bounding box) LIST list lhd3 : Bezier point list metadata ldat : Bezier points relative to shph","title":"Shape"},{"location":"aep/#gradient-colors","text":"LIST GCst LIST tdbs : Property definition LIST GCky : Keyframe values Utf8 Gradient XML (repeated)","title":"Gradient Colors"},{"location":"aep/#orientation","text":"LIST otst LIST tdbs : Property definition LIST otky : Keyframe values otda 3D vector (repeated)","title":"Orientation"},{"location":"aep/#marker","text":"LIST mrst LIST tdbs : Property definition LIST mrky : Keyframe values Nmrd Marker (repeated) NmHd Marker properties Utf8 Name","title":"Marker"},{"location":"aep/#text-document","text":"LIST btds LIST tdbs : Property definition LIST btdk : COS-encoded data","title":"Text Document"},{"location":"aep/#layer","text":"Follows the usual LIST tdbs , check tdb4 for the \"Integer\" property type. LIST tdbs tdb4 cdat : Should always be [0.0] tdpi : Layer index tdps : Layer source","title":"Layer"},{"location":"aep/#mask-index","text":"Follows the usual LIST tdbs , check tdb4 for the \"Integer\" property type. LIST tdbs tdb4 cdat : Should always be [0.0] tdli : Mask index","title":"Mask Index"},{"location":"aep/#mask","text":"mkif : Basic mask properties LIST tdgp : Animated properties","title":"Mask"},{"location":"aep/#layer-overrides","text":"LIST OvG2 CprC : uint32 ?","title":"Layer Overrides"},{"location":"aep/#layer-source-alternate","text":"blsv : uint32 Layer index? blsi : uint32","title":"Layer Source Alternate"},{"location":"aep/#chunk-naming","text":"Most of property related chunks seem to contain the prefix td in their name: tdgp : property group tdsb : property group flags tdsn : property group name tdmn : property match name tdbs : property definition tdb4 : property details I'm not sure what td stands for my best guess would be \"Track Data\". For properties with external values, the naming convention generally is XXst for the parent chunk and XXky for the values (where XX changes depending on the type and its meaning is fairly obvious). I'm not sure what st stands for, ky most likely stands for \"keyframes\"","title":"Chunk naming"},{"location":"aep/#expressions","text":"Bodymovin modifies expressions when converting into lottie, if you add expressions but fail to convert them, the animation might not play properly.","title":"Expressions"},{"location":"aep/#assets_1","text":"","title":"Assets"},{"location":"aep/#image","text":"Defined within LIST Item , it will have idta with type 7 . Within that there's a LIST Pin , containing the following: LIST Als2 with alas , which in turn has some JSON. Inside the JSON you can get fullpath . opti : Contains the asset name. LIST CLRS , the last Utf8 here has some JSON with a base64-encoded color profile.","title":"Image"},{"location":"aep/#shapes","text":"","title":"Shapes"},{"location":"aep/#stroke-dashes","text":"Look for the match name ADBE Vector Stroke Dashes . Inside of it you'll find a bunch of properties with match name ADBE Vector Stroke Dash n or ADBE Vector Stroke Gap n , where n is an ineger starting from 1. You will also find a single ADBE Vector Stroke Offset . They are all animatable lengths and fairly straighforward. Note that lottie-web wants a unique \"name\" for these, and the file doesn't provide this but you can generate one based on the match name.","title":"Stroke Dashes"},{"location":"aep/#transforms","text":"","title":"Transforms"},{"location":"aep/#split-position","text":"When a position is split the Position attribute is removed and you can get the data from Position_0 and Position_1. For some reason Position_0 and Position_1 are present (with value 0 ) even when the position is not split. Their tdsb seems to change from 1 (not split) to 3 (split).","title":"Split Position"},{"location":"aep/#effects","text":"The effects used in by the file are defined in the top-level chunk LIST EfdG , instanciations of these effects are present in the layers that use them. LIST EfdG : Effect definitions EfDC : Effect definition count (number of definitions) LIST EfDf : Effect definition (one per effect type used in the document) tdmn : Effect match name LIST sspc fnam > Utf8 : Effect name LIST parT : Effect parameters parn : Number of parameters tdmn : Parameter match name pard : Parameter definition pdnm : (optional) Parameter control strings You get tdmn and pard (optionally followed by pdnm for each parameter LIST tdgp : Contains the values of the first instance of this effect, can be ignored Note that the first paramter in an effect should be ignored. The effects in a later are listed under ADBE Effect Parade : tdmn : Effect match name, you'll need to find the matching definition LIST sspc fnam > Utf8 : Effect name LIST parT : You might find this here as well but it isn't consistent. Refer to LIST EfdG for the definition LIST tdgp : Parameter values, works like any other property list","title":"Effects"},{"location":"aep/#essential-graphics","text":"","title":"Essential Graphics"},{"location":"aep/#definition","text":"Essential graphics are defined in the following chunks inside the comp's LIST Item : LIST CIF0 LIST CIF2 LIST CIF3 They seem to have the same structure and (almost) identical values. But only CIF3 has data about groups: LIST CIF3 LIST CpS2 CsCt : seems to always have the value 0x1000000 . Utf8 : Name (Defaults to Untitled ) Utf8 : Locale? ( en_US ) CapS CsCt : seems to always have the value 0x1000000 . CapL : seems to always have the value 0 . Utf8 : Name (again, same value as before) LIST CCtl : Item (repeated) Items have the following common structure LIST CCtl LIST CpS2 Utf8 : Name LIST CapS Utf8 : Name (again) Utf8 : UUID CTyp : item type CprC : Flags Type-specific data","title":"Definition"},{"location":"aep/#comment","text":"CTyp : 8 Utf8 : Comment string Utf8 : Comment string (again) CprC : 0","title":"Comment"},{"location":"aep/#group","text":"CTyp : 8 LIST StVc : Items StVS : Count Utf8 : UUID of child items (repeated) CprC : 0","title":"Group"},{"location":"aep/#property","text":"CVal : Value CDef : Default Value Smin : Slider min value (only for scalar properties) Smax : Slider max value (only for scalar properties) CDim : Number of dimenstions (only for vector properties) LIST StVc : Enum values (only for enum properties) StVS : Count Utf8 : Value name (repeated) CprC : 1 LIST CPrp CCId : Composition ID (same as the one in idta ). CLId : Layer ID (same as the one in ldta ). Utf8 : JSON-ecoded path. The JSON is a dict where the key is a string containing a number and the values are dicts like this: index : Index for like shape groups and such, or the value 4294967295 ( 0xffffffff ) is used when there is no index matchName : Match name as per usual To find the property, something like this might work: CCId = 15 CLId = 18 json_data = { \"0\": { \"index\":4294967295, \"matchName\":\"ADBE Root Vectors Group\" }, \"1\": { \"index\":0, \"matchName\":\"ADBE Vector Group\" }, \"2\": { \"index\":4294967295, \"matchName\":\"ADBE Vectors Group\" }, \"3\": { \"index\":2, \"matchName\":\"ADBE Vector Graphic - Fill\" }, \"4\": { \"index\":4294967295, \"matchName\":\"ADBE Vector Fill Opacity\" } } property = get_layer(CCId, CLId) for item in json_data.values(): if item[\"index\"] == 0xffffffff: property = property.property(item[\"matchName\"]) else: property = property.properties[item[\"index\"]] The values in Smin , Smax , CVal , CDef depends on the type, refer to CTyp for their representation.","title":"Property"},{"location":"aep/#overrides","text":"Defined in the precomp layer under match name ADBE Layer Overrides tdmn : ADBE Layer Overrides LIST OvG2 LIST CPrp : (repeated) Utf8 : UUID of the essential property LIST tdgp : Property groups with the matching properties defined as usual.","title":"Overrides"},{"location":"aep/#match-names","text":"Follows a list of known match names grouped by object type. For properties that specify a default value, you should assume they have the specified value if they are not present in the AEP file.","title":"Match Names"},{"location":"aep/#layers_1","text":"Match Name Description Default ADBE Root Vectors Group shapes ADBE Layer Styles styles ADBE Transform Group ks ADBE Layer Styles sy ADBE Extrsn Options Group ADBE Material Options Group ADBE Audio Group ADBE Layer Sets ADBE Time Remapping tm ADBE Effect Parade ef ADBE Marker Markers ADBE Mask Parade masksProperties ADBE Plane Options Group ADBE Data Group ADBE Layer Overrides Essential graphincs values ADBE Source Options Group Match Name Description Default ADBE Camera Options Group Camera Layer Marks a layer as a camera layer ADBE Camera Aperture pe ADBE Camera Zoom ADBE Camera Focus Distance Match Name Description Default ADBE Mask Atom Mask ADBE Mask Shape pt ADBE Mask Offset x 0 ADBE Mask Feather [0, 0] ADBE Mask Opacity 0 100 Match Name Description Default ADBE Extrsn Options Group ADBE Bevel Direction Match Name Description Default ADBE Material Options Group ADBE Appears in Reflections ADBE Reflection Coefficient ADBE Glossiness Coefficient ADBE Fresnel Coefficient ADBE Transparency Coefficient ADBE Transp Rolloff ADBE Index of Refraction Match Name Description Default ADBE Source Options Group ADBE Layer Source Alternate Match Name Description Default ADBE Layer Styles ADBE Blend Options Group Match Name Description Default ADBE Blend Options Group ADBE Adv Blend Group","title":"Layers"},{"location":"aep/#shapes_1","text":"Match Name Description Default ADBE Vector Group Group ADBE Vector Blend Mode bm 1 2 ADBE Vectors Group it ADBE Vector Transform Group Transform ADBE Vector Materials Group Match Name Description Default ADBE Vector Shape - Rect Rectangle ADBE Vector Shape Direction d 1 ADBE Vector Rect Position p ADBE Vector Rect Size s ADBE Vector Rect Roundness r Match Name Description Default ADBE Vector Shape - Ellipse Ellipse ADBE Vector Shape Direction d 1 ADBE Vector Ellipse Position p ADBE Vector Ellipse Size s Match Name Description Default ADBE Vector Shape - Star PolyStar ADBE Vector Shape Direction d 1 ADBE Vector Star Type sy 1 ADBE Vector Star Points pt 3 ADBE Vector Star Position p ADBE Vector Star Rotation r ADBE Vector Star Inner Radius ir ADBE Vector Star Outer Radius or ADBE Vector Star Inner Roundess is ADBE Vector Star Outer Roundess os Match Name Description Default ADBE Vector Shape - Group Path ADBE Vector Shape Direction d 1 ADBE Vector Shape ks 4","title":"Shapes"},{"location":"aep/#shape-styles","text":"Match Name Description Default ADBE Vector Graphic - Fill Fill ADBE Vector Blend Mode bm 1 2 ADBE Vector Fill Color c 5 [255, 255, 0, 0] ADBE Vector Fill Opacity o 100 ADBE Vector Fill Rule r 1 1 ADBE Vector Composite Order if 2, it should be drawn over the previous shape 1 Match Name Description Default ADBE Vector Graphic - Stroke Stroke ADBE Vector Blend Mode bm 1 2 ADBE Vector Stroke Color c 5 [255, 255, 255, 255, ] ADBE Vector Stroke Opacity o 100 ADBE Vector Stroke Width w 2 ADBE Vector Stroke Line Cap lc 1 1 ADBE Vector Stroke Line Join lj 1 1 ADBE Vector Stroke Miter Limit ml2 4 ADBE Vector Stroke Dashes d ADBE Vector Stroke Taper ADBE Vector Stroke Wave ADBE Vector Composite Order if 2, it should be drawn over the previous shape 1 Match Name Description Default ADBE Vector Stroke Taper All properties are percentages in [0, 100] ADBE Vector Taper Start Length ADBE Vector Taper End Length ADBE Vector Taper Start Width ADBE Vector Taper End Width ADBE Vector Taper Start Ease ADBE Vector Taper End Ease Match Name Description Default ADBE Vector Stroke Wave ADBE Vector Taper Wave Amount ADBE Vector Taper Wave Units 1 for pixels, 2 for cycles ADBE Vector Taper Wavelength ADBE Vector Taper Wave Phase Match Name Description Default ADBE Vector Stroke Dashes ADBE Vector Stroke Offset ADBE Vector Stroke Gap # ADBE Vector Stroke Dash # Match Name Description Default ADBE Vector Graphic - G-Fill Gradient Fill ADBE Vector Blend Mode bm 1 2 ADBE Vector Grad Type t 1 ADBE Vector Grad Start Pt s ADBE Vector Grad End Pt e [100, 0] ADBE Vector Grad HiLite Length h ADBE Vector Grad HiLite Angle a ADBE Vector Grad Colors g 6 ADBE Vector Fill Opacity o 100 ADBE Vector Fill Rule r 1 1 ADBE Vector Composite Order if 2, it should be drawn over the previous shape 1 Match Name Description Default ADBE Vector Graphic - G-Stroke Gradient Stroke ADBE Vector Blend Mode bm 1 2 ADBE Vector Grad Type t 1 ADBE Vector Grad Start Pt s ADBE Vector Grad End Pt e ADBE Vector Grad HiLite Length h ADBE Vector Grad HiLite Angle a ADBE Vector Grad Colors g 6 ADBE Vector Stroke Opacity o 100 ADBE Vector Stroke Width w 2 ADBE Vector Stroke Line Cap lc 1 1 ADBE Vector Stroke Line Join lj 1 1 ADBE Vector Stroke Miter Limit ml2 ADBE Vector Stroke Dashes d ADBE Vector Stroke Taper ADBE Vector Stroke Wave ADBE Vector Composite Order if 2, it should be drawn over the previous shape 1","title":"Shape Styles"},{"location":"aep/#shape-modifiers","text":"Match Name Description Default ADBE Vector Filter - Merge Merge ADBE Vector Merge Type mm Match Name Description Default ADBE Vector Filter - Offset Offset Path ADBE Vector Offset Amount a ADBE Vector Offset Line Join lj 1 ADBE Vector Offset Miter Limit ml Match Name Description Default ADBE Vector Filter - PB Pucker Bloat ADBE Vector PuckerBloat Amount a Match Name Description Default ADBE Vector Filter - Repeater Repeater ADBE Vector Repeater Transform tr ADBE Vector Repeater Copies c 3 ADBE Vector Repeater Offset o ADBE Vector Repeater Order m 1 Match Name Description Default ADBE Vector Filter - RC Rounded Corners ADBE Vector RoundCorner Radius r 10 Match Name Description Default ADBE Vector Filter - Trim Trim ADBE Vector Trim Start s ADBE Vector Trim End e ADBE Vector Trim Offset o ADBE Vector Trim Type m 1 Match Name Description Default ADBE Vector Filter - Twist Twist ADBE Vector Twist Angle a ADBE Vector Twist Center c Match Name Description Default ADBE Vector Filter - Roughen ADBE Vector Roughen Size ADBE Vector Roughen Detail ADBE Vector Roughen Points ADBE Vector Temporal Freq ADBE Vector Correlation ADBE Vector Temporal Phase ADBE Vector Spatial Phase ADBE Vector Random Seed Match Name Description Default ADBE Vector Filter - Wiggler ADBE Vector Xform Temporal Freq ADBE Vector Correlation ADBE Vector Temporal Phase ADBE Vector Spatial Phase ADBE Vector Random Seed ADBE Vector Wiggler Transform Match Name Description Default ADBE Vector Filter - Zigzag Zig Zag ADBE Vector Zigzag Size s 10 ADBE Vector Zigzag Detail r 5 ADBE Vector Zigzag Points pt 1","title":"Shape Modifiers"},{"location":"aep/#transforms_1","text":"Match Name Description Default ADBE Transform Group Transform ADBE Anchor Point a 8 [0, 0] ADBE Position p Half of the comp size ADBE Position_0 Split position X ADBE Position_1 Split position Y ADBE Position_2 Split position Z ADBE Scale s 7 [1, 1] ADBE Orientation or ADBE Rotate X rx ADBE Rotate Y ry ADBE Rotate Z rz or just normal rotation 0 ADBE Opacity o 7 1 ADBE Envir Appear in Reflect Single float, probably a boolean? Match Name Description Default ADBE Vector Transform Group Transform Shape ADBE Vector Anchor Point a ADBE Vector Anchor a probably an outdated name ADBE Vector Position p ADBE Vector Scale s [100, 100] ADBE Vector Rotate X rx ADBE Vector Rotate Y ry ADBE Vector Rotate Z rz or just normal rotation ADBE Vector Rotation r ADBE Vector Skew sk ADBE Vector Skew Axis sa ADBE Vector Group Opacity o 100 Match Name Description Default ADBE Vector Repeater Transform Repeater Transform ADBE Vector Repeater Anchor Point a ADBE Vector Repeater Position p ADBE Vector Repeater Scale s 7 ADBE Vector Repeater Rotation r ADBE Vector Repeater Start Opacity so 7 1 ADBE Vector Repeater End Opacity so 7 1","title":"Transforms"},{"location":"aep/#effects_1","text":"Match Name Description Default ADBE Tint Tint Effect ty = 20 ADBE Fill Fill Effect ty = 21 ADBE Stroke Stroke Effect ty = 22 ADBE Tritone Tritone Effect ty = 23 ADBE Pro Levels2 Pro Levels Effect ty = 24 ADBE Drop Shadow Drop Shadow Effect ty = 25 ADBE Radial Wipe Radial Wipe ty = 26 ADBE Displacement Map Displacement Map Effect ty = 27 ADBE Set Matte3 Set Matte Effect ty = 28 ADBE Gaussian Blur 2 Gaussian Blur Effect ty = 29 ADBE Twirl Twirl Effect ty = 30 ADBE MESH WARP Mesh Warp Effect ty = 31 ADBE Ripple Wavy Effect ty = 32 ADBE Spherize Spherize Effect ty = 33 ADBE FreePin3 Puppet Effect ty = 34 Match Name Description Default ADBE Effect Built In Params Marks a LIST tdgp with built-in effect properties ADBE Effect Mask Opacity Match Name Description Default ADBE Paint Group Data for the paint effect ADBE Paint Atom Contains the following properties ADBE Paint Duration ADBE Paint Shape ADBE Paint Transform Same as other transform but match names starting with ADBE Paint ADBE Paint Properties contains the following ADBE Paint Clone Layer","title":"Effects"},{"location":"aep/#text","text":"Match Name Description Default ADBE Text Properties Text Data ADBE Text Document d ADBE Text Path Options p ADBE Text More Options m ADBE Text Animators a Match Name Description Default ADBE Text Animator Text Range ADBE Text Selectors s (list) ADBE Text Animator Properties a Match Name Description Default ADBE Text Selector Text Range Selector ADBE Text Percent Start s 0 ADBE Text Percent End e 100 ADBE Text Percent Offset o 0 ADBE Text Index Start s ADBE Text Index End e ADBE Text Index Offset o ADBE Text Range Advanced ADBE Text Selector Max Amount a ADBE Text Selector Smoothness sm ADBE Text Levels Max Ease xe ADBE Text Levels Min Ease ne ADBE Text Random Seed rn Match Name Description Default ADBE Text Animator Properties Text Style ADBE Text Anchor Point 3D a ADBE Text Position 3D p ADBE Text Scale 3D s ADBE Text Skew sk ADBE Text Skew Axis sa ADBE Text Rotation X rx ADBE Text Rotation Y ry ADBE Text Rotation r ADBE Text Opacity o ADBE Text Fill Color fc ADBE Text Fill Opacity fo ADBE Text Fill Hue fh ADBE Text Fill Saturation fs ADBE Text Fill Brightness fb ADBE Text Stroke Color sc ADBE Text Stroke Opacity so ADBE Text Stroke Hue sh ADBE Text Stroke Saturation ss ADBE Text Stroke Brightness sb ADBE Text Stroke Width sw ADBE Text Line Spacing ls ADBE Text Line Anchor ADBE Text Track Type ADBE Text Tracking Amount ADBE Text Character Replace ADBE Text Character Offset ADBE Text Blur Match Name Description Default ADBE Text Path Options Text Follow Path ADBE Text Path m ADBE Text Reverse Path r ADBE Text Perpendicular To Path p ADBE Text Force Align Path a ADBE Text First Margin f ADBE Text Last Margin l Match Name Description Default ADBE Text More Options Text Alignment Options ADBE Text Anchor Point Option g 1 ADBE Text Anchor Point Align a [0, 0] ADBE Text Render Order 1 ADBE Text Character Blend Mode 1","title":"Text"},{"location":"aep/#misc","text":"Match Name Description Default ADBE Group End Indicates the end of a LIST tdgp","title":"Misc"},{"location":"aep/#notes","text":"Enumerations needs to be converted from floats, but the values match. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 Blend mode has different values than Lottie, see the section below for details. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 Needs to be converted from float to int . \u21a9 \u21a9 How to parse this? \u21a9 Colors are defined as 4 floats (ARGB) in [0, 255]. \u21a9 \u21a9 Colors defined as XML . \u21a9 \u21a9 You need to multiply by 100 to get the lottie value. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 For asset layers, the anchor point is relative to the size of the asset (eg: (0.5, 0.5) would be the center). \u21a9","title":"Notes"},{"location":"aep/#enumerations","text":"Most enumerated values are the same in Lottie and AEP, this section lists the exceptions to this and enums not in lottie","title":"Enumerations"},{"location":"aep/#blend-mode","text":"Name AEP Lottie Normal 1 0 Darken 3 4 Multiply 4 1 Color Burn 5 7 Linear Burn 6 Darker Color 7 Lighten 9 5 Screen 10 2 Color Dodge 11 6 Linear Dodge 12 Lighter Color 13 Overlay 15 3 Soft Light 16 9 Hard Light 17 8 Linear Light 18 Vivid Light 19 Pin Light 20 Hard Mix 21 16 Difference 23 10 Exclusion 24 11 Hue 26 12 Saturation 27 13 Color 28 14 Luminosity 29 15","title":"Blend Mode"},{"location":"aep/#label-colors","text":"Value Name Default Color 0 None (shows as grey) 1 Red #b4393b 2 Yellow #e2d759 3 Aqua #abcbc8 4 Pink #e5bcca 5 Lavender #a9aac9 6 Peach #e5c19f 7 Sea Foam #b4c7b4 8 Blue #687fdd 9 Green #4ea350 10 Purple #8d3299 11 Orange #e79228 12 Brown #7e442c 13 Fuchsia #f371d5 14 Cyan #43a2a4 15 Sandstone #a7967a 16 Dark Green #203f1f","title":"Label Colors"},{"location":"aep/#text-render-oder","text":"Per character palette Fills over strokes Strokes over fills","title":"Text Render Oder"},{"location":"aep/#chunk-data","text":"Note that chunks might have extra data after what is described here, always parse exactly as many bytes as specified in the chunk header.","title":"Chunk Data"},{"location":"aep/#list","text":"This chunk is defined by the RIFF specs, its data has the following format: Starts with an id , specifying the type of the list, then followed by sub-chunks. The format of specific LIST types are described later in this document. Note that the LIST btdk doesn't conform to RIFF, so take care to not read over the chunk length.","title":"LIST"},{"location":"aep/#utf8","text":"Contains utf-8 encoded text. Sometimes it contains the string -_0_/- which (I guess) is used as a placeholder for objects lacking a name.","title":"Utf8"},{"location":"aep/#tdsn-fnam-pdnm","text":"Contains a Utf8 chunk, used for object names","title":"tdsn / fnam / pdnm"},{"location":"aep/#tdmn","text":"Contains a NUL-terminated string (You'll need to strip excess \\0 ) and defines a Match Name .","title":"tdmn"},{"location":"aep/#cmta","text":"Comment, NUL-terminated string. The size seems to be variable but rounded to 4 bytes.","title":"cmta"},{"location":"aep/#fdta","text":"Folder data.","title":"fdta"},{"location":"aep/#cdta","text":"Composition data. Field Name Size Type Description X Resolution 2 uint16 Y Resolution 2 uint16 1 Time Scale 2 uint16 How much Time values are scaled by 14 Playhead 2 Time Playhead time 6 In Time 2 Time Same as ip in Lottie 6 Out Time 2 Time Same as op in Lottie 6 Comp duration 2 Time Duration setting in AE 5 Color 3 bytes Color as 24 bit RGB 84 Attributes 1 Flags Width 2 uint16 Same as w in Lottie Height 2 uint16 Same as h in Lottie Pixel Ratio Width 4 uint32 Pixel Ratio Height 4 uint32 12 Framerate 2 uint16 Same as fr in Lottie 16 Shutter Angle 2 uint16 Shutter Phase 4 sint16 16 Samples Limit 4 sint16 Samples per frame 4 sint16 Note that End Time might have a value of FFFF, if that's the case assume it to be the same as Comp Duration. The X/Y resolution represent a divisor of the size in that direction used for rendering. For example a X Resolution of 5, with a width of 500 will yield an output of 100px. The pixel ratio is represented as a fraction of width/height, if both values are 1 you get square pixels. Attributes: Shy: (0, 0): Hides Shy layers from the timeline Motion Blur: (0, 3): Allows layers to enable motion blur Frame Blending: (0, 4): Allows layers to enable frame blending Preserve Framerate: (0, 5): Something about nested render queues Preserve Resolution: (0, 7): Something about nested render queues","title":"cdta"},{"location":"aep/#ldta","text":"Layer data, it seems that AE23 adds 4 extra 00 bytes at the end compared to older versions. Field Name Size Type Description Layer ID 4 uint32 Quality 2 uint16 0 : Wireframe, 1 : Draft, 2 : Best 4 Stretch Numerator 2 uint16 1 Start Time 2 sint16 Time offset for times withing the layer 6 In Time 2 Time Same as ip in Lottie 6 Out Time 2 Time Same as op in Lottie 6 Attributes 3 Flags Source ID 4 uint32 Item id for the used asset 17 Label Color Index 1 uint8 Label Colors 2 Layer Name 32 string0 It's repeated in the Utf8 chunk right after 11 Matte Mode 1 uint8 2 Stretch Denominator 2 uint16 19 Layer Type 1 uint8 Parent ID 4 uint32 ID of the parent layer, if any 24 Matte Layer ID 4 uint32 Id of the layer masking the current layer, if any (only for AE >= 23) With the following Attributes: Guide : (0, 1) Guide layers aren't rendered Bicubic Sampling : (0, 6) Auto Orient : (1, 0) Adjustment : (1, 1) Whether it's an adjustment layer Threedimensional : (1, 2) Solo : (1, 3) (UI thing, only displays that layer) Null : (1, 7) Whether it's a null layer Visible : (2, 0) Effects : (2, 2) Motion Blur : (2, 3) Locked : (2, 5) Shy : (2, 6) (Used to hide some layers in the AE UI) Conitnuosly Rasterize (vector) / Collapse Transform (comps): (2, 7) Layer Types: 0: Asset Layer 1: Light Layer 2: Camera Layer 3: Text Layer 4: Shape Layer Matte Modes: No Matte Alpha Inverted Alpha Luma Inverted Luma Time streching is defined as a fraction of Stretch Numerator / Stretch Denominator","title":"ldta"},{"location":"aep/#idta","text":"Item data. Field Name Size Type Description Type 2 uint16 14 ID 4 uint32 ID used to reference this item 38 Label Color 1 uint8 Label Colors The Type field above can have the following values: 1 : Folder 4 : Composition 7 : Footage The last 2 bytes of this field seem to change every time you make a change.","title":"idta"},{"location":"aep/#tdb4","text":"Property metadata. Field Name Size Type Description 2 Always db 99 ? Components 2 uint16 Number of values in a multi-dimensional Attributes 2 Flags 1 1 Some sort of flag, it has value 03 for position properties 2 2 2 Always 0000 ? 2 2nd most significant bit always on, perhaps some kind of flag 8 float64 Most of the time 0.0001 8 float64 Most of the time 1.0 , sometimes 1.777 8 float64 Always 1.0 ? 8 float64 Always 1.0 ? 8 float64 Always 1.0 ? Type? 4 Flags See below 1 Seems correlated with the previous byte, it's set for 04 for enum properties 7 Bunch of 00 Animated 1 Set to 1 when animated, kinda the reverse of the Static bit in Attributes 7 Bunch of 00 4 Usually 0, probs flags 4 Mst likely flags, only last byte seems to contain data 8 float64 Always 0.0 ? 8 float64 Mostly 0.0 , sometimes 0.333 8 float64 Always 0.0 ? 8 float64 Mostly 0.0 , sometimes 0.333 4 Probs some flags 4 Probs some flags Attributes: Position : (1, 3). When true , this is a position property, which changes how animated values are parsed. Static : (1, 0). When false , the property is animated and it will have a cdat . Types: No Value : (1, 0). Used for properties like shapes, gradients, etc, where the values are not in the keyframe. Integer : (3, 2). Vector ?: (3, 3). Color : (3, 0). Set for color properties (they have a different keyframe format). For Integer type, you might have indexed values: For layers, the value will be in tdpi / tdps , for masks it will be in tdli .","title":"tdb4"},{"location":"aep/#cdat","text":"Property static value. For multi-dimensional properties, you look at the number of components in tdb4 and parse that many float64 , that's the value of the property.","title":"cdat"},{"location":"aep/#shph","text":"Header for bezier shape data, contained within LIST shap . It's followed by a LIST list with bezier data. Field Name Size Type Description 3 Attributes 1 Flags Top Left 2 float32 Top-left corner of the shape area, relative to the layer position Bottom Right 2 float32 Bottom-right corner of the shape area, relative to the layer position 4 Flags: Open : (0, 3). When true , the shape is open (it's missing the segment connecting the last point to the first)","title":"shph"},{"location":"aep/#lhd3","text":"Inside a LIST list , defines the data format, followed by ldat . Field Name Size Type Description 4 Seems to always be 00 d0 0b ee 6 All 00 Count 2 uint16 Number of items 4 The last byte is the only one that changes, greatest variation is on shapes 2 All 00 Item Size 2 uint16 Size of an item in the list 3 All 00 Type? 1 4 00 00 00 01 2 All 00 2 Some kind of flags 20 All 00 Item Type Size Type Gide 00 01 02 LItm 00 80 01 LRdr 08 c6 01 Color Kf 00 98 04 1D Kf 00 30 04 2D Kf 00 58 04 2D pos Kf 00 68 04 3D Kf 00 80 04 3D pos Kf 00 80 04 Marker Kf 00 10 04 Orientation Kf 00 50 04 No Value Kf 00 40 04 The corresponding ldat should have Item Size * Count bytes, and it's omitted if Count is 0.","title":"lhd3"},{"location":"aep/#ldat","text":"Inside a LIST list , contains the list data, preceded by lhd3 . The number of element is the one defined in lhd3 . It has a different format based on certain conditions, follow some of the possible element formats. The size of an item is found like so: item_size = ldat_chunk_length / lhd3_count","title":"ldat"},{"location":"aep/#keyframe-common","text":"All keyframe items start like this: Field Name Size Type Description 1 Time 2 Time Time of the keyframe, seems they always start from 0. 2 Ease Mode 1 uint8 Label Color 1 uint8 Label Colors Attributes 1 Flags Ease Mode: 1. Linear 2. Ease 3. Hold Attributes: Least significant 3 bits seems to always be on. Continuous Bezier (0, 3) Auto Bezier (0, 4) Roving across time (0, 5)","title":"Keyframe (common)"},{"location":"aep/#keyframe-multi-dimensional","text":"Given n as the number of dimensions found in tdb4 (eg: 3 for 3D positions): Field Name Size Type Description Value 8* n float64[n] Value In Speed 8* n float64[n] In Influence 8* n float64[n] Out Speed 8* n float64[n] Out Influence 8* n float64[n]","title":"Keyframe - Multi-Dimensional"},{"location":"aep/#keyframe-position","text":"If the property is an animated position, the keyframe is formatted like so: Field Name Size Type Description 8 8 float64 In Speed 8 float64 In Influence 8 float64 Out Speed 8 float64 Out Influence 8 float64 Value 8* n float64[n] Value Tan In 8* n float64[n] Spatial tangents Tan Out 8* n float64[n] Spatial tangents","title":"Keyframe - Position"},{"location":"aep/#keyframe-no-value","text":"Used for shapes and gradients ( Special set in tdb4 ) Field Name Size Type Description 8 8 float64 In Speed 8 float64 In Influence 8 float64 Out Speed 8 float64 Out Influence 8 float64 8","title":"Keyframe - No Value"},{"location":"aep/#keyframe-color","text":"Field Name Size Type Description 8 8 float64 In Speed 8 float64 In Influence 8 float64 Out Speed 8 float64 Out Influence 8 float64 Value 8*4 float64[4] ARGB 255 8*8 float64[8]","title":"Keyframe - Color"},{"location":"aep/#shape-data","text":"Bezier data, positions are relative to the area defined by shph . The list is a sequence of points, appearing in this order: Vertex 0 Out Tangent 0 In Tangent 1 Vertex 1 Out Tangent 1 ... Note that all coordinates are relative to the area in shph but not to each other. A coordinate of [0, 0] will correspond to the top-left corner in shph , and [1, 1] corresponds to the bottom-right. Field Name Size Type Description X 4 float32 X Coordinate XY 4 float32 X Coordinate","title":"Shape Data"},{"location":"aep/#pprf","text":"Color profile information as ICC data.","title":"pprf"},{"location":"aep/#fiac","text":"Folder item active, uint8 if it's 1 the previous List Item is the active item.","title":"fiac"},{"location":"aep/#wsnm","text":"Worspace name. Utf-16 encoded string, contains the name of the \"workspace\" (window layout in AE) It's always followed by an Utf8 with the same content.","title":"wsnm"},{"location":"aep/#tdum-tdum","text":"float64 values often found inside LIST tdbs . In some cases they seem to indicate minimum and maximum values for that property but there are some cases in which they are both 0.0 .","title":"tdum / tduM"},{"location":"aep/#ppsn","text":"Contains a float64 , unknown meaning.","title":"ppSn"},{"location":"aep/#otda","text":"Orientation data Field Name Size Type Description X 8 float64 X Coordinate Y 8 float64 Y Coordinate Z 8 float64 Z Coordinate","title":"otda"},{"location":"aep/#opti","text":"Asset data, format depends on type Field Name Size Type Description Type 4 string Asset type","title":"opti"},{"location":"aep/#solid","text":"Type Soli , data for solid layers. Field Name Size Type Description 6 Alpha 4 float32 Red 4 float32 Green 4 float32 Blue 4 float32 Name 256 string0 Color components are in [0, 1].","title":"Solid"},{"location":"aep/#sspc","text":"Footage / asset data. Field Name Size Type Description 32 Width 2 uint16 2 Height 2 uint16","title":"sspc"},{"location":"aep/#alas","text":"JSON string containing external asset info. Field Name Type Description ascendcount_base number ascendcount_target number fullpath string The absolute path to the file platform number Operating system (see below) server_name string Hostname (?) server_volume_name string target_is_folder boolean Whether the file is a folder platform values: 1 is Windows, other values are for Unix and MacOS, but the values are to be discovered","title":"alas"},{"location":"aep/#head","text":"Field Name Size Type Description AE Version? 6 12 File Revision? 2 uint16 Increases by 2 every time you save Seems the first 6 bytes contain AE version information. I haven't been able to decode it fully but here's a list of values encountered in the wild: Version Bytes 15.0 5c 06 07 38 06 b4 16.0 5d 04 0b 00 06 eb 16.0.1 5d 04 0b 00 0e 30 16.1.2 5d 05 0b 00 96 37 16.1.3 5d 05 0b 00 9e 05 17.0 5d 09 4b 08 06 2b 17.0.4 5d 0b 0b 08 26 3b 18.2.1 5d 1b 0b 11 0e 08 18.4 5d 1d 0b 12 06 26 22.0 5d 1d 0b 70 06 6f 22.6 5d 2b 0b 33 06 3b 23.2.1 5e 03 0b 39 0e 03 It's possible the 3rd to the 5th bytes encode some kind of internal build number that gets mapped to AE versions somehow...","title":"head"},{"location":"aep/#efdc","text":"The first byte contains the number of LIST EfDf in a LIST EfdG","title":"EfDC"},{"location":"aep/#parn","text":"Contains a uint64 with the number of parameters in a LIST parT .","title":"parn"},{"location":"aep/#pard","text":"Effect parameter definition. Field Name Size Type Description 15 Type 1 uint8 Parameter type Name 32 string0 8 Types: Type Name AEP Lottie Lottie Object Layer 0 10 Effect Value Layer Scalar 2 0 Effect Value Slider Angle 3 1 Effect Value Angle Boolean 4 4 Effect Value Checkbox Color 5 2 Effect Value Color 2D 6 3 Effect Value Point Enum 7 7 Effect Value Drop Down Paint Group 9 Slider 10 0 Effect Value Slider Group 13 5 Custom Effect Unknown 15 6 Effect No Value 3D 18 3 Effect Value Point After the data above, there is more data that depends on the type","title":"pard"},{"location":"aep/#layer_1","text":"Doesn't seem to have much data","title":"Layer"},{"location":"aep/#scalar-angle","text":"Field Name Size Type Description Last value 4 sint32 4 64 4 Min Value 2 sint16 2 Max Value 2 sint16 To get the last value, you need to divide the raw value by 0x10000 .","title":"Scalar / Angle"},{"location":"aep/#boolean","text":"Field Name Size Type Description Last used value 4 uint32 Default 1 uint8 3 64 4 float32 4 4 float32","title":"Boolean"},{"location":"aep/#color","text":"Field Name Size Type Description Last used value 4 uint8[4] ARGB Default 4 uint8[4] ARGB 64 Max Value 4 uint8[4] ARGB","title":"Color"},{"location":"aep/#2d","text":"Field Name Size Type Description Last value X 4 sint32 Last value Y 4 sint32 Last value x/y are multiplied by 0x80, so divide them to get the right value.","title":"2D"},{"location":"aep/#enum","text":"Field Name Size Type Description Last used value 4 uint32 Option count 2 uint16 Default 2 uint16","title":"Enum"},{"location":"aep/#slider","text":"Field Name Size Type Description Last used value 8 float64 44 4 float32 4 Max Value 4 float32","title":"Slider"},{"location":"aep/#3d-point","text":"Field Name Size Type Description Last value X 8 float64 Last value Y 8 float64 Last value Z 8 float64 You need to multiply the \"Last value\" components by 512 to get the actual values.","title":"3D Point"},{"location":"aep/#pdnm","text":"Effect parameter definition name / strings. This will contain strings used by the widget in the effect controls of the preceding pard . For example if the type in the pard is 4 (Boolean) the name of the parameter might be empty and it will be in pdnm as that's how AE displays it. For Enum (type 7 ), you get the drop down strings separated by | .","title":"pdnm"},{"location":"aep/#tdpi","text":"Layer index for index properties ( uint32 ).","title":"tdpi"},{"location":"aep/#tdps","text":"Layer source for index properties ( sint32 ). 0 : Layer -1 : Effects & Masks -2 : Masks","title":"tdps"},{"location":"aep/#tdli","text":"Mask index for index properties ( uint32 ).","title":"tdli"},{"location":"aep/#prin","text":"Seems to always have the same content: 4 00 bytes, the string ADBE Escher , 37 00 , the string Classic 3D , 41 00 , and ends with 01 .","title":"prin"},{"location":"aep/#prda","text":"Seems to always have the same content: 3 00 , a 01 , 8 00 .","title":"prda"},{"location":"aep/#nmhd","text":"Marker attributes Name Size Type Description 3 Attributes 1 Flags Duration 4 uint32 Duration in frames 4 Label Color 1 uint8 Label Colors Flags: Protected : (0, 1) The marker signals a protected region ??? : (0, 2) This flags seems to always be on","title":"NmHd"},{"location":"aep/#tdsb","text":"4 bytes specifying flags for a tdgp . 0x00'00'00'01 - object is visible 0x00'00'00'02 - split position 0x00'00'20'00 - locked x/y ratio","title":"tdsb"},{"location":"aep/#mkif","text":"Mask properties. Name Size Type Inverted 1 uint8 Locked 1 uint8 4 Mode 2 uint16 Mask Modes: 0: None 1: Add 2: Subtract 3: Intersect 4: Darken 5: Lighten 6: Difference","title":"mkif"},{"location":"aep/#ccid","text":"Composition ID for essential graphics properties ( uint32 )","title":"CCId"},{"location":"aep/#clid","text":"Layer ID for essential graphics properties ( uint32 )","title":"CLId"},{"location":"aep/#smin","text":"Essential graphics slider minimum value. Representation depends on the value of the previous CTyp .","title":"Smin"},{"location":"aep/#smax","text":"Essential graphics slider maximum value. Representation depends on the value of the previous CTyp .","title":"Smax"},{"location":"aep/#cval","text":"Essential graphics property current value. Representation depends on the value of the previous CTyp .","title":"CVal"},{"location":"aep/#cdef","text":"Essential graphics property default value. Representation depends on the value of the previous CTyp .","title":"CDef"},{"location":"aep/#ctyp","text":"uint32 with the essential graphics item type Name Type Value Format Scalar 2 float64 Color 4 float32[4] RGBA Position 5 float64[2] Comment 8 Vector 9 float64[4] Group 10 Enum 13 uint32","title":"CTyp"},{"location":"aep/#cprc","text":"Essential graphics flags (4bytes) Is property (3, 0)","title":"CprC"},{"location":"aep/#stvs","text":"Essential graphics group item count Name Size Type Count 1 uint8 3","title":"StVS"},{"location":"aep/#cdim","text":"uint32 number of dimensions for an essential vector property.","title":"CDim"},{"location":"aep/#fips","text":"Contained in LIST Fold contains preview settings. The chunk is repeated multiple times but only the first one seems to be relevant. Name Size Type 15 Flags 1 uint8 Flags Show alpha grid (0, 7)","title":"fips"},{"location":"aep/#list-fold","text":"Top level item.","title":"LIST Fold"},{"location":"aep/#list-item","text":"Item, you can check its properties with idta contained inside it.","title":"LIST Item"},{"location":"aep/#list-layr","text":"Defines a layer. Layer metadata is found in a ldta , the layer name is in a Utf8 . Go through its LIST tdgp to get shapes and transforms. You will find the following match names within it: ADBE Root Vectors Group : Contains shape data (shape layer in lottie) ADBE Camera Options Group : Lottie camera layer ADBE Transform Group : Layer transform ADBE Layer Styles : Layer styles","title":"LIST Layr"},{"location":"aep/#list-tdgp","text":"Defines an object / property group. Flags for the objects are in tdsb . The name of the object is in tdsn > Utf8 . Then follows a sequence of properties / objects defined as such: tdmn specifies the match name of the object, then it's followed by chunks that describe said object (usually more LIST s). Usually the last chunk here is a tdmn with value ADBE Group End .","title":"LIST tdgp"},{"location":"aep/#list-tdbs","text":"Defines an object's property. To know which property, you need to check the tdmn preceding this chunk. It will contain a tdb4 , and usually cdat (static) or a List list (animated). For properties with expressions, it will have a Utf8 with the expression code.","title":"LIST tdbs"},{"location":"aep/#list-gcst","text":"Defines a gradient. Contains a LIST tdbs and a LIST GCky .","title":"LIST GCst"},{"location":"aep/#list-gcky","text":"Gradient color keyframes. Contains a sequence of Utf8 formatted in XML with the gradient definition for each keyframe.","title":"LIST GCky"},{"location":"aep/#list-om-s","text":"Contains a LIST tdbs and a LIST omks to define a shape property.","title":"LIST om-s"},{"location":"aep/#list-omks","text":"Bezier shape data. Contains a sequence of LIST shap with the shape data for each keyframe.","title":"LIST omks"},{"location":"aep/#list-shap","text":"Contains a shph and a LIST list with the shape data.","title":"LIST shap"},{"location":"aep/#list-cppl","text":"Contains a pprf .","title":"LIST CPPl"},{"location":"aep/#list-list","text":"For animated properties it replaces cdat . The list header is defined in the chunk lhd3 , the list data in ldat .","title":"LIST list"},{"location":"aep/#list-slay-list-dlay-list-clay","text":"They seem to be camera layers used to store internal views, not exported to lottie. SLay (Side views?) have names like \"Top\" and \"Front\", perhaps they define 3d views. CLay : Custom views. DLay : Default views.","title":"LIST SLay / LIST DLay / LIST CLay"},{"location":"aep/#list-secl","text":"Composition Markers Layer. Contains ldta and like other layers. in LIST tbgp look for the match name ADBE Marker , the data is in the LIST mrst .","title":"LIST SecL"},{"location":"aep/#list-mrst","text":"Marker property. Contains a LIST tdbs that defines the property, which should always be animated when present. Marker keyframe values are available in LIST mrky .","title":"LIST mrst"},{"location":"aep/#list-mrky","text":"Marker keyframes. contains a LIST Nmrd for each keyframe","title":"LIST mrky"},{"location":"aep/#list-nmrd","text":"Marker data There's a NmHd with the attributes. The marker comment is in the first Utf8","title":"LIST Nmrd"},{"location":"aep/#list-otst","text":"Orientation property. Contains a LIST tdbs and a LIST otky to define a shape property.","title":"LIST otst"},{"location":"aep/#list-otky","text":"Contains a sequence of otda with the orientation data for each keyframe.","title":"LIST otky"},{"location":"aep/#list-als2","text":"Contains alas for external assets.","title":"LIST Als2"},{"location":"aep/#list-sfdr","text":"Asset folder contents, contains several LIST Item .","title":"LIST Sfdr"},{"location":"aep/#list-btdk","text":"For some reason this doesn't conform to the RIFX specs, instead of a list its data is encoded in Carousel Object Structure (COS). The COS format is the same used in PDF but it's extremely difficult to find detailed information on it, the best technical specs is this very old PDF 1.7 specification . Once you parse the COS, you can find the following data: 0.1.0 : Array of available fonts: 0.99 : CoolTypeFont 0.0.0 : Font family (seems to have bold/italic encoded in the name) 0.0.2 : 0 or 1 ? 1.1 : Array of text documents (one for each keyframe) in this format: 0.0 : Text 0.5.0 : Array of paragraph styles 0.0.5 Paragraph Style: 0 : Text align ( 0 : left, 1 : right, 2 : center) 1 : Length (in characters) the style applies to 0.6.0 : Array of character styles: 0.0.6 : Character Style: 0 : Index of the font from the array of available fonts 1 : Font size 2 : Faux Bold 3 : Faux Italic 12 : 0 : Normal, 1 : Small caps, 2 : All caps 13 : 0 : Normal, 1 : Superscript, 2 : Subscript 53.0.1 : Fill color in ARGB [0, 1] 54.0.1 : Stroke color in ARGB [0, 1] 57 : Stroke enabled 58 : Stroke over fill 63 : Stroke width 1 : Length (in characters) the style applies to","title":"LIST btdk"},{"location":"aep/#list-sspc","text":"Effect Definiton. The generic effect name is in fnam > Utf8 . The effect parameters are defined in LIST parT . If the effect type has already been encountered, you might not find the LIST parT here, you might need to match the name to an entry in LIST EfdG . It finally contains a LIST tdgp where the effect properties are present like any other animated property. You can also find the name of the effect object in fnam > Utf8 . Inside there you can also find a match name with ADBE Effect Built In Params which will contain values for built-in effect parameters.","title":"LIST sspc"},{"location":"aep/#list-part","text":"Effect parameters. Contains a parn with the number of parameters, then follows a list of tdmn with the match name of the parameter followed by pard with its definition. Enum parameters have their values in a pdnm separated by | pipes. The first property seems to be a dummy?","title":"LIST parT"},{"location":"aep/#list-efdg","text":"Effect definitions. This is where effect types used by the project are defined. Basically it repeats the first instance of any effect found in the layers. it contains a EfDC with the number of effects, and that many LIST EfDf .","title":"LIST EfdG"},{"location":"aep/#list-efdf","text":"Effect type definition. Contains a tdmn with the match name of the effect and a LIST sspc .","title":"LIST EfDf"},{"location":"aep/#list-exen","text":"Contains a Utf8 with the expression language (eg: javascript-1.0 ).","title":"LIST ExEn"},{"location":"aep/#list-prin","text":"Contains a prin and a prda .","title":"LIST PRin"},{"location":"aep/#list-pin","text":"Asset properties. Contains: sspc with some common properties Utf8 with the name (except for solids) opti with asset data","title":"LIST Pin"},{"location":"aep/#list-cif0","text":"See LIST CIF3 .","title":"LIST CIF0"},{"location":"aep/#list-cif2","text":"See LIST CIF3 .","title":"LIST CIF2"},{"location":"aep/#list-cif3","text":"Essential Graphics Definition.","title":"LIST CIF3"},{"location":"aep/#list-cctl","text":"Essential graphics item.","title":"LIST CCtl"},{"location":"aep/#list-cps2","text":"Essential graphics header.","title":"LIST CpS2"},{"location":"aep/#list-stvc","text":"Essential graphics group items","title":"LIST StVc"},{"location":"aep/#list-cprp","text":"Essential graphics property definition","title":"LIST CPrp"},{"location":"aep/#list-ovg2","text":"Essential graphics override property identifiers","title":"LIST OvG2"},{"location":"aep/#list-cprp_1","text":"Essential graphics override property identifier","title":"LIST CPrp"},{"location":"aep/#list-lrdr","text":"Render queue data. this is a top-level chunk. Items are stored in LIST LItm .","title":"LIST LRdr"},{"location":"aep/#list-litm","text":"Render Queue items, contains a sequence of LIST list and LIST LOm , the latter having information on the render item (one per job).","title":"LIST LItm"},{"location":"aep/#list-lom","text":"Render list item, contains the following chunks: Roou Output options? Ropt Render options? LIST Als2 Selected output file Utf8 Name of the template applied to the item Utf8 File name template","title":"LIST LOm"},{"location":"aep/#gradient-xml","text":"Gradient data seems to be stored in a convoluted XML structure. The easiest way to describe it is as a mapping, the elements can be parsed like so: Tag Name Logical Type Description prop.map Top-level, just get its first child prop.list dict Mapping of key-value pairs prop.pair Item in prop.list key str Property key array list Array of values, the first item is array.type which specifies the type int int float float string str If you interpret the XML as a mapping, you can gather the following info: { \"Gradient Color Data\": { \"Alpha Stops\": { \"Stops List\": { \"Stop-0\": { \"Stops Alpha\": [ 0.0, // offset 0.5, // midpoint 1.0 // alpha ] }, // More stops defined the same way... } \"Stops Size\": 2 // Number of stops }, \"Color Stops\": { \"Stops List\": { \"Stop-0\": { \"Stops Color\": [ 0.0, // offset 0.5, // midpoint 0.0, // red 0.0, // green 0.5, // blue 1.0 // alpha? ] }, // More stops defined the same way... } \"Stops Size\": 2 // Number of stops } }, \"Gradient Colors\": \"1.0\" // Version? }","title":"Gradient XML"},{"location":"aep/#midpoint","text":"You should use the \"midpoint\" values to add an additional color which is halfway between the other two. For example given these stops: \"Stop-0\": { \"Stops Color\": [ 0.0, // offset 0.5, // midpoint 0.1, // red 0.2, // green 0.3, // blue 1.0 // alpha? ] }, \"Stop-0\": { \"Stops Color\": [ 0.6, // offset 0.5, // midpoint 0.3, // red 0.4, // green 0.5, // blue 1.0 // alpha? ] }, The final gradient will look like this: [ // stop 0 0.0, // offset_0 0.1, // red_0 0.2, // green_0 0.3, // blue_0 // midpoint stop 0.3, // offset_0 * (1 - midpoint_0) + offset_1 * midpoint_0 0.2, // (red_0 + red_1) / 2 0.3, // (green_0 + green_1) / 2 0.4, // (blue_0 + blue_1) / 2 // stop 1 0.6, // offset_1 0.5, // midpoint_1 0.3, // red_1 0.4, // green_1 0.5, // blue_1 ]","title":"Midpoint"},{"location":"aep/#opacity","text":"For some reason in AE gradients alpha is independent from the color, so you have separate stops for color and opacity. You should treat the midpoint value for opacity stops in a similar way as to the color ones. Once you have both the color and opacity values, the final lottie array is simply a concatenation of the two.","title":"Opacity"},{"location":"aep/#xmp-metadata","text":"After the RIFX data, an AEP file also contains some XML in the XMP format. This section contains the version of AfterEffects, when the file has been created and modified, and related info.","title":"XMP Metadata"},{"location":"aep/#xml-project-format","text":"Aftereffects allows you to save the project as XML. This is basically as the RIFX but with a different container format and binary data encoded as hex. Conversion notes for elements are provided below","title":"XML Project Format"},{"location":"aep/#aftereffectsproject","text":"Root element, same as RIFX .","title":"AfterEffectsProject"},{"location":"aep/#projectxmpmetadata","text":"In the RIFX file this is dumped at the end without a chunk.","title":"ProjectXMPMetadata"},{"location":"aep/#string","text":"Used instead of Utf8 .","title":"string"},{"location":"aep/#nums-ppsn","text":"For some reason they have their value in a <string> but are not string in the RIFX.","title":"numS / ppSn"},{"location":"aep/#tdsn-fnam-pdnm_1","text":"These elements contain children but they are not LIST in RIFX, that's the only thing of note.","title":"tdsn / fnam / pdnm"},{"location":"aep/#child-elements","text":"If an element has children. it's the same as the equivalent LIST in RIFX.","title":"Child elements"},{"location":"aep/#bdata","text":"Elements with the bdata attribute have their binary data hex encoded in said attribute. You can parse their data the same way as you'd do in RIFX.","title":"bdata"},{"location":"aep/#resources","text":"aftereffects-aep-parser A basic AEP parser written in Go. Multimedia Programming Interface and Data Specifications 1.0 RIFF specs PDF. Floating Point to Hex Converter Float to hex converter. bodymovin-extension AE extensions that exports to Lottie After Effects Scripting Guide Shape Layer Match Names Portable document format \u2014 Part 1: PDF 1.7 The only COS reference I've found","title":"Resources"},{"location":"animation/","text":"Animation This is the top-level JSON object, describing the document, layers, assets, etc. The size of the canvas is determined by w and h . Duration is expressed in frames with op , and the framerate is in fr . Most of the contents are in layers and assets . Attribute Type Description layers array of Precomposition Layer or Solid Color Layer or Image Layer or Null Layer or Shape Layer or Text Layer or Audio Layer or Camera Layer or Data Layer An array of layers (See: Lists of layers and shapes ) nm string Name, as seen from editors and the like mn string Match name, used in expressions assets array of Image or Precomposition or Sound or Data source An array of assets v string Lottie version, on very old versions some things might be slightly different from what is explained here ddd 0-1 integer Whether the animation has 3D layers. Lottie doesn't actually support 3D stuff so this should always be 0 fr number Framerate in frames per second ip number \"In Point\", which frame the animation starts at (usually 0) op number \"Out Point\", which frame the animation stops/loops at, which makes this the duration in frames when ip is 0 w integer Width of the animation h integer Height of the animation comps array of Precomposition List of Extra compositions not referenced by anything fonts Font List Fonts chars array of Character Data Data defining text characters as lottie shapes. If present a player might only render characters defined here and nothing else. meta Metadata Document metadata metadata User Metadata User Metadata markers array of Marker Markers defining named sections of the composition. mb Motion Blur Motion Blur slots object Available property overrides Metadata Some (but not all) lottie files will have a metadata object describing the program used to create the file and other useful information: Document Metadata Attribute Type Description a string Author d string Description tc string Theme Color g string Software used to generate the file User Metadata Attribute Type Description filename string Filename customProps object Custom Properties Motion Blur Attribute Type Description sa number Angle in degrees sp number Angle in degrees spf number Samples per Frame asl number Adaptive Sample Limit Marker Attribute Type Description cm string Comment tm number Time dr number Duration","title":"Animation"},{"location":"animation/#animation","text":"This is the top-level JSON object, describing the document, layers, assets, etc. The size of the canvas is determined by w and h . Duration is expressed in frames with op , and the framerate is in fr . Most of the contents are in layers and assets . Attribute Type Description layers array of Precomposition Layer or Solid Color Layer or Image Layer or Null Layer or Shape Layer or Text Layer or Audio Layer or Camera Layer or Data Layer An array of layers (See: Lists of layers and shapes ) nm string Name, as seen from editors and the like mn string Match name, used in expressions assets array of Image or Precomposition or Sound or Data source An array of assets v string Lottie version, on very old versions some things might be slightly different from what is explained here ddd 0-1 integer Whether the animation has 3D layers. Lottie doesn't actually support 3D stuff so this should always be 0 fr number Framerate in frames per second ip number \"In Point\", which frame the animation starts at (usually 0) op number \"Out Point\", which frame the animation stops/loops at, which makes this the duration in frames when ip is 0 w integer Width of the animation h integer Height of the animation comps array of Precomposition List of Extra compositions not referenced by anything fonts Font List Fonts chars array of Character Data Data defining text characters as lottie shapes. If present a player might only render characters defined here and nothing else. meta Metadata Document metadata metadata User Metadata User Metadata markers array of Marker Markers defining named sections of the composition. mb Motion Blur Motion Blur slots object Available property overrides","title":"Animation"},{"location":"animation/#metadata","text":"Some (but not all) lottie files will have a metadata object describing the program used to create the file and other useful information:","title":"Metadata"},{"location":"animation/#document-metadata","text":"Attribute Type Description a string Author d string Description tc string Theme Color g string Software used to generate the file","title":"Document Metadata"},{"location":"animation/#user-metadata","text":"Attribute Type Description filename string Filename customProps object Custom Properties","title":"User Metadata"},{"location":"animation/#motion-blur","text":"Attribute Type Description sa number Angle in degrees sp number Angle in degrees spf number Samples per Frame asl number Adaptive Sample Limit","title":"Motion Blur"},{"location":"animation/#marker","text":"Attribute Type Description cm string Comment tm number Time dr number Duration","title":"Marker"},{"location":"assets/","text":"Assets Assets are usually referenced by layers of the appropriate type. Image Represents a (static) image Attribute Type Description id string Unique identifier used by layers when referencing this asset nm string Human readable name u string Path to the directory containing a file p string Filename or data url e 0-1 integer Whether the file is embedded w number Width of the image h number Height of the image t string = 'seq' Marks as part of an image sequence if present sid string One of the ID in the file's slots If the image is embedded, u is empty and p contains a base64-encoded data url: { \"id\": \"my image\", \"h\": 512, \"w\": 512, \"e\": 1, \"u\": \"\", \"p\": \"data:image/png;base64,...\" } If the image is not embedded, u will contain the path to the directory containing the image and p will have the filename. So for example if you want to store the image at /path/to/images/image.png , the asset will look something like this: { \"id\": \"my image\", \"h\": 512, \"w\": 512, \"e\": 0, \"u\": \"/path/to/images/\", \"p\": \"image.png\" } It works similarly for external images. If you want to store the image at https://example.com/images/image.png , you'd have: { \"id\": \"my image\", \"h\": 512, \"w\": 512, \"e\": 0, \"u\": \"https://example.com/images/\", \"p\": \"image.png\" } Sound Similar to Image but for audio files. Attribute Type Description id string Unique identifier used by layers when referencing this asset nm string Human readable name u string Path to the directory containing a file p string Filename or data url e 0-1 integer Whether the file is embedded Precomposition You can think of precompositions as self-contained animation within the main animation file that can be referenced using precomp layers . Within a precomposition you can have precomp layers showing other precompositions, as long as you don't create a dependency cycle. You can find more details in the Precompositions page. Attribute Type Description layers array of Precomposition Layer or Solid Color Layer or Image Layer or Null Layer or Shape Layer or Text Layer or Audio Layer or Camera Layer or Data Layer An array of layers (See: Lists of layers and shapes ) id string Unique identifier used by layers when referencing this asset nm string Human readable name fr number Framerate in frames per second xt 0-1 integer Extra composition Follows a rather extreme example, that uses precompositions inside precompositions to generate a fractal: var lottie_player_0 = new LottiePlayer( 'lottie_target_0', '../examples/fractal.json', true, {} ); Data Source Points to a JSON file for data. Attribute Type Description id string Unique identifier used by layers when referencing this asset nm string Human readable name u string Path to the directory containing a file p string Filename or data url e 0-1 integer Whether the file is embedded t integer = 3 Type","title":"Assets"},{"location":"assets/#assets","text":"Assets are usually referenced by layers of the appropriate type.","title":"Assets"},{"location":"assets/#image","text":"Represents a (static) image Attribute Type Description id string Unique identifier used by layers when referencing this asset nm string Human readable name u string Path to the directory containing a file p string Filename or data url e 0-1 integer Whether the file is embedded w number Width of the image h number Height of the image t string = 'seq' Marks as part of an image sequence if present sid string One of the ID in the file's slots If the image is embedded, u is empty and p contains a base64-encoded data url: { \"id\": \"my image\", \"h\": 512, \"w\": 512, \"e\": 1, \"u\": \"\", \"p\": \"data:image/png;base64,...\" } If the image is not embedded, u will contain the path to the directory containing the image and p will have the filename. So for example if you want to store the image at /path/to/images/image.png , the asset will look something like this: { \"id\": \"my image\", \"h\": 512, \"w\": 512, \"e\": 0, \"u\": \"/path/to/images/\", \"p\": \"image.png\" } It works similarly for external images. If you want to store the image at https://example.com/images/image.png , you'd have: { \"id\": \"my image\", \"h\": 512, \"w\": 512, \"e\": 0, \"u\": \"https://example.com/images/\", \"p\": \"image.png\" }","title":"Image"},{"location":"assets/#sound","text":"Similar to Image but for audio files. Attribute Type Description id string Unique identifier used by layers when referencing this asset nm string Human readable name u string Path to the directory containing a file p string Filename or data url e 0-1 integer Whether the file is embedded","title":"Sound"},{"location":"assets/#precomposition","text":"You can think of precompositions as self-contained animation within the main animation file that can be referenced using precomp layers . Within a precomposition you can have precomp layers showing other precompositions, as long as you don't create a dependency cycle. You can find more details in the Precompositions page. Attribute Type Description layers array of Precomposition Layer or Solid Color Layer or Image Layer or Null Layer or Shape Layer or Text Layer or Audio Layer or Camera Layer or Data Layer An array of layers (See: Lists of layers and shapes ) id string Unique identifier used by layers when referencing this asset nm string Human readable name fr number Framerate in frames per second xt 0-1 integer Extra composition Follows a rather extreme example, that uses precompositions inside precompositions to generate a fractal: var lottie_player_0 = new LottiePlayer( 'lottie_target_0', '../examples/fractal.json', true, {} );","title":"Precomposition"},{"location":"assets/#data-source","text":"Points to a JSON file for data. Attribute Type Description id string Unique identifier used by layers when referencing this asset nm string Human readable name u string Path to the directory containing a file p string Filename or data url e 0-1 integer Whether the file is embedded t integer = 3 Type","title":"Data Source"},{"location":"concepts/","text":"General concepts This page describes values and other objects used throughout the lottie format Booleans In some places boolean values are shown as booleans in the JSON ( true / false ). In other places they are shown as integers with 0 or 1 as values. Colors Colors are represented as arrays with values between 0 and 1 for the RGB components. for example: [1, 0, 0] [1, 0.5, 0] Note sometimes you might find color values with 4 components (the 4th being alpha) but most player ignore the last component. Gradients Gradients are represented as a flat array, showing offsets and RGB components. There are two possible representations, with alpha, and without. Gradients without transparency The array is a sequence of offset , red , green , blue components for each color. all values are between 0 and 1 So let's say you want these colors: [0.161, 0.184, 0.459] [0.196, 0.314, 0.69] [0.769, 0.851, 0.961] the array will look like the following: [0, 0.161, 0.184, 0.459, 0.5, 0.196, 0.314, 0.69, 1, 0.769, 0.851, 0.961] Value Description 0 Offset of the 1st color ( 0 means at the start) 0.161 Red component for the 1st color 0.184 Green component for the 1st color 0.459 Blue component for the 1st color 0.5 Offset of the 2nd color ( 0.5 means half way) 0.196 Red component for the 2nd color 0.314 Green component for the 2nd color 0.69 Blue component for the 2nd color 1 Offset of the 3rd color ( 1 means at the end) 0.769 Red component for the 3rd color 0.851 Green component for the 3rd color 0.961 Blue component for the 3rd color Gradients with transparency Alpha is added at the end, repeating offsets and followed by alpha for each colors So assume the same colors as before, but opacity of 80% for the first color and 100% for the other two. The array will look like this: [0, 0.161, 0.184, 0.459, 0.5, 0.196, 0.314, 0.69, 1, 0.769, 0.851, 0.961, 0, 0.8, 0.5, 1, 1, 1] It's the same array as the case without transparency but with the following values added at the end: Value Description 0 Offset of the 1st color ( 0 means at the start) 0.8 Alpha component for the 1st color 0.5 Offset of the 2nd color ( 0.5 means half way) 1 Alpha component for the 2nd color 1 Offset of the 3rd color ( 1 means at the end) 1 Alpha component for the 3rd color Gradient Example Show JSON GradientPreviewEditor.stand_alone(document.getElementById(\"editor_1\"), (lottie) => { var raw_json = JSON.stringify(lottie, undefined, 4); var pretty_json = hljs.highlight(\"json\", raw_json).value; document.getElementById(\"json_viewer_1\").innerHTML = pretty_json; }, ); Lists of layers and shapes Such lists appear Precomposition, Animation, ShapeLayer, and Grop. In such lists, items coming first will be rendered on top So if you have for example: [Ellipse, Rectangle] The ellipse will show on top of the rectangle: var lottie_player_5 = new LottiePlayer( 'lottie_target_5', '../examples/layer_order.json', true, {} ); This means the render order goes from the last element to the first. Animated Property Animated properties have two attributes Attribute Type Description View Schema a 0-1 int Whether the property is animated. Note some old animations might not have this k Value or keyframes, this changes based on the value of a If a is 0 , then k just has the value of the property. If a is 1 , k will be an array of keyframes. Keyframe Attribute Type Description View Schema t number Keyframe time (in frames) s Depends on the property Value, note that scalar values have the value is wrapped in an array i , o Easing Handle h 0-1 int Whether it's a hold frame If h is present and it's 1, you don't need i and o , as the property will keep the same value until the next keyframe. Easing Handles They are objects with x and y attributes, which are numbers within 0 and 1. For multi-dimensional animated properties, these are arrays, with one element per dimension so you can have different easing curves per dimension. They represent a cubic bezier, starting at [0,0] and ending at [1,1] where the value determines the easing function. The x axis represents time, a value of 0 is the time of the current keyframe, a value of 1 is the time of the next keyframe. The y axis represents the value interpolation factor, a value of 0 represents the value at the current keyframe, a value of 1 represents the value at the next keyframe. When you use easing you have two easing handles for the keyframe: o is the \"out\" handle, and is the first one in the bezier, determines the curve as it exits the current keyframe. i is the \"in\" handle, and it's the second one in the bezier, determines the curve as it enters the next keyframe. For linear interpolation you'd have { \"o\": {\"x\": [0, 0], \"y\": [0, 0]}, \"i\": {\"x\": [1, 1], \"y\": [1, 1]} } For easing in and out, you move the x towards the center, this makes the animation more fluid: { \"o\": {\"x\": [0.333, 0.333], \"y\": [0, 0]}, \"i\": {\"x\": [0.667, 0.667], \"y\": [1, 1]} } Old Lottie Keyframes Old lotties have an additional attribute for keyframes, e which works similarly to s but represents the value at the end of the keyframe. They also have a final keyframe with only the t attribute and you need to determine its value based on the s value of the previous keyframe. Easing example In the following example, the ball moves left and right, on the background you can see a representation of its easing function. Show JSON KeyframePreviewEditor.stand_alone(document.getElementById(\"editor_2\"), (lottie) => { var raw_json = JSON.stringify(lottie, undefined, 4); var pretty_json = hljs.highlight(\"json\", raw_json).value; document.getElementById(\"json_viewer_2\").innerHTML = pretty_json; }, ); Animated Position Position properties have additional attributes in their keyframes to represent bezier tangents in the path followed by the animation Also has the attributes from Keyframe . Attribute Type Description ti array of number Tangent for values (eg: moving position around a curved path) to array of number Tangent for values (eg: moving position around a curved path) Transform This represents a layer or shape transform. It has the properties from Visual Object and its own properties are all animated : Attribute Type Name Description View Schema a 2D Vector Anchor point Position (relative to its parent) around which transformations are applied (ie: center for rotation / scale) p 2D Vector Position Position / Translation s 2D Vector Scale Scale factor, 100 for no scaling r number Rotation Rotation in degrees, clockwise sk number Skew Skew amount as an angle in degrees sa number Skew Axis Direction at which skew is applied, in degrees ( 0 skews along the X axis, 90 along the Y axis) o number Opacity Opacity, 100 for fully opaque To make the anchor point properly line up with the center of location, p and a should have the same value. This example allows you to tweak transform attributes and see how the shape changes. The anchor point is highlighted with an orange dot. Anchor X 256 Anchor Y 256 Position X 256 Position Y 256 Scale X 100 Scale Y 100 Rotation 0 Skew 0 Skew Angle 0 Opacity 100 Show JSON var lottie_player_3 = new PlaygroundPlayer( 3, 'playground_3_11', 'lottie_target_3', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{a3bb98c7-d0dd-4484-b6da-74a0e70eaf2f}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 2, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Anchor\", \"mn\": \"{04f9b742-3603-49fa-9552-ea04de1a3f33}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{4251e46a-bb13-464b-913c-e67c44a218da}\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{7d3070ed-88a3-41aa-a62e-7db8df1bd312}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.9411764705882353, 0.11372549019607843, 0.0392156862745098]}, \"r\": 1}]}, {\"ddd\": 0, \"ty\": 4, \"ind\": 1, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Transformed\", \"mn\": \"{d00298c4-66b4-4ae4-a730-22c1eb85c188}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}, \"sk\": {\"a\": 0, \"k\": 0}, \"sa\": {\"a\": 0, \"k\": 0}}, \"shapes\": [{\"ty\": \"rc\", \"nm\": \"Rectangle 1\", \"mn\": \"{bf8ad877-113b-4df8-a2e2-3bb4af32edf7}\", \"p\": {\"a\": 0, \"k\": [252.75223880597017, 250.60298507462684]}, \"s\": {\"a\": 0, \"k\": [319.8089552238806, 330.98507462686564]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"nm\": \"Fill 1\", \"mn\": \"{b9040dc8-0753-4a6e-b5f1-d508d17bbd4f}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}, \"r\": 1}]}, {\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Reference\", \"mn\": \"{8f351be7-8a51-4310-9dc3-59ed21594815}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"mn\": \"{cb4f7b74-bed1-493b-a0e6-01b00566aedd}\", \"p\": {\"a\": 0, \"k\": [252.75223880597017, 250.60298507462684]}, \"s\": {\"a\": 0, \"k\": [319.8089552238806, 330.98507462686564]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{05064670-7e14-4141-89c1-e0f0f3a1c57d}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.1607843137254902, 0.1843137254901961, 0.4588235294117647]}, \"r\": 1}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { lottie.layers[0].ks.p.k[0] = data[\"Anchor X\"]; lottie.layers[1].ks.a.k[0] = data[\"Anchor X\"]; lottie.layers[0].ks.p.k[1] = data[\"Anchor Y\"]; lottie.layers[1].ks.a.k[1] = data[\"Anchor Y\"]; lottie.layers[1].ks.p.k[0] = data[\"Position X\"]; lottie.layers[1].ks.p.k[1] = data[\"Position Y\"]; lottie.layers[1].ks.s.k[0] = data[\"Scale X\"]; lottie.layers[1].ks.s.k[1] = data[\"Scale Y\"]; lottie.layers[1].ks.r.k = data[\"Rotation\"]; lottie.layers[1].ks.sk.k = data[\"Skew\"]; lottie.layers[1].ks.sa.k = data[\"Skew Angle\"]; lottie.layers[1].ks.o.k = data[\"Opacity\"];this.json_viewer_contents = lottie.layers[1].ks; }, {} ); Split vector Sometimes p might be split into separate components animated independently and have the following structure Attribute Type Description s boolean = True Split x Animated number X y Animated number Y z Animated number Z Bezier This represents a cubic bezier path. Note that for interpolation to work correctly all bezier values in a property's keyframe must have the same number of points. Attribute Type Name Description View Schema c 0-1 int Closed Whether the bezier forms a closed loop v array of 2D Vector Vertices Points along the curve i array of 2D Vector In Tangents Cubic control points, incoming tangent o array of 2D Vector Out Tangents Cubic control points, outgoing tangent i and o are relative to v . The n th bezier segment is defined as: v[n], v[n]+o[n], v[n+1]+i[n+1], v[n+1] If the bezier is closed, you need an extra segment going from the last point to the first, still following i and o appropriately. If you want linear bezier, you can have i and o for a segment to be [0, 0] . If you want it quadratic, set them to 2/3rd of what the quadratic control point would be. If you want a point to be smooth you need to make sure that i = -o . Show JSON BezierPreviewEditor.stand_alone(document.getElementById(\"editor_4\"), (lottie) => { var raw_json = JSON.stringify(lottie, undefined, 4); var pretty_json = hljs.highlight(\"json\", raw_json).value; document.getElementById(\"json_viewer_4\").innerHTML = pretty_json; }, );","title":"General concepts"},{"location":"concepts/#general-concepts","text":"This page describes values and other objects used throughout the lottie format","title":"General concepts"},{"location":"concepts/#booleans","text":"In some places boolean values are shown as booleans in the JSON ( true / false ). In other places they are shown as integers with 0 or 1 as values.","title":"Booleans"},{"location":"concepts/#colors","text":"Colors are represented as arrays with values between 0 and 1 for the RGB components. for example: [1, 0, 0] [1, 0.5, 0] Note sometimes you might find color values with 4 components (the 4th being alpha) but most player ignore the last component.","title":"Colors"},{"location":"concepts/#gradients","text":"Gradients are represented as a flat array, showing offsets and RGB components. There are two possible representations, with alpha, and without.","title":"Gradients"},{"location":"concepts/#gradients-without-transparency","text":"The array is a sequence of offset , red , green , blue components for each color. all values are between 0 and 1 So let's say you want these colors: [0.161, 0.184, 0.459] [0.196, 0.314, 0.69] [0.769, 0.851, 0.961] the array will look like the following: [0, 0.161, 0.184, 0.459, 0.5, 0.196, 0.314, 0.69, 1, 0.769, 0.851, 0.961] Value Description 0 Offset of the 1st color ( 0 means at the start) 0.161 Red component for the 1st color 0.184 Green component for the 1st color 0.459 Blue component for the 1st color 0.5 Offset of the 2nd color ( 0.5 means half way) 0.196 Red component for the 2nd color 0.314 Green component for the 2nd color 0.69 Blue component for the 2nd color 1 Offset of the 3rd color ( 1 means at the end) 0.769 Red component for the 3rd color 0.851 Green component for the 3rd color 0.961 Blue component for the 3rd color","title":"Gradients without transparency"},{"location":"concepts/#gradients-with-transparency","text":"Alpha is added at the end, repeating offsets and followed by alpha for each colors So assume the same colors as before, but opacity of 80% for the first color and 100% for the other two. The array will look like this: [0, 0.161, 0.184, 0.459, 0.5, 0.196, 0.314, 0.69, 1, 0.769, 0.851, 0.961, 0, 0.8, 0.5, 1, 1, 1] It's the same array as the case without transparency but with the following values added at the end: Value Description 0 Offset of the 1st color ( 0 means at the start) 0.8 Alpha component for the 1st color 0.5 Offset of the 2nd color ( 0.5 means half way) 1 Alpha component for the 2nd color 1 Offset of the 3rd color ( 1 means at the end) 1 Alpha component for the 3rd color","title":"Gradients with transparency"},{"location":"concepts/#gradient-example","text":"Show JSON GradientPreviewEditor.stand_alone(document.getElementById(\"editor_1\"), (lottie) => { var raw_json = JSON.stringify(lottie, undefined, 4); var pretty_json = hljs.highlight(\"json\", raw_json).value; document.getElementById(\"json_viewer_1\").innerHTML = pretty_json; }, );","title":"Gradient Example"},{"location":"concepts/#lists-of-layers-and-shapes","text":"Such lists appear Precomposition, Animation, ShapeLayer, and Grop. In such lists, items coming first will be rendered on top So if you have for example: [Ellipse, Rectangle] The ellipse will show on top of the rectangle: var lottie_player_5 = new LottiePlayer( 'lottie_target_5', '../examples/layer_order.json', true, {} ); This means the render order goes from the last element to the first.","title":"Lists of layers and shapes"},{"location":"concepts/#animated-property","text":"Animated properties have two attributes Attribute Type Description View Schema a 0-1 int Whether the property is animated. Note some old animations might not have this k Value or keyframes, this changes based on the value of a If a is 0 , then k just has the value of the property. If a is 1 , k will be an array of keyframes.","title":"Animated Property"},{"location":"concepts/#keyframe","text":"Attribute Type Description View Schema t number Keyframe time (in frames) s Depends on the property Value, note that scalar values have the value is wrapped in an array i , o Easing Handle h 0-1 int Whether it's a hold frame If h is present and it's 1, you don't need i and o , as the property will keep the same value until the next keyframe.","title":"Keyframe"},{"location":"concepts/#easing-handles","text":"They are objects with x and y attributes, which are numbers within 0 and 1. For multi-dimensional animated properties, these are arrays, with one element per dimension so you can have different easing curves per dimension. They represent a cubic bezier, starting at [0,0] and ending at [1,1] where the value determines the easing function. The x axis represents time, a value of 0 is the time of the current keyframe, a value of 1 is the time of the next keyframe. The y axis represents the value interpolation factor, a value of 0 represents the value at the current keyframe, a value of 1 represents the value at the next keyframe. When you use easing you have two easing handles for the keyframe: o is the \"out\" handle, and is the first one in the bezier, determines the curve as it exits the current keyframe. i is the \"in\" handle, and it's the second one in the bezier, determines the curve as it enters the next keyframe. For linear interpolation you'd have { \"o\": {\"x\": [0, 0], \"y\": [0, 0]}, \"i\": {\"x\": [1, 1], \"y\": [1, 1]} } For easing in and out, you move the x towards the center, this makes the animation more fluid: { \"o\": {\"x\": [0.333, 0.333], \"y\": [0, 0]}, \"i\": {\"x\": [0.667, 0.667], \"y\": [1, 1]} }","title":"Easing Handles"},{"location":"concepts/#old-lottie-keyframes","text":"Old lotties have an additional attribute for keyframes, e which works similarly to s but represents the value at the end of the keyframe. They also have a final keyframe with only the t attribute and you need to determine its value based on the s value of the previous keyframe.","title":"Old Lottie Keyframes"},{"location":"concepts/#easing-example","text":"In the following example, the ball moves left and right, on the background you can see a representation of its easing function. Show JSON KeyframePreviewEditor.stand_alone(document.getElementById(\"editor_2\"), (lottie) => { var raw_json = JSON.stringify(lottie, undefined, 4); var pretty_json = hljs.highlight(\"json\", raw_json).value; document.getElementById(\"json_viewer_2\").innerHTML = pretty_json; }, );","title":"Easing example"},{"location":"concepts/#animated-position","text":"Position properties have additional attributes in their keyframes to represent bezier tangents in the path followed by the animation Also has the attributes from Keyframe . Attribute Type Description ti array of number Tangent for values (eg: moving position around a curved path) to array of number Tangent for values (eg: moving position around a curved path)","title":"Animated Position"},{"location":"concepts/#transform","text":"This represents a layer or shape transform. It has the properties from Visual Object and its own properties are all animated : Attribute Type Name Description View Schema a 2D Vector Anchor point Position (relative to its parent) around which transformations are applied (ie: center for rotation / scale) p 2D Vector Position Position / Translation s 2D Vector Scale Scale factor, 100 for no scaling r number Rotation Rotation in degrees, clockwise sk number Skew Skew amount as an angle in degrees sa number Skew Axis Direction at which skew is applied, in degrees ( 0 skews along the X axis, 90 along the Y axis) o number Opacity Opacity, 100 for fully opaque To make the anchor point properly line up with the center of location, p and a should have the same value. This example allows you to tweak transform attributes and see how the shape changes. The anchor point is highlighted with an orange dot. Anchor X 256 Anchor Y 256 Position X 256 Position Y 256 Scale X 100 Scale Y 100 Rotation 0 Skew 0 Skew Angle 0 Opacity 100 Show JSON var lottie_player_3 = new PlaygroundPlayer( 3, 'playground_3_11', 'lottie_target_3', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{a3bb98c7-d0dd-4484-b6da-74a0e70eaf2f}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 2, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Anchor\", \"mn\": \"{04f9b742-3603-49fa-9552-ea04de1a3f33}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{4251e46a-bb13-464b-913c-e67c44a218da}\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{7d3070ed-88a3-41aa-a62e-7db8df1bd312}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.9411764705882353, 0.11372549019607843, 0.0392156862745098]}, \"r\": 1}]}, {\"ddd\": 0, \"ty\": 4, \"ind\": 1, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Transformed\", \"mn\": \"{d00298c4-66b4-4ae4-a730-22c1eb85c188}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}, \"sk\": {\"a\": 0, \"k\": 0}, \"sa\": {\"a\": 0, \"k\": 0}}, \"shapes\": [{\"ty\": \"rc\", \"nm\": \"Rectangle 1\", \"mn\": \"{bf8ad877-113b-4df8-a2e2-3bb4af32edf7}\", \"p\": {\"a\": 0, \"k\": [252.75223880597017, 250.60298507462684]}, \"s\": {\"a\": 0, \"k\": [319.8089552238806, 330.98507462686564]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"nm\": \"Fill 1\", \"mn\": \"{b9040dc8-0753-4a6e-b5f1-d508d17bbd4f}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}, \"r\": 1}]}, {\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Reference\", \"mn\": \"{8f351be7-8a51-4310-9dc3-59ed21594815}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"mn\": \"{cb4f7b74-bed1-493b-a0e6-01b00566aedd}\", \"p\": {\"a\": 0, \"k\": [252.75223880597017, 250.60298507462684]}, \"s\": {\"a\": 0, \"k\": [319.8089552238806, 330.98507462686564]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{05064670-7e14-4141-89c1-e0f0f3a1c57d}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.1607843137254902, 0.1843137254901961, 0.4588235294117647]}, \"r\": 1}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { lottie.layers[0].ks.p.k[0] = data[\"Anchor X\"]; lottie.layers[1].ks.a.k[0] = data[\"Anchor X\"]; lottie.layers[0].ks.p.k[1] = data[\"Anchor Y\"]; lottie.layers[1].ks.a.k[1] = data[\"Anchor Y\"]; lottie.layers[1].ks.p.k[0] = data[\"Position X\"]; lottie.layers[1].ks.p.k[1] = data[\"Position Y\"]; lottie.layers[1].ks.s.k[0] = data[\"Scale X\"]; lottie.layers[1].ks.s.k[1] = data[\"Scale Y\"]; lottie.layers[1].ks.r.k = data[\"Rotation\"]; lottie.layers[1].ks.sk.k = data[\"Skew\"]; lottie.layers[1].ks.sa.k = data[\"Skew Angle\"]; lottie.layers[1].ks.o.k = data[\"Opacity\"];this.json_viewer_contents = lottie.layers[1].ks; }, {} );","title":"Transform"},{"location":"concepts/#split-vector","text":"Sometimes p might be split into separate components animated independently and have the following structure Attribute Type Description s boolean = True Split x Animated number X y Animated number Y z Animated number Z","title":"Split vector"},{"location":"concepts/#bezier","text":"This represents a cubic bezier path. Note that for interpolation to work correctly all bezier values in a property's keyframe must have the same number of points. Attribute Type Name Description View Schema c 0-1 int Closed Whether the bezier forms a closed loop v array of 2D Vector Vertices Points along the curve i array of 2D Vector In Tangents Cubic control points, incoming tangent o array of 2D Vector Out Tangents Cubic control points, outgoing tangent i and o are relative to v . The n th bezier segment is defined as: v[n], v[n]+o[n], v[n+1]+i[n+1], v[n+1] If the bezier is closed, you need an extra segment going from the last point to the first, still following i and o appropriately. If you want linear bezier, you can have i and o for a segment to be [0, 0] . If you want it quadratic, set them to 2/3rd of what the quadratic control point would be. If you want a point to be smooth you need to make sure that i = -o . Show JSON BezierPreviewEditor.stand_alone(document.getElementById(\"editor_4\"), (lottie) => { var raw_json = JSON.stringify(lottie, undefined, 4); var pretty_json = hljs.highlight(\"json\", raw_json).value; document.getElementById(\"json_viewer_4\").innerHTML = pretty_json; }, );","title":"Bezier"},{"location":"constants/","text":"Enumerations Blend Mode Layer and shape blend mode Value Name View Schema 0 Normal 1 Multiply 2 Screen 3 Overlay 4 Darken 5 Lighten 6 Color Dodge 7 Color Burn 8 Hard Light 9 Soft Light 10 Difference 11 Exclusion 12 Hue 13 Saturation 14 Color 15 Luminosity 16 Add 17 Hard Mix In the following example you can change the blend mode of the top layer Blend Mode Normal Multiply Screen Overlay Darken Lighten Color Dodge Color Burn Hard Light Soft Light Difference Exclusion Hue Saturation Color Luminosity Add Hard Mix Opacity 50 var lottie_player_6 = new PlaygroundPlayer( 6, 'None', 'lottie_target_6', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{429ff333-f31c-4124-91c5-5e861412a004}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 1, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{625eab7e-4758-4d4b-b37c-d89115b1442b}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 50}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Ellipse\", \"mn\": \"{dd57d763-ff3b-420f-a94d-eb5503e7faa7}\", \"it\": [{\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{fa5c495c-00d1-4253-b30c-cc8cb1b855b2}\", \"p\": {\"a\": 0, \"k\": [400.1910447761194, 240.71641791044777]}, \"s\": {\"a\": 0, \"k\": [195.15223880597017, 180.53731343283584]}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{89437b5f-dca9-42d4-aff9-c57ce08c8c1e}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{352559ca-ebe9-4b11-acdd-09e155612598}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.3411764705882353, 0.01568627450980392]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [400.1910447761194, 240.71641791044777]}, \"p\": {\"a\": 0, \"k\": [400.1910447761194, 240.71641791044777]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{b6000853-a4d3-4b13-acdd-2e4f1a192760}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{d647a149-8105-4e08-b395-c8de40669fb0}\", \"p\": {\"a\": 0, \"k\": [110.90149253731343, 216.644776119403]}, \"or\": {\"a\": 0, \"k\": 121.5619125366211}, \"ir\": {\"a\": 0, \"k\": 60.78095626831055}, \"r\": {\"a\": 0, \"k\": 143.04905700683594}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{67a87e2b-afff-4f55-9004-4cc274cefe07}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{39b8d13c-45cf-4ad7-972a-ef5169f1ffbf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [110.90149253731343, 216.644776119403]}, \"p\": {\"a\": 0, \"k\": [159.9044776119403, 247.59402985074627]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}, {\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer 1\", \"mn\": \"{d74c9dcc-e7af-45c3-9eab-554c7b93f6b6}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Rectangle 1\", \"mn\": \"{b22ddad1-738b-471a-86eb-1f072fa45799}\", \"it\": [{\"ty\": \"rc\", \"nm\": \"Rectangle 1\", \"mn\": \"{0c09bd21-59ab-4f1e-bd3d-547613eb3e2a}\", \"p\": {\"a\": 0, \"k\": [241.57611940298506, 357.6358208955224]}, \"s\": {\"a\": 0, \"k\": [383.4268656716418, 211.4865671641791]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{8cd4fca9-3480-49fa-947f-04bc40ed74f5}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{050089d8-44c4-4312-8e23-3c89df7615aa}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.7686274509803922, 0.8509803921568627, 0.9607843137254902]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [241.57611940298506, 357.6358208955224]}, \"p\": {\"a\": 0, \"k\": [226.1014925373134, 131.53432835820894]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"gr\", \"nm\": \"Rectangle\", \"mn\": \"{700bfca8-0e45-42e9-8559-15ac0ebe93b2}\", \"it\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"mn\": \"{0e3ac2ac-22c8-4310-8208-f5d5ba9cd6d9}\", \"p\": {\"a\": 0, \"k\": [277.68358208955226, 148.2985074626866]}, \"s\": {\"a\": 0, \"k\": [335.2835820895522, 162.48358208955224]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{af0c691f-7815-414e-a988-ac2eb6e32128}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{059d8c4e-de02-4fa7-99fe-c069b73218be}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [277.68358208955226, 148.2985074626866]}, \"p\": {\"a\": 0, \"k\": [277.68358208955226, 366.6626865671642]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { lottie.layers[0].bm = Number(data[\"Blend Mode\"]); lottie.layers[0].ks.o.k = data[\"Opacity\"]; }, {} ); Composite How to stack copies in a repeater Value Name View Schema 1 Above 2 Below Fill Rule Rule used to handle multiple shapes rendered with the same fill object Value Name Description View Schema 1 Non Zero Everything is colored (You can think of this as an OR) 2 Even Odd Colored based on intersections and path direction, can be used to create \"holes\" Font Path Origin Value Name View Schema 0 Local 1 Css Url 2 Script Url 3 Font Url Gradient Type Type of a gradient Value Name View Schema 1 Linear 2 Radial Line Cap Style at the end of a stoked line Value Name View Schema 1 Butt 2 Round 3 Square Line Join Style at a sharp corner of a stoked line Value Name View Schema 1 Miter 2 Round 3 Bevel Mask Mode How masks interact with each other. See https://helpx.adobe.com/after-effects/using/alpha-channels-masks-mattes.html Value Name View Schema 'n' None 'a' Add 's' Subtract 'i' Intersect 'l' Lighten 'd' Darken 'f' Difference Matte Mode How a layer should mask another layer Value Name View Schema 0 Normal 1 Alpha 2 Inverted Alpha 3 Luma 4 Inverted Luma Matte Mode Normal Alpha Inverted Alpha Luma Inverted Luma var lottie_player_7 = new PlaygroundPlayer( 7, 'None', 'lottie_target_7', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{b3d1b083-9de7-4537-a691-fc9aa42f9742}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 1, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Ellipse (Mask)\", \"ks\": {\"a\": {\"a\": 0, \"k\": [153, 294]}, \"p\": {\"a\": 0, \"k\": [346, 211]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{261eddeb-af92-4be1-932c-790b00c23933}\", \"p\": {\"a\": 0, \"k\": [137.0955223880597, 293.60820895522386]}, \"s\": {\"a\": 0, \"k\": [303.42089552238804, 315.55074626865667]}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{aa9c282c-253d-4d8d-ab05-4819c592fa85}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 1, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 6}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{2b2b0002-ff0c-4978-a33b-db4e0498848d}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.9411764705882353, 0.11372549019607843, 0.0392156862745098]}, \"r\": 1}], \"td\": 1}, {\"ddd\": 0, \"ty\": 4, \"ind\": 2, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Shapes (Masked)\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{528994b7-40ff-4d12-81f8-603f274da12e}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{ce8756d7-289f-4f84-a135-d225d57c42e0}\", \"p\": {\"a\": 0, \"k\": [427.2716417910448, 194.29253731343283]}, \"or\": {\"a\": 0, \"k\": 216.4160919189453}, \"ir\": {\"a\": 0, \"k\": 87.03440856933594}, \"r\": {\"a\": 0, \"k\": 261.54803466796875}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{efd05a25-a43b-451d-83d2-53a477087223}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5019607843137255, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{523ca39c-9e57-4547-bf0e-ba7496003579}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [427.2716417910448, 194.29253731343283]}, \"p\": {\"a\": 0, \"k\": [338.7223880597015, 209.76716417910447]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"gr\", \"nm\": \"Rectangle\", \"mn\": \"{d2d7a5d5-6d91-42e8-b40a-af52a112fe38}\", \"it\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"mn\": \"{9ef8604e-7891-4909-a655-445131b4d842}\", \"p\": {\"a\": 0, \"k\": [209.17611940298502, 226.8]}, \"s\": {\"a\": 0, \"k\": [363.3313432835821, 369.3492537313433]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{444584d2-cb59-4cba-83a1-82cc605837fd}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5019607843137255, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{f75aed67-9b0e-41a9-b859-a14b5b0a320d}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.7686274509803922, 0.8509803921568627, 0.9607843137254902]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [256.1910447761194, 273.8149253731343]}, \"p\": {\"a\": 0, \"k\": [256.1910447761194, 273.8149253731343]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}], \"tt\": 1, \"tp\": 1}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { lottie.layers[1].tt = Number(data[\"Matte Mode\"]); }, {} ); Merge Mode Boolean operation on shapes Value Name View Schema 1 Normal 2 Add 3 Subtract 4 Intersect 5 Exclude Intersections Shape Direction Drawing direction of the shape curve, useful for trim path Value Name Description View Schema 1 Normal Usually clockwise 3 Reversed Usually counter clockwise Star Type Star or Polygon Value Name View Schema 1 Star 2 Polygon Stroke Dash Type Type of a dash item in a stroked line Value Name View Schema 'd' Dash 'g' Gap 'o' Offset Text Based Value Name View Schema 1 Characters 2 Character Excluding Spaces 3 Words 4 Lines Text Grouping Value Name View Schema 1 Characters 2 Word 3 Line 4 All Text Justify Text alignment / justification Value Name View Schema 0 Left 1 Right 2 Center 3 Justify with Last Line Left 4 Justify with Last Line Right 5 Justify with Last Line Center 6 Justify with Last Line Full Text Shape Defines the function used to determine the interpolating factor on a text range selector. Value Name View Schema 1 Square 2 Ramp Up 3 Ramp Down 4 Triangle 5 Round 6 Smooth To better illustrate what the value mean, the graphics below shows an example for each value, including the function itself, based on the range start and end character. Trim Multiple Shapes How to handle multiple shapes in trim path Value Name View Schema 1 Simultaneously 2 Individually Text Caps Value Name View Schema 0 Regular 1 All Caps 2 Small Caps Text Range Units Unit type for a text selector Value Name View Schema 1 Percent 2 Index","title":"Enumerations"},{"location":"constants/#enumerations","text":"","title":"Enumerations"},{"location":"constants/#blend-mode","text":"Layer and shape blend mode Value Name View Schema 0 Normal 1 Multiply 2 Screen 3 Overlay 4 Darken 5 Lighten 6 Color Dodge 7 Color Burn 8 Hard Light 9 Soft Light 10 Difference 11 Exclusion 12 Hue 13 Saturation 14 Color 15 Luminosity 16 Add 17 Hard Mix In the following example you can change the blend mode of the top layer Blend Mode Normal Multiply Screen Overlay Darken Lighten Color Dodge Color Burn Hard Light Soft Light Difference Exclusion Hue Saturation Color Luminosity Add Hard Mix Opacity 50 var lottie_player_6 = new PlaygroundPlayer( 6, 'None', 'lottie_target_6', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{429ff333-f31c-4124-91c5-5e861412a004}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 1, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{625eab7e-4758-4d4b-b37c-d89115b1442b}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 50}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Ellipse\", \"mn\": \"{dd57d763-ff3b-420f-a94d-eb5503e7faa7}\", \"it\": [{\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{fa5c495c-00d1-4253-b30c-cc8cb1b855b2}\", \"p\": {\"a\": 0, \"k\": [400.1910447761194, 240.71641791044777]}, \"s\": {\"a\": 0, \"k\": [195.15223880597017, 180.53731343283584]}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{89437b5f-dca9-42d4-aff9-c57ce08c8c1e}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{352559ca-ebe9-4b11-acdd-09e155612598}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.3411764705882353, 0.01568627450980392]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [400.1910447761194, 240.71641791044777]}, \"p\": {\"a\": 0, \"k\": [400.1910447761194, 240.71641791044777]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{b6000853-a4d3-4b13-acdd-2e4f1a192760}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{d647a149-8105-4e08-b395-c8de40669fb0}\", \"p\": {\"a\": 0, \"k\": [110.90149253731343, 216.644776119403]}, \"or\": {\"a\": 0, \"k\": 121.5619125366211}, \"ir\": {\"a\": 0, \"k\": 60.78095626831055}, \"r\": {\"a\": 0, \"k\": 143.04905700683594}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{67a87e2b-afff-4f55-9004-4cc274cefe07}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{39b8d13c-45cf-4ad7-972a-ef5169f1ffbf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [110.90149253731343, 216.644776119403]}, \"p\": {\"a\": 0, \"k\": [159.9044776119403, 247.59402985074627]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}, {\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer 1\", \"mn\": \"{d74c9dcc-e7af-45c3-9eab-554c7b93f6b6}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Rectangle 1\", \"mn\": \"{b22ddad1-738b-471a-86eb-1f072fa45799}\", \"it\": [{\"ty\": \"rc\", \"nm\": \"Rectangle 1\", \"mn\": \"{0c09bd21-59ab-4f1e-bd3d-547613eb3e2a}\", \"p\": {\"a\": 0, \"k\": [241.57611940298506, 357.6358208955224]}, \"s\": {\"a\": 0, \"k\": [383.4268656716418, 211.4865671641791]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{8cd4fca9-3480-49fa-947f-04bc40ed74f5}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{050089d8-44c4-4312-8e23-3c89df7615aa}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.7686274509803922, 0.8509803921568627, 0.9607843137254902]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [241.57611940298506, 357.6358208955224]}, \"p\": {\"a\": 0, \"k\": [226.1014925373134, 131.53432835820894]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"gr\", \"nm\": \"Rectangle\", \"mn\": \"{700bfca8-0e45-42e9-8559-15ac0ebe93b2}\", \"it\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"mn\": \"{0e3ac2ac-22c8-4310-8208-f5d5ba9cd6d9}\", \"p\": {\"a\": 0, \"k\": [277.68358208955226, 148.2985074626866]}, \"s\": {\"a\": 0, \"k\": [335.2835820895522, 162.48358208955224]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{af0c691f-7815-414e-a988-ac2eb6e32128}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{059d8c4e-de02-4fa7-99fe-c069b73218be}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [277.68358208955226, 148.2985074626866]}, \"p\": {\"a\": 0, \"k\": [277.68358208955226, 366.6626865671642]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { lottie.layers[0].bm = Number(data[\"Blend Mode\"]); lottie.layers[0].ks.o.k = data[\"Opacity\"]; }, {} );","title":"Blend Mode"},{"location":"constants/#composite","text":"How to stack copies in a repeater Value Name View Schema 1 Above 2 Below","title":"Composite"},{"location":"constants/#fill-rule","text":"Rule used to handle multiple shapes rendered with the same fill object Value Name Description View Schema 1 Non Zero Everything is colored (You can think of this as an OR) 2 Even Odd Colored based on intersections and path direction, can be used to create \"holes\"","title":"Fill Rule"},{"location":"constants/#font-path-origin","text":"Value Name View Schema 0 Local 1 Css Url 2 Script Url 3 Font Url","title":"Font Path Origin"},{"location":"constants/#gradient-type","text":"Type of a gradient Value Name View Schema 1 Linear 2 Radial","title":"Gradient Type"},{"location":"constants/#line-cap","text":"Style at the end of a stoked line Value Name View Schema 1 Butt 2 Round 3 Square","title":"Line Cap"},{"location":"constants/#line-join","text":"Style at a sharp corner of a stoked line Value Name View Schema 1 Miter 2 Round 3 Bevel","title":"Line Join"},{"location":"constants/#mask-mode","text":"How masks interact with each other. See https://helpx.adobe.com/after-effects/using/alpha-channels-masks-mattes.html Value Name View Schema 'n' None 'a' Add 's' Subtract 'i' Intersect 'l' Lighten 'd' Darken 'f' Difference","title":"Mask Mode"},{"location":"constants/#matte-mode","text":"How a layer should mask another layer Value Name View Schema 0 Normal 1 Alpha 2 Inverted Alpha 3 Luma 4 Inverted Luma Matte Mode Normal Alpha Inverted Alpha Luma Inverted Luma var lottie_player_7 = new PlaygroundPlayer( 7, 'None', 'lottie_target_7', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{b3d1b083-9de7-4537-a691-fc9aa42f9742}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 1, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Ellipse (Mask)\", \"ks\": {\"a\": {\"a\": 0, \"k\": [153, 294]}, \"p\": {\"a\": 0, \"k\": [346, 211]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{261eddeb-af92-4be1-932c-790b00c23933}\", \"p\": {\"a\": 0, \"k\": [137.0955223880597, 293.60820895522386]}, \"s\": {\"a\": 0, \"k\": [303.42089552238804, 315.55074626865667]}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{aa9c282c-253d-4d8d-ab05-4819c592fa85}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 1, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 6}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{2b2b0002-ff0c-4978-a33b-db4e0498848d}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.9411764705882353, 0.11372549019607843, 0.0392156862745098]}, \"r\": 1}], \"td\": 1}, {\"ddd\": 0, \"ty\": 4, \"ind\": 2, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Shapes (Masked)\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{528994b7-40ff-4d12-81f8-603f274da12e}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{ce8756d7-289f-4f84-a135-d225d57c42e0}\", \"p\": {\"a\": 0, \"k\": [427.2716417910448, 194.29253731343283]}, \"or\": {\"a\": 0, \"k\": 216.4160919189453}, \"ir\": {\"a\": 0, \"k\": 87.03440856933594}, \"r\": {\"a\": 0, \"k\": 261.54803466796875}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{efd05a25-a43b-451d-83d2-53a477087223}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5019607843137255, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{523ca39c-9e57-4547-bf0e-ba7496003579}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [427.2716417910448, 194.29253731343283]}, \"p\": {\"a\": 0, \"k\": [338.7223880597015, 209.76716417910447]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"gr\", \"nm\": \"Rectangle\", \"mn\": \"{d2d7a5d5-6d91-42e8-b40a-af52a112fe38}\", \"it\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"mn\": \"{9ef8604e-7891-4909-a655-445131b4d842}\", \"p\": {\"a\": 0, \"k\": [209.17611940298502, 226.8]}, \"s\": {\"a\": 0, \"k\": [363.3313432835821, 369.3492537313433]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{444584d2-cb59-4cba-83a1-82cc605837fd}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5019607843137255, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{f75aed67-9b0e-41a9-b859-a14b5b0a320d}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.7686274509803922, 0.8509803921568627, 0.9607843137254902]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [256.1910447761194, 273.8149253731343]}, \"p\": {\"a\": 0, \"k\": [256.1910447761194, 273.8149253731343]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}], \"tt\": 1, \"tp\": 1}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { lottie.layers[1].tt = Number(data[\"Matte Mode\"]); }, {} );","title":"Matte Mode"},{"location":"constants/#merge-mode","text":"Boolean operation on shapes Value Name View Schema 1 Normal 2 Add 3 Subtract 4 Intersect 5 Exclude Intersections","title":"Merge Mode"},{"location":"constants/#shape-direction","text":"Drawing direction of the shape curve, useful for trim path Value Name Description View Schema 1 Normal Usually clockwise 3 Reversed Usually counter clockwise","title":"Shape Direction"},{"location":"constants/#star-type","text":"Star or Polygon Value Name View Schema 1 Star 2 Polygon","title":"Star Type"},{"location":"constants/#stroke-dash-type","text":"Type of a dash item in a stroked line Value Name View Schema 'd' Dash 'g' Gap 'o' Offset","title":"Stroke Dash Type"},{"location":"constants/#text-based","text":"Value Name View Schema 1 Characters 2 Character Excluding Spaces 3 Words 4 Lines","title":"Text Based"},{"location":"constants/#text-grouping","text":"Value Name View Schema 1 Characters 2 Word 3 Line 4 All","title":"Text Grouping"},{"location":"constants/#text-justify","text":"Text alignment / justification Value Name View Schema 0 Left 1 Right 2 Center 3 Justify with Last Line Left 4 Justify with Last Line Right 5 Justify with Last Line Center 6 Justify with Last Line Full","title":"Text Justify"},{"location":"constants/#text-shape","text":"Defines the function used to determine the interpolating factor on a text range selector. Value Name View Schema 1 Square 2 Ramp Up 3 Ramp Down 4 Triangle 5 Round 6 Smooth To better illustrate what the value mean, the graphics below shows an example for each value, including the function itself, based on the range start and end character.","title":"Text Shape"},{"location":"constants/#trim-multiple-shapes","text":"How to handle multiple shapes in trim path Value Name View Schema 1 Simultaneously 2 Individually","title":"Trim Multiple Shapes"},{"location":"constants/#text-caps","text":"Value Name View Schema 0 Regular 1 All Caps 2 Small Caps","title":"Text Caps"},{"location":"constants/#text-range-units","text":"Unit type for a text selector Value Name View Schema 1 Percent 2 Index","title":"Text Range Units"},{"location":"effects/","text":"Layer Effects Layers can have post-processing effects applied to them. Effects Attribute Type Description nm string Name, as seen from editors and the like mn string Match name, used in expressions ef array of Effect No Value or Effect Value Angle or Effect Value Checkbox or Effect Value Color or Effect Value Drop Down or Ignored Value or Effect Value Layer or Effect Value Point or Effect Value Slider Array of effect values . Each effect below shows a table with the values it expects. np integer Number of values in ef ix integer Effect Index ty integer Effect type en 0-1 integer Enabled Many effects have unused values which are labeled with a number. Effect types: ty Effect Type 5 Misc Effect 20 Tint 21 Fill 22 Stroke 23 Tritone 24 Pro Levels 25 Drop Shadow 26 Radial Wipe 27 Displacement Map 28 Matte3 29 Gaussian Blur 30 Twirl 31 Mesh Warp 32 Wavy 33 Spherize 34 Puppet All the examples will use this as their base: var lottie_player_15 = new LottiePlayer( 'lottie_target_15', '../examples/image.json', true, {} ); Fill Effect Fill all opaque areas with a solid color Attribute Type Description ty integer = 21 Type ef array Effect values Name Type 00 Effect Value Point 01 Effect Value Drop Down color Effect Value Color 03 Effect Value Drop Down 04 Effect Value Slider 05 Effect Value Slider opacity Effect Value Slider Opacity 1 Color Red 1 Green 0.9 Blue 0 Show JSON var lottie_player_8 = new PlaygroundPlayer( 8, 'playground_8_5', 'lottie_target_8', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 21, \"ef\": [{\"ty\": 3, \"v\": {\"k\": [0, 0], \"a\": 0}}, {\"ty\": 7, \"v\": {\"k\": 0, \"a\": 0}}, {\"ty\": 2, \"v\": {\"k\": [1, 0.9, 0, 1], \"a\": 0}}, {\"ty\": 2, \"v\": {\"k\": [0, 0, 0, 1], \"a\": 0}}, {\"ty\": 7, \"v\": {\"k\": 0, \"a\": 0}}, {\"ty\": 0, \"v\": {\"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"a\": 0, \"k\": 0}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ef[0].ef[6].v.k = data[\"Opacity\"]; lottie.layers[0].ef[0].ef[2].v.k[0] = data[\"Red\"]; lottie.layers[0].ef[0].ef[2].v.k[1] = data[\"Green\"]; lottie.layers[0].ef[0].ef[2].v.k[2] = data[\"Blue\"];this.json_viewer_contents = lottie.layers[0].ef[0]; }, {} ); Stroke Effect Attribute Type Description ty integer = 22 Type ef array Effect values Name Type 00 Effect Value Color 01 Effect Value Checkbox 02 Effect Value Checkbox color Effect Value Color 04 Effect Value Slider 05 Effect Value Slider 06 Effect Value Slider 07 Effect Value Slider 08 Effect Value Slider 09 Effect Value Drop Down type Effect Value Drop Down Tritone Effect Converts the layer to greyscale, then applies the gradient based on bright/mid/dark. Attribute Type Description ty integer = 23 Type ef array Effect values Name Type bright Effect Value Color mid Effect Value Color dark Effect Value Color Bright Red 1 Green 1 Blue 1 Mid Red 0.3 Green 0.8 Blue 0.3 Dark Red 0 Green 0 Blue 0 Show JSON var lottie_player_9 = new PlaygroundPlayer( 9, 'playground_9_10', 'lottie_target_9', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 23, \"ef\": [{\"ty\": 2, \"v\": {\"k\": [1, 1, 1, 1], \"a\": 0}}, {\"ty\": 2, \"v\": {\"k\": [0.3, 0.8, 0.3, 1], \"a\": 0}}, {\"ty\": 2, \"v\": {\"k\": [0, 0, 0, 1], \"a\": 0}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ef[0].ef[0].v.k[0] = data[\"r1\"]; lottie.layers[0].ef[0].ef[0].v.k[1] = data[\"g1\"]; lottie.layers[0].ef[0].ef[0].v.k[2] = data[\"b1\"]; lottie.layers[0].ef[0].ef[1].v.k[0] = data[\"r2\"]; lottie.layers[0].ef[0].ef[1].v.k[1] = data[\"g2\"]; lottie.layers[0].ef[0].ef[1].v.k[2] = data[\"b2\"]; lottie.layers[0].ef[0].ef[2].v.k[0] = data[\"r3\"]; lottie.layers[0].ef[0].ef[2].v.k[1] = data[\"g3\"]; lottie.layers[0].ef[0].ef[2].v.k[2] = data[\"b3\"];this.json_viewer_contents = lottie.layers[0].ef[0]; }, {} ); Pro Levels Effect Color correction levels. For more information refer to the After Effects Documentation . Attribute Type Description ty integer = 24 Type ef array Effect values Name Type 00 Effect Value Drop Down 01 Effect No Value 02 Effect No Value comp_inblack Effect Value Slider comp_inwhite Effect Value Slider comp_gamma Effect Value Slider comp_outblack Effect Value Slider comp_outwhite Effect No Value 08 Effect No Value 09 Effect Value Slider r_inblack Effect Value Slider r_inwhite Effect Value Slider r_gamma Effect Value Slider r_outblack Effect Value Slider r_outwhite Effect Value Slider 15 Effect Value Slider 16 Effect Value Slider g_inblack Effect Value Slider g_inwhite Effect Value Slider g_gamma Effect Value Slider g_outblack Effect Value Slider g_outwhite Effect Value Slider 22 Effect Value Slider 23 Effect Value Slider b_inblack Effect Value Slider b_inwhite Effect Value Slider b_gamma Effect Value Slider b_outblack Effect Value Slider b_outwhite Effect Value Slider 29 Effect Value Slider a_inblack Effect Value Slider a_inwhite Effect Value Slider a_gamma Effect Value Slider a_outblack Effect Value Slider a_outwhite Effect No Value Composite In Black 0 In White 1 Gamma 1 Out Black 0 Out White 1 Red In Black 0 In White 1 Gamma 1 Out Black 0 Out White 1 Green In Black 0 In White 1 Gamma 1 Out Black 0 Out White 1 Blue In Black 0 In White 1 Gamma 1 Out Black 0 Out White 1 Show JSON var lottie_player_10 = new PlaygroundPlayer( 10, 'playground_10_21', 'lottie_target_10', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 24, \"ef\": [{\"ty\": 7, \"v\": {\"nm\": \"00 Dropdown\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"01\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"02\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_outwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"08\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"09 slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"r_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"r_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"r_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"r_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"r_outwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"15 slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"16 slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"g_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"g_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"g_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"g_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"g_outwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"22\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"23\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"b_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"b_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"b_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"b_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"b_outwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"29\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"a_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"a_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"a_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"a_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"a_outwhite slider\", \"a\": 0, \"k\": 1}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ef[0].ef[3].v.k = data[\"Composite In Black\"]; lottie.layers[0].ef[0].ef[4].v.k = data[\"Composite In White\"]; lottie.layers[0].ef[0].ef[5].v.k = data[\"Composite Gamma\"]; lottie.layers[0].ef[0].ef[6].v.k = data[\"Composite Out Black\"]; lottie.layers[0].ef[0].ef[7].v.k = data[\"Composite Out White\"]; lottie.layers[0].ef[0].ef[10].v.k = data[\"Red In Black\"]; lottie.layers[0].ef[0].ef[11].v.k = data[\"Red In White\"]; lottie.layers[0].ef[0].ef[12].v.k = data[\"Red Gamma\"]; lottie.layers[0].ef[0].ef[13].v.k = data[\"Red Out Black\"]; lottie.layers[0].ef[0].ef[14].v.k = data[\"Red Out White\"]; lottie.layers[0].ef[0].ef[17].v.k = data[\"Green In Black\"]; lottie.layers[0].ef[0].ef[18].v.k = data[\"Green In White\"]; lottie.layers[0].ef[0].ef[19].v.k = data[\"Green Gamma\"]; lottie.layers[0].ef[0].ef[20].v.k = data[\"Green Out Black\"]; lottie.layers[0].ef[0].ef[21].v.k = data[\"Green Out White\"]; lottie.layers[0].ef[0].ef[24].v.k = data[\"Blue In Black\"]; lottie.layers[0].ef[0].ef[25].v.k = data[\"Blue In White\"]; lottie.layers[0].ef[0].ef[26].v.k = data[\"Blue Gamma\"]; lottie.layers[0].ef[0].ef[27].v.k = data[\"Blue Out Black\"]; lottie.layers[0].ef[0].ef[28].v.k = data[\"Blue Out White\"];this.json_viewer_contents = lottie.layers[0].ef[0]; }, {} ); Tint Effect The layer is converted to grayscale, then black to white is mapped to the given color. The result is merged back with the original based on the intensity. Attribute Type Description ty integer = 20 Type ef array Effect values Name Type Black Color Effect Value Color White Color Effect Value Color Intensity Effect Value Slider Black Red 0 Green 0 Blue 0 White Red 0 Green 1 Blue 0 Intensity Effect Intensity 90 Show JSON var lottie_player_11 = new PlaygroundPlayer( 11, 'playground_11_8', 'lottie_target_11', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 20, \"ef\": [{\"ty\": 2, \"v\": {\"k\": [0, 0, 0, 1], \"a\": 0}}, {\"ty\": 2, \"v\": {\"k\": [0, 1, 0, 1], \"a\": 0}}, {\"ty\": 0, \"v\": {\"k\": 90, \"a\": 0}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ef[0].ef[0].v.k[0] = data[\"Black Red\"]; lottie.layers[0].ef[0].ef[0].v.k[1] = data[\"Black Green\"]; lottie.layers[0].ef[0].ef[0].v.k[2] = data[\"Black Blue\"]; lottie.layers[0].ef[0].ef[1].v.k[0] = data[\"White Red\"]; lottie.layers[0].ef[0].ef[1].v.k[1] = data[\"White Green\"]; lottie.layers[0].ef[0].ef[1].v.k[2] = data[\"White Blue\"]; lottie.layers[0].ef[0].ef[2].v.k = data[\"Effect Intensity\"];this.json_viewer_contents = lottie.layers[0].ef[0]; }, {} ); Matte3 Effect Uses a layer as a mask Attribute Type Description ty integer = 28 Type ef array Effect values Name Type Layer Effect Value Layer Channel Effect Value Drop Down Invert Effect Value Drop Down Stretch To Fit Effect Value Drop Down Show Mask Effect Value Drop Down Premultiply Mask Effect Value Drop Down Layer Circle Rectangle Channel Red Green Blue Alpha Luma Hue Lightness Saturation Full Off Invert Stretch To Fit Show Mask Premultiply Mask Show JSON var lottie_player_12 = new PlaygroundPlayer( 12, 'playground_12_7', 'lottie_target_12', {\"v\": \"5.9.0\", \"fr\": 29.9700012207031, \"ip\": 0, \"op\": 900.000036657751, \"w\": 1920, \"h\": 1080, \"nm\": \"Comp 1\", \"ddd\": 0, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ind\": 1, \"ty\": 4, \"nm\": \"Star\", \"sr\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100, \"ix\": 11}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 10}, \"p\": {\"a\": 0, \"k\": [960, 540, 0], \"ix\": 2, \"l\": 2}, \"a\": {\"a\": 0, \"k\": [0, 0, 0], \"ix\": 1, \"l\": 2}, \"s\": {\"a\": 0, \"k\": [100, 100, 100], \"ix\": 6, \"l\": 2}}, \"ao\": 0, \"ef\": [{\"ty\": 28, \"nm\": \"Set Matte\", \"np\": 8, \"mn\": \"ADBE Set Matte3\", \"ix\": 1, \"en\": 1, \"ef\": [{\"ty\": 10, \"nm\": \"Take Matte From Layer\", \"mn\": \"ADBE Set Matte3-0001\", \"ix\": 1, \"v\": {\"a\": 0, \"k\": 3, \"ix\": 1}}, {\"ty\": 7, \"nm\": \"Use For Matte\", \"mn\": \"ADBE Set Matte3-0002\", \"ix\": 2, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 2}}, {\"ty\": 7, \"nm\": \"Invert Matte\", \"mn\": \"ADBE Set Matte3-0003\", \"ix\": 3, \"v\": {\"a\": 0, \"k\": 0, \"ix\": 3}}, {\"ty\": 7, \"nm\": \"If Layer Sizes Differ\", \"mn\": \"ADBE Set Matte3-0004\", \"ix\": 4, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 4}}, {\"ty\": 7, \"nm\": \"Composite Matte with Original\", \"mn\": \"ADBE Set Matte3-0005\", \"ix\": 5, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 5}}, {\"ty\": 7, \"nm\": \"Premultiply Matte Layer\", \"mn\": \"ADBE Set Matte3-0006\", \"ix\": 6, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 6}}]}], \"shapes\": [{\"ty\": \"gr\", \"it\": [{\"ty\": \"sr\", \"sy\": 1, \"d\": 1, \"pt\": {\"a\": 0, \"k\": 5, \"ix\": 3}, \"p\": {\"a\": 0, \"k\": [0, 0], \"ix\": 4}, \"r\": {\"a\": 0, \"k\": 222.865, \"ix\": 5}, \"ir\": {\"a\": 0, \"k\": 226.442, \"ix\": 6}, \"is\": {\"a\": 0, \"k\": 0, \"ix\": 8}, \"or\": {\"a\": 0, \"k\": 452.885, \"ix\": 7}, \"os\": {\"a\": 0, \"k\": 0, \"ix\": 9}, \"ix\": 1, \"nm\": \"Polystar Path 1\", \"mn\": \"ADBE Vector Shape - Star\", \"hd\": false}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725], \"ix\": 4}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 5}, \"r\": 1, \"bm\": 0, \"nm\": \"Fill 1\", \"mn\": \"ADBE Vector Graphic - Fill\", \"hd\": false}, {\"ty\": \"tr\", \"p\": {\"a\": 0, \"k\": [124, -148], \"ix\": 2}, \"a\": {\"a\": 0, \"k\": [0, 0], \"ix\": 1}, \"s\": {\"a\": 0, \"k\": [100, 100], \"ix\": 3}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 6}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 7}, \"sk\": {\"a\": 0, \"k\": 0, \"ix\": 4}, \"sa\": {\"a\": 0, \"k\": 0, \"ix\": 5}, \"nm\": \"Transform\"}], \"nm\": \"Polystar 1\", \"np\": 3, \"cix\": 2, \"bm\": 0, \"ix\": 1, \"mn\": \"ADBE Vector Group\", \"hd\": false}], \"ip\": 0, \"op\": 900.000036657751, \"st\": 0, \"bm\": 0}, {\"ddd\": 0, \"ind\": 2, \"ty\": 4, \"nm\": \"Ellipse\", \"sr\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100, \"ix\": 11}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 10}, \"p\": {\"a\": 0, \"k\": [960, 540, 0], \"ix\": 2, \"l\": 2}, \"a\": {\"a\": 0, \"k\": [0, 0, 0], \"ix\": 1, \"l\": 2}, \"s\": {\"a\": 0, \"k\": [100, 100, 100], \"ix\": 6, \"l\": 2}}, \"ao\": 0, \"shapes\": [{\"ty\": \"gr\", \"it\": [{\"d\": 1, \"ty\": \"el\", \"s\": {\"a\": 0, \"k\": [528.102, 545.938], \"ix\": 2}, \"p\": {\"a\": 0, \"k\": [0, 0], \"ix\": 3}, \"nm\": \"Ellipse Path 1\", \"mn\": \"ADBE Vector Shape - Ellipse\", \"hd\": false}, {\"ty\": \"st\", \"c\": {\"a\": 0, \"k\": [1, 1, 1, 1], \"ix\": 3}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 4}, \"w\": {\"a\": 0, \"k\": 2, \"ix\": 5}, \"lc\": 1, \"lj\": 1, \"ml\": 4, \"bm\": 0, \"nm\": \"Stroke 1\", \"mn\": \"ADBE Vector Graphic - Stroke\", \"hd\": false}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0.7686274509803922, 0.8509803921568627, 0.9607843137254902], \"ix\": 4}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 5}, \"r\": 1, \"bm\": 0, \"nm\": \"Fill 1\", \"mn\": \"ADBE Vector Graphic - Fill\", \"hd\": false}, {\"ty\": \"tr\", \"p\": {\"a\": 0, \"k\": [409.91, -95.102], \"ix\": 2}, \"a\": {\"a\": 0, \"k\": [0, 0], \"ix\": 1}, \"s\": {\"a\": 0, \"k\": [100, 100], \"ix\": 3}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 6}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 7}, \"sk\": {\"a\": 0, \"k\": 0, \"ix\": 4}, \"sa\": {\"a\": 0, \"k\": 0, \"ix\": 5}, \"nm\": \"Transform\"}], \"nm\": \"Ellipse 1\", \"np\": 3, \"cix\": 2, \"bm\": 0, \"ix\": 1, \"mn\": \"ADBE Vector Group\", \"hd\": false}], \"ip\": 0, \"op\": 900.000036657751, \"st\": 0, \"bm\": 0}, {\"ddd\": 0, \"ind\": 3, \"ty\": 4, \"nm\": \"Rectangle\", \"sr\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100, \"ix\": 11}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 10}, \"p\": {\"a\": 0, \"k\": [960, 540, 0], \"ix\": 2, \"l\": 2}, \"a\": {\"a\": 0, \"k\": [0, 0, 0], \"ix\": 1, \"l\": 2}, \"s\": {\"a\": 0, \"k\": [100, 100, 100], \"ix\": 6, \"l\": 2}}, \"ao\": 0, \"shapes\": [{\"ty\": \"gr\", \"it\": [{\"ty\": \"rc\", \"d\": 1, \"s\": {\"a\": 0, \"k\": [78.482, 70.992], \"ix\": 2}, \"p\": {\"a\": 0, \"k\": [0, 0], \"ix\": 3}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 4}, \"nm\": \"Rectangle Path 1\", \"mn\": \"ADBE Vector Shape - Rect\", \"hd\": false}, {\"ty\": \"st\", \"c\": {\"a\": 0, \"k\": [1, 1, 1, 1], \"ix\": 3}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 4}, \"w\": {\"a\": 0, \"k\": 2, \"ix\": 5}, \"lc\": 1, \"lj\": 1, \"ml\": 4, \"bm\": 0, \"nm\": \"Stroke 1\", \"mn\": \"ADBE Vector Graphic - Stroke\", \"hd\": false}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0.9411764705882353, 0.11372549019607843, 0.0392156862745098], \"ix\": 4}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 5}, \"r\": 1, \"bm\": 0, \"nm\": \"Fill 1\", \"mn\": \"ADBE Vector Graphic - Fill\", \"hd\": false}, {\"ty\": \"tr\", \"p\": {\"a\": 0, \"k\": [-143.321, -63.043], \"ix\": 2}, \"a\": {\"a\": 0, \"k\": [0, 0], \"ix\": 1}, \"s\": {\"a\": 0, \"k\": [563.332, 416.105], \"ix\": 3}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 6}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 7}, \"sk\": {\"a\": 0, \"k\": 0, \"ix\": 4}, \"sa\": {\"a\": 0, \"k\": 0, \"ix\": 5}, \"nm\": \"Transform\"}], \"nm\": \"Rectangle 1\", \"np\": 3, \"cix\": 2, \"bm\": 0, \"ix\": 1, \"mn\": \"ADBE Vector Group\", \"hd\": false}], \"ip\": 0, \"op\": 900.000036657751, \"st\": 0, \"bm\": 0}], \"markers\": []}, function (lottie, data) { lottie.layers[0].ef[0].ef[0].v.k = Number(data[\"Layer\"]); lottie.layers[0].ef[0].ef[1].v.k = Number(data[\"Channel\"]); lottie.layers[0].ef[0].ef[2].v.k = Number(data[\"Invert\"]); lottie.layers[0].ef[0].ef[3].v.k = Number(data[\"Stretch To Fit\"]); lottie.layers[0].ef[0].ef[4].v.k = Number(data[\"Show Mask\"]); lottie.layers[0].ef[0].ef[5].v.k = Number(data[\"Premultiply Mask\"]);this.json_viewer_contents = lottie.layers[0].ef[0]; }, {} ); Gaussian Blur Effect Attribute Type Description ty integer = 29 Type ef array Effect values Name Type sigma Effect Value Slider direction Effect Value Slider wrap Effect Value Checkbox Sigma 25 Direction Both Horizontal Vertical Wrap Show JSON var lottie_player_13 = new PlaygroundPlayer( 13, 'playground_13_4', 'lottie_target_13', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 29, \"en\": 1, \"ef\": [{\"ty\": 0, \"v\": {\"a\": 0, \"k\": 25}}, {\"ty\": 0, \"v\": {\"k\": 0, \"a\": 0}}, {\"ty\": 4, \"v\": {\"k\": 0, \"a\": 0}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ef[0].ef[0].v.k = data[\"Sigma\"]; lottie.layers[0].ef[0].ef[1].v.k = Number(data[\"Direction\"]); lottie.layers[0].ef[0].ef[2].v.k = Number(data[\"Wrap\"]);this.json_viewer_contents = lottie.layers[0].ef[0]; }, {} ); Drop Shadow Effect Attribute Type Description ty integer = 25 Type ef array Effect values Name Type color Effect Value Color opacity Effect Value Slider angle Effect Value Angle distance Effect Value Slider blur Effect Value Slider Red 0 Green 0 Blue 0 Opacity 128 Angle 135 Distance 10 Blur 7 Show JSON var lottie_player_14 = new PlaygroundPlayer( 14, 'playground_14_8', 'lottie_target_14', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 25, \"ef\": [{\"ty\": 2, \"v\": {\"k\": [0, 0, 0, 1], \"a\": 0}}, {\"ty\": 0, \"v\": {\"k\": 128, \"a\": 0}}, {\"ty\": 1, \"v\": {\"k\": 135, \"a\": 0}}, {\"ty\": 0, \"v\": {\"k\": 10, \"a\": 0}}, {\"ty\": 0, \"v\": {\"k\": 7, \"a\": 0}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ef[0].ef[0].v.k[0] = data[\"Red\"]; lottie.layers[0].ef[0].ef[0].v.k[1] = data[\"Green\"]; lottie.layers[0].ef[0].ef[0].v.k[2] = data[\"Blue\"]; lottie.layers[0].ef[0].ef[1].v.k = data[\"Opacity\"]; lottie.layers[0].ef[0].ef[2].v.k = data[\"Angle\"]; lottie.layers[0].ef[0].ef[3].v.k = data[\"Distance\"]; lottie.layers[0].ef[0].ef[4].v.k = data[\"Blur\"];this.json_viewer_contents = lottie.layers[0].ef[0]; }, {} ); Radial Wipe Effect Attribute Type Description ty integer = 26 Type ef array Effect values Name Type Completion Effect Value Slider Start Angle Effect Value Angle Wipe Center Effect Value Point Wipe Effect Value Slider Feather Effect Value Slider Displacement Map Effect Attribute Type Description ty integer = 27 Type ef array Effect values Name Type Displacement Map Layer Effect Value Layer Use For Horizontal Displacement Effect Value Drop Down Max Horizontal Displacement Effect Value Slider Use For Vertical Displacement Effect Value Drop Down Max Vertical Displacement Effect Value Slider Displacement Map Behavior Effect Value Drop Down Edge Behavior Effect Value Drop Down Expand Output Effect Value Drop Down Mesh Warp Effect Attribute Type Description ty integer = 31 Type ef array Effect values Name Type Rows Effect Value Slider Columns Effect Value Slider Quality Effect Value Slider 03 Effect No Value Puppet Effect Attribute Type Description ty integer = 34 Type ef array Effect values Name Type Puppet Engine Effect Value Drop Down Mesh Rotation Refinement Effect Value Slider On Transparent Effect Value Drop Down 03 Effect No Value Spherize Effect Attribute Type Description ty integer = 33 Type ef array Effect values Name Type radius Effect Value Slider center Effect Value Point Wavy Effect Attribute Type Description ty integer = 32 Type ef array Effect values Name Type Radius Effect Value Slider Center Effect Value Point Conversion type Effect Value Drop Down Speed Effect Value Drop Down Width Effect Value Slider Height Effect Value Slider Phase Effect Value Slider Twirl Effect Attribute Type Description ty integer = 30 Type ef array Effect values Name Type Angle Effect Value Angle Radius Effect Value Slider Center Effect Value Point Custom Effect You might find various different effects all with ty = 5. Sometimes these are used together with expressions. Attribute Type Description ty integer = 5 Type Effect Values Attribute Type Description nm string Name mn string Match Name ix integer Effect Index ty integer Type ty Control Type 0 Slider 1 Angle 2 Color 3 Point 4 Checkbox 6 Ignored 7 Dropdown 10 Layer No Value Slider Attribute Type Description ty integer = 0 Type v Animated number Value Angle Attribute Type Description ty integer = 1 Type v Animated number Value Color Attribute Type Description ty integer = 2 Type v Animated Color Value Point Attribute Type Description ty integer = 3 Type v Animated Vector Value Checkbox Attribute Type Description ty integer = 4 Type v Animated number Value Ignored Attribute Type Description ty integer = 6 Type v number Value Drop Down Attribute Type Description ty integer = 7 Type v Animated number Value Layer Attribute Type Description ty integer = 10 Type v Animated number Value Layer Style A layer can also have a list of styles applied to it Attribute Type Description nm string Name, as seen from editors and the like mn string Match name, used in expressions ty integer Style Type Style types: ty Style Type 0 Stroke 1 Drop Shadow 2 Inner Shadow 3 Outer Glow 4 Inner Glow 5 Bevel / Emboss 6 Satin 7 Color Overlay 8 Gradient Overlay Stroke Style Attribute Type Description ty integer = 0 Layer Type s Animated number Size c Animated Color Color Drop Shadow Style Attribute Type Description ty integer = 1 Layer Type c Animated Color Color o Animated number Opacity a Animated number Local light angle s Animated number Blur size d Animated number Distance ch Animated number Choke Spread bm Animated number Blend Mode no Animated number Noise lc Animated number Layer knowck out drop shadow Inner Shadow Style Attribute Type Description ty integer = 2 Layer Type c Animated Color Color o Animated number Opacity a Animated number Local light angle s Animated number Blur size d Animated number Distance ch Animated number Choke Spread bm Animated number Blend Mode no Animated number Noise Outer Glow Style Attribute Type Description ty integer = 3 Layer Type c Animated Color Color o Animated number Opacity r Animated number Range ch Animated number Choke Spread bm Animated number Blend Mode no Animated number Noise j Animated number Jitter Inner Glow Style Attribute Type Description ty integer = 4 Layer Type c Animated Color Color o Animated number Opacity r Animated number Range sr Animated number Source ch Animated number Choke Spread bm Animated number Blend Mode no Animated number Noise j Animated number Jitter Bevel / Emboss Style Attribute Type Description ty integer = 5 Layer Type bs Animated number Bevel Style bt Animated number Technique sr Animated number Strength s Animated number Size sf Animated number Soften ga Animated number Use global light a Animated number Local lighting angle ll Animated number Local lighting altitude hm Animated number Highlight Mode hc Animated Color Highlight Color ho Animated number Highlight Opacity sm Animated number Shadow Mode sc Animated Color Shadow Color so Animated number Shadow Opacity Satin Style Attribute Type Description ty integer = 6 Layer Type bm Animated number Blend Mode c Animated Color Color o Animated number Opacity a Animated number Angle d Animated number Distance s Animated number Size in Animated number Invert Color Overlay Style Attribute Type Description ty integer = 7 Layer Type bm Animated number Blend Mode c Animated Color Color so Animated number Opacity Gradient Overlay Style Attribute Type Description ty integer = 8 Layer Type bm Animated number Blend Mode o Animated number Opacity gf Gradient Colors Gradient gs Animated number Smoothness a Animated number Angle gt Gradient Type Gradient Type re Animated number Reverse al Animated number Align with layer s Animated number Scale of Animated number Offset","title":"Layer Effects"},{"location":"effects/#layer-effects","text":"Layers can have post-processing effects applied to them.","title":"Layer Effects"},{"location":"effects/#effects","text":"Attribute Type Description nm string Name, as seen from editors and the like mn string Match name, used in expressions ef array of Effect No Value or Effect Value Angle or Effect Value Checkbox or Effect Value Color or Effect Value Drop Down or Ignored Value or Effect Value Layer or Effect Value Point or Effect Value Slider Array of effect values . Each effect below shows a table with the values it expects. np integer Number of values in ef ix integer Effect Index ty integer Effect type en 0-1 integer Enabled Many effects have unused values which are labeled with a number. Effect types: ty Effect Type 5 Misc Effect 20 Tint 21 Fill 22 Stroke 23 Tritone 24 Pro Levels 25 Drop Shadow 26 Radial Wipe 27 Displacement Map 28 Matte3 29 Gaussian Blur 30 Twirl 31 Mesh Warp 32 Wavy 33 Spherize 34 Puppet All the examples will use this as their base: var lottie_player_15 = new LottiePlayer( 'lottie_target_15', '../examples/image.json', true, {} );","title":"Effects"},{"location":"effects/#fill-effect","text":"Fill all opaque areas with a solid color Attribute Type Description ty integer = 21 Type ef array Effect values Name Type 00 Effect Value Point 01 Effect Value Drop Down color Effect Value Color 03 Effect Value Drop Down 04 Effect Value Slider 05 Effect Value Slider opacity Effect Value Slider Opacity 1 Color Red 1 Green 0.9 Blue 0 Show JSON var lottie_player_8 = new PlaygroundPlayer( 8, 'playground_8_5', 'lottie_target_8', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 21, \"ef\": [{\"ty\": 3, \"v\": {\"k\": [0, 0], \"a\": 0}}, {\"ty\": 7, \"v\": {\"k\": 0, \"a\": 0}}, {\"ty\": 2, \"v\": {\"k\": [1, 0.9, 0, 1], \"a\": 0}}, {\"ty\": 2, \"v\": {\"k\": [0, 0, 0, 1], \"a\": 0}}, {\"ty\": 7, \"v\": {\"k\": 0, \"a\": 0}}, {\"ty\": 0, \"v\": {\"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"a\": 0, \"k\": 0}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ef[0].ef[6].v.k = data[\"Opacity\"]; lottie.layers[0].ef[0].ef[2].v.k[0] = data[\"Red\"]; lottie.layers[0].ef[0].ef[2].v.k[1] = data[\"Green\"]; lottie.layers[0].ef[0].ef[2].v.k[2] = data[\"Blue\"];this.json_viewer_contents = lottie.layers[0].ef[0]; }, {} );","title":"Fill Effect"},{"location":"effects/#stroke-effect","text":"Attribute Type Description ty integer = 22 Type ef array Effect values Name Type 00 Effect Value Color 01 Effect Value Checkbox 02 Effect Value Checkbox color Effect Value Color 04 Effect Value Slider 05 Effect Value Slider 06 Effect Value Slider 07 Effect Value Slider 08 Effect Value Slider 09 Effect Value Drop Down type Effect Value Drop Down","title":"Stroke Effect"},{"location":"effects/#tritone-effect","text":"Converts the layer to greyscale, then applies the gradient based on bright/mid/dark. Attribute Type Description ty integer = 23 Type ef array Effect values Name Type bright Effect Value Color mid Effect Value Color dark Effect Value Color Bright Red 1 Green 1 Blue 1 Mid Red 0.3 Green 0.8 Blue 0.3 Dark Red 0 Green 0 Blue 0 Show JSON var lottie_player_9 = new PlaygroundPlayer( 9, 'playground_9_10', 'lottie_target_9', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 23, \"ef\": [{\"ty\": 2, \"v\": {\"k\": [1, 1, 1, 1], \"a\": 0}}, {\"ty\": 2, \"v\": {\"k\": [0.3, 0.8, 0.3, 1], \"a\": 0}}, {\"ty\": 2, \"v\": {\"k\": [0, 0, 0, 1], \"a\": 0}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ef[0].ef[0].v.k[0] = data[\"r1\"]; lottie.layers[0].ef[0].ef[0].v.k[1] = data[\"g1\"]; lottie.layers[0].ef[0].ef[0].v.k[2] = data[\"b1\"]; lottie.layers[0].ef[0].ef[1].v.k[0] = data[\"r2\"]; lottie.layers[0].ef[0].ef[1].v.k[1] = data[\"g2\"]; lottie.layers[0].ef[0].ef[1].v.k[2] = data[\"b2\"]; lottie.layers[0].ef[0].ef[2].v.k[0] = data[\"r3\"]; lottie.layers[0].ef[0].ef[2].v.k[1] = data[\"g3\"]; lottie.layers[0].ef[0].ef[2].v.k[2] = data[\"b3\"];this.json_viewer_contents = lottie.layers[0].ef[0]; }, {} );","title":"Tritone Effect"},{"location":"effects/#pro-levels-effect","text":"Color correction levels. For more information refer to the After Effects Documentation . Attribute Type Description ty integer = 24 Type ef array Effect values Name Type 00 Effect Value Drop Down 01 Effect No Value 02 Effect No Value comp_inblack Effect Value Slider comp_inwhite Effect Value Slider comp_gamma Effect Value Slider comp_outblack Effect Value Slider comp_outwhite Effect No Value 08 Effect No Value 09 Effect Value Slider r_inblack Effect Value Slider r_inwhite Effect Value Slider r_gamma Effect Value Slider r_outblack Effect Value Slider r_outwhite Effect Value Slider 15 Effect Value Slider 16 Effect Value Slider g_inblack Effect Value Slider g_inwhite Effect Value Slider g_gamma Effect Value Slider g_outblack Effect Value Slider g_outwhite Effect Value Slider 22 Effect Value Slider 23 Effect Value Slider b_inblack Effect Value Slider b_inwhite Effect Value Slider b_gamma Effect Value Slider b_outblack Effect Value Slider b_outwhite Effect Value Slider 29 Effect Value Slider a_inblack Effect Value Slider a_inwhite Effect Value Slider a_gamma Effect Value Slider a_outblack Effect Value Slider a_outwhite Effect No Value Composite In Black 0 In White 1 Gamma 1 Out Black 0 Out White 1 Red In Black 0 In White 1 Gamma 1 Out Black 0 Out White 1 Green In Black 0 In White 1 Gamma 1 Out Black 0 Out White 1 Blue In Black 0 In White 1 Gamma 1 Out Black 0 Out White 1 Show JSON var lottie_player_10 = new PlaygroundPlayer( 10, 'playground_10_21', 'lottie_target_10', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 24, \"ef\": [{\"ty\": 7, \"v\": {\"nm\": \"00 Dropdown\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"01\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"02\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_outwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"08\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"09 slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"r_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"r_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"r_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"r_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"r_outwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"15 slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"16 slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"g_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"g_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"g_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"g_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"g_outwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"22\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"23\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"b_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"b_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"b_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"b_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"b_outwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"29\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"a_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"a_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"a_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"a_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"a_outwhite slider\", \"a\": 0, \"k\": 1}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ef[0].ef[3].v.k = data[\"Composite In Black\"]; lottie.layers[0].ef[0].ef[4].v.k = data[\"Composite In White\"]; lottie.layers[0].ef[0].ef[5].v.k = data[\"Composite Gamma\"]; lottie.layers[0].ef[0].ef[6].v.k = data[\"Composite Out Black\"]; lottie.layers[0].ef[0].ef[7].v.k = data[\"Composite Out White\"]; lottie.layers[0].ef[0].ef[10].v.k = data[\"Red In Black\"]; lottie.layers[0].ef[0].ef[11].v.k = data[\"Red In White\"]; lottie.layers[0].ef[0].ef[12].v.k = data[\"Red Gamma\"]; lottie.layers[0].ef[0].ef[13].v.k = data[\"Red Out Black\"]; lottie.layers[0].ef[0].ef[14].v.k = data[\"Red Out White\"]; lottie.layers[0].ef[0].ef[17].v.k = data[\"Green In Black\"]; lottie.layers[0].ef[0].ef[18].v.k = data[\"Green In White\"]; lottie.layers[0].ef[0].ef[19].v.k = data[\"Green Gamma\"]; lottie.layers[0].ef[0].ef[20].v.k = data[\"Green Out Black\"]; lottie.layers[0].ef[0].ef[21].v.k = data[\"Green Out White\"]; lottie.layers[0].ef[0].ef[24].v.k = data[\"Blue In Black\"]; lottie.layers[0].ef[0].ef[25].v.k = data[\"Blue In White\"]; lottie.layers[0].ef[0].ef[26].v.k = data[\"Blue Gamma\"]; lottie.layers[0].ef[0].ef[27].v.k = data[\"Blue Out Black\"]; lottie.layers[0].ef[0].ef[28].v.k = data[\"Blue Out White\"];this.json_viewer_contents = lottie.layers[0].ef[0]; }, {} );","title":"Pro Levels Effect"},{"location":"effects/#tint-effect","text":"The layer is converted to grayscale, then black to white is mapped to the given color. The result is merged back with the original based on the intensity. Attribute Type Description ty integer = 20 Type ef array Effect values Name Type Black Color Effect Value Color White Color Effect Value Color Intensity Effect Value Slider Black Red 0 Green 0 Blue 0 White Red 0 Green 1 Blue 0 Intensity Effect Intensity 90 Show JSON var lottie_player_11 = new PlaygroundPlayer( 11, 'playground_11_8', 'lottie_target_11', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 20, \"ef\": [{\"ty\": 2, \"v\": {\"k\": [0, 0, 0, 1], \"a\": 0}}, {\"ty\": 2, \"v\": {\"k\": [0, 1, 0, 1], \"a\": 0}}, {\"ty\": 0, \"v\": {\"k\": 90, \"a\": 0}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ef[0].ef[0].v.k[0] = data[\"Black Red\"]; lottie.layers[0].ef[0].ef[0].v.k[1] = data[\"Black Green\"]; lottie.layers[0].ef[0].ef[0].v.k[2] = data[\"Black Blue\"]; lottie.layers[0].ef[0].ef[1].v.k[0] = data[\"White Red\"]; lottie.layers[0].ef[0].ef[1].v.k[1] = data[\"White Green\"]; lottie.layers[0].ef[0].ef[1].v.k[2] = data[\"White Blue\"]; lottie.layers[0].ef[0].ef[2].v.k = data[\"Effect Intensity\"];this.json_viewer_contents = lottie.layers[0].ef[0]; }, {} );","title":"Tint Effect"},{"location":"effects/#matte3-effect","text":"Uses a layer as a mask Attribute Type Description ty integer = 28 Type ef array Effect values Name Type Layer Effect Value Layer Channel Effect Value Drop Down Invert Effect Value Drop Down Stretch To Fit Effect Value Drop Down Show Mask Effect Value Drop Down Premultiply Mask Effect Value Drop Down Layer Circle Rectangle Channel Red Green Blue Alpha Luma Hue Lightness Saturation Full Off Invert Stretch To Fit Show Mask Premultiply Mask Show JSON var lottie_player_12 = new PlaygroundPlayer( 12, 'playground_12_7', 'lottie_target_12', {\"v\": \"5.9.0\", \"fr\": 29.9700012207031, \"ip\": 0, \"op\": 900.000036657751, \"w\": 1920, \"h\": 1080, \"nm\": \"Comp 1\", \"ddd\": 0, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ind\": 1, \"ty\": 4, \"nm\": \"Star\", \"sr\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100, \"ix\": 11}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 10}, \"p\": {\"a\": 0, \"k\": [960, 540, 0], \"ix\": 2, \"l\": 2}, \"a\": {\"a\": 0, \"k\": [0, 0, 0], \"ix\": 1, \"l\": 2}, \"s\": {\"a\": 0, \"k\": [100, 100, 100], \"ix\": 6, \"l\": 2}}, \"ao\": 0, \"ef\": [{\"ty\": 28, \"nm\": \"Set Matte\", \"np\": 8, \"mn\": \"ADBE Set Matte3\", \"ix\": 1, \"en\": 1, \"ef\": [{\"ty\": 10, \"nm\": \"Take Matte From Layer\", \"mn\": \"ADBE Set Matte3-0001\", \"ix\": 1, \"v\": {\"a\": 0, \"k\": 3, \"ix\": 1}}, {\"ty\": 7, \"nm\": \"Use For Matte\", \"mn\": \"ADBE Set Matte3-0002\", \"ix\": 2, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 2}}, {\"ty\": 7, \"nm\": \"Invert Matte\", \"mn\": \"ADBE Set Matte3-0003\", \"ix\": 3, \"v\": {\"a\": 0, \"k\": 0, \"ix\": 3}}, {\"ty\": 7, \"nm\": \"If Layer Sizes Differ\", \"mn\": \"ADBE Set Matte3-0004\", \"ix\": 4, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 4}}, {\"ty\": 7, \"nm\": \"Composite Matte with Original\", \"mn\": \"ADBE Set Matte3-0005\", \"ix\": 5, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 5}}, {\"ty\": 7, \"nm\": \"Premultiply Matte Layer\", \"mn\": \"ADBE Set Matte3-0006\", \"ix\": 6, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 6}}]}], \"shapes\": [{\"ty\": \"gr\", \"it\": [{\"ty\": \"sr\", \"sy\": 1, \"d\": 1, \"pt\": {\"a\": 0, \"k\": 5, \"ix\": 3}, \"p\": {\"a\": 0, \"k\": [0, 0], \"ix\": 4}, \"r\": {\"a\": 0, \"k\": 222.865, \"ix\": 5}, \"ir\": {\"a\": 0, \"k\": 226.442, \"ix\": 6}, \"is\": {\"a\": 0, \"k\": 0, \"ix\": 8}, \"or\": {\"a\": 0, \"k\": 452.885, \"ix\": 7}, \"os\": {\"a\": 0, \"k\": 0, \"ix\": 9}, \"ix\": 1, \"nm\": \"Polystar Path 1\", \"mn\": \"ADBE Vector Shape - Star\", \"hd\": false}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725], \"ix\": 4}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 5}, \"r\": 1, \"bm\": 0, \"nm\": \"Fill 1\", \"mn\": \"ADBE Vector Graphic - Fill\", \"hd\": false}, {\"ty\": \"tr\", \"p\": {\"a\": 0, \"k\": [124, -148], \"ix\": 2}, \"a\": {\"a\": 0, \"k\": [0, 0], \"ix\": 1}, \"s\": {\"a\": 0, \"k\": [100, 100], \"ix\": 3}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 6}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 7}, \"sk\": {\"a\": 0, \"k\": 0, \"ix\": 4}, \"sa\": {\"a\": 0, \"k\": 0, \"ix\": 5}, \"nm\": \"Transform\"}], \"nm\": \"Polystar 1\", \"np\": 3, \"cix\": 2, \"bm\": 0, \"ix\": 1, \"mn\": \"ADBE Vector Group\", \"hd\": false}], \"ip\": 0, \"op\": 900.000036657751, \"st\": 0, \"bm\": 0}, {\"ddd\": 0, \"ind\": 2, \"ty\": 4, \"nm\": \"Ellipse\", \"sr\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100, \"ix\": 11}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 10}, \"p\": {\"a\": 0, \"k\": [960, 540, 0], \"ix\": 2, \"l\": 2}, \"a\": {\"a\": 0, \"k\": [0, 0, 0], \"ix\": 1, \"l\": 2}, \"s\": {\"a\": 0, \"k\": [100, 100, 100], \"ix\": 6, \"l\": 2}}, \"ao\": 0, \"shapes\": [{\"ty\": \"gr\", \"it\": [{\"d\": 1, \"ty\": \"el\", \"s\": {\"a\": 0, \"k\": [528.102, 545.938], \"ix\": 2}, \"p\": {\"a\": 0, \"k\": [0, 0], \"ix\": 3}, \"nm\": \"Ellipse Path 1\", \"mn\": \"ADBE Vector Shape - Ellipse\", \"hd\": false}, {\"ty\": \"st\", \"c\": {\"a\": 0, \"k\": [1, 1, 1, 1], \"ix\": 3}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 4}, \"w\": {\"a\": 0, \"k\": 2, \"ix\": 5}, \"lc\": 1, \"lj\": 1, \"ml\": 4, \"bm\": 0, \"nm\": \"Stroke 1\", \"mn\": \"ADBE Vector Graphic - Stroke\", \"hd\": false}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0.7686274509803922, 0.8509803921568627, 0.9607843137254902], \"ix\": 4}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 5}, \"r\": 1, \"bm\": 0, \"nm\": \"Fill 1\", \"mn\": \"ADBE Vector Graphic - Fill\", \"hd\": false}, {\"ty\": \"tr\", \"p\": {\"a\": 0, \"k\": [409.91, -95.102], \"ix\": 2}, \"a\": {\"a\": 0, \"k\": [0, 0], \"ix\": 1}, \"s\": {\"a\": 0, \"k\": [100, 100], \"ix\": 3}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 6}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 7}, \"sk\": {\"a\": 0, \"k\": 0, \"ix\": 4}, \"sa\": {\"a\": 0, \"k\": 0, \"ix\": 5}, \"nm\": \"Transform\"}], \"nm\": \"Ellipse 1\", \"np\": 3, \"cix\": 2, \"bm\": 0, \"ix\": 1, \"mn\": \"ADBE Vector Group\", \"hd\": false}], \"ip\": 0, \"op\": 900.000036657751, \"st\": 0, \"bm\": 0}, {\"ddd\": 0, \"ind\": 3, \"ty\": 4, \"nm\": \"Rectangle\", \"sr\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100, \"ix\": 11}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 10}, \"p\": {\"a\": 0, \"k\": [960, 540, 0], \"ix\": 2, \"l\": 2}, \"a\": {\"a\": 0, \"k\": [0, 0, 0], \"ix\": 1, \"l\": 2}, \"s\": {\"a\": 0, \"k\": [100, 100, 100], \"ix\": 6, \"l\": 2}}, \"ao\": 0, \"shapes\": [{\"ty\": \"gr\", \"it\": [{\"ty\": \"rc\", \"d\": 1, \"s\": {\"a\": 0, \"k\": [78.482, 70.992], \"ix\": 2}, \"p\": {\"a\": 0, \"k\": [0, 0], \"ix\": 3}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 4}, \"nm\": \"Rectangle Path 1\", \"mn\": \"ADBE Vector Shape - Rect\", \"hd\": false}, {\"ty\": \"st\", \"c\": {\"a\": 0, \"k\": [1, 1, 1, 1], \"ix\": 3}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 4}, \"w\": {\"a\": 0, \"k\": 2, \"ix\": 5}, \"lc\": 1, \"lj\": 1, \"ml\": 4, \"bm\": 0, \"nm\": \"Stroke 1\", \"mn\": \"ADBE Vector Graphic - Stroke\", \"hd\": false}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0.9411764705882353, 0.11372549019607843, 0.0392156862745098], \"ix\": 4}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 5}, \"r\": 1, \"bm\": 0, \"nm\": \"Fill 1\", \"mn\": \"ADBE Vector Graphic - Fill\", \"hd\": false}, {\"ty\": \"tr\", \"p\": {\"a\": 0, \"k\": [-143.321, -63.043], \"ix\": 2}, \"a\": {\"a\": 0, \"k\": [0, 0], \"ix\": 1}, \"s\": {\"a\": 0, \"k\": [563.332, 416.105], \"ix\": 3}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 6}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 7}, \"sk\": {\"a\": 0, \"k\": 0, \"ix\": 4}, \"sa\": {\"a\": 0, \"k\": 0, \"ix\": 5}, \"nm\": \"Transform\"}], \"nm\": \"Rectangle 1\", \"np\": 3, \"cix\": 2, \"bm\": 0, \"ix\": 1, \"mn\": \"ADBE Vector Group\", \"hd\": false}], \"ip\": 0, \"op\": 900.000036657751, \"st\": 0, \"bm\": 0}], \"markers\": []}, function (lottie, data) { lottie.layers[0].ef[0].ef[0].v.k = Number(data[\"Layer\"]); lottie.layers[0].ef[0].ef[1].v.k = Number(data[\"Channel\"]); lottie.layers[0].ef[0].ef[2].v.k = Number(data[\"Invert\"]); lottie.layers[0].ef[0].ef[3].v.k = Number(data[\"Stretch To Fit\"]); lottie.layers[0].ef[0].ef[4].v.k = Number(data[\"Show Mask\"]); lottie.layers[0].ef[0].ef[5].v.k = Number(data[\"Premultiply Mask\"]);this.json_viewer_contents = lottie.layers[0].ef[0]; }, {} );","title":"Matte3 Effect"},{"location":"effects/#gaussian-blur-effect","text":"Attribute Type Description ty integer = 29 Type ef array Effect values Name Type sigma Effect Value Slider direction Effect Value Slider wrap Effect Value Checkbox Sigma 25 Direction Both Horizontal Vertical Wrap Show JSON var lottie_player_13 = new PlaygroundPlayer( 13, 'playground_13_4', 'lottie_target_13', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 29, \"en\": 1, \"ef\": [{\"ty\": 0, \"v\": {\"a\": 0, \"k\": 25}}, {\"ty\": 0, \"v\": {\"k\": 0, \"a\": 0}}, {\"ty\": 4, \"v\": {\"k\": 0, \"a\": 0}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ef[0].ef[0].v.k = data[\"Sigma\"]; lottie.layers[0].ef[0].ef[1].v.k = Number(data[\"Direction\"]); lottie.layers[0].ef[0].ef[2].v.k = Number(data[\"Wrap\"]);this.json_viewer_contents = lottie.layers[0].ef[0]; }, {} );","title":"Gaussian Blur Effect"},{"location":"effects/#drop-shadow-effect","text":"Attribute Type Description ty integer = 25 Type ef array Effect values Name Type color Effect Value Color opacity Effect Value Slider angle Effect Value Angle distance Effect Value Slider blur Effect Value Slider Red 0 Green 0 Blue 0 Opacity 128 Angle 135 Distance 10 Blur 7 Show JSON var lottie_player_14 = new PlaygroundPlayer( 14, 'playground_14_8', 'lottie_target_14', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 25, \"ef\": [{\"ty\": 2, \"v\": {\"k\": [0, 0, 0, 1], \"a\": 0}}, {\"ty\": 0, \"v\": {\"k\": 128, \"a\": 0}}, {\"ty\": 1, \"v\": {\"k\": 135, \"a\": 0}}, {\"ty\": 0, \"v\": {\"k\": 10, \"a\": 0}}, {\"ty\": 0, \"v\": {\"k\": 7, \"a\": 0}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ef[0].ef[0].v.k[0] = data[\"Red\"]; lottie.layers[0].ef[0].ef[0].v.k[1] = data[\"Green\"]; lottie.layers[0].ef[0].ef[0].v.k[2] = data[\"Blue\"]; lottie.layers[0].ef[0].ef[1].v.k = data[\"Opacity\"]; lottie.layers[0].ef[0].ef[2].v.k = data[\"Angle\"]; lottie.layers[0].ef[0].ef[3].v.k = data[\"Distance\"]; lottie.layers[0].ef[0].ef[4].v.k = data[\"Blur\"];this.json_viewer_contents = lottie.layers[0].ef[0]; }, {} );","title":"Drop Shadow Effect"},{"location":"effects/#radial-wipe-effect","text":"Attribute Type Description ty integer = 26 Type ef array Effect values Name Type Completion Effect Value Slider Start Angle Effect Value Angle Wipe Center Effect Value Point Wipe Effect Value Slider Feather Effect Value Slider","title":"Radial Wipe Effect"},{"location":"effects/#displacement-map-effect","text":"Attribute Type Description ty integer = 27 Type ef array Effect values Name Type Displacement Map Layer Effect Value Layer Use For Horizontal Displacement Effect Value Drop Down Max Horizontal Displacement Effect Value Slider Use For Vertical Displacement Effect Value Drop Down Max Vertical Displacement Effect Value Slider Displacement Map Behavior Effect Value Drop Down Edge Behavior Effect Value Drop Down Expand Output Effect Value Drop Down","title":"Displacement Map Effect"},{"location":"effects/#mesh-warp-effect","text":"Attribute Type Description ty integer = 31 Type ef array Effect values Name Type Rows Effect Value Slider Columns Effect Value Slider Quality Effect Value Slider 03 Effect No Value","title":"Mesh Warp Effect"},{"location":"effects/#puppet-effect","text":"Attribute Type Description ty integer = 34 Type ef array Effect values Name Type Puppet Engine Effect Value Drop Down Mesh Rotation Refinement Effect Value Slider On Transparent Effect Value Drop Down 03 Effect No Value","title":"Puppet Effect"},{"location":"effects/#spherize-effect","text":"Attribute Type Description ty integer = 33 Type ef array Effect values Name Type radius Effect Value Slider center Effect Value Point","title":"Spherize Effect"},{"location":"effects/#wavy-effect","text":"Attribute Type Description ty integer = 32 Type ef array Effect values Name Type Radius Effect Value Slider Center Effect Value Point Conversion type Effect Value Drop Down Speed Effect Value Drop Down Width Effect Value Slider Height Effect Value Slider Phase Effect Value Slider","title":"Wavy Effect"},{"location":"effects/#twirl-effect","text":"Attribute Type Description ty integer = 30 Type ef array Effect values Name Type Angle Effect Value Angle Radius Effect Value Slider Center Effect Value Point","title":"Twirl Effect"},{"location":"effects/#custom-effect","text":"You might find various different effects all with ty = 5. Sometimes these are used together with expressions. Attribute Type Description ty integer = 5 Type","title":"Custom Effect"},{"location":"effects/#effect-values","text":"Attribute Type Description nm string Name mn string Match Name ix integer Effect Index ty integer Type ty Control Type 0 Slider 1 Angle 2 Color 3 Point 4 Checkbox 6 Ignored 7 Dropdown 10 Layer","title":"Effect Values"},{"location":"effects/#no-value","text":"","title":"No Value"},{"location":"effects/#slider","text":"Attribute Type Description ty integer = 0 Type v Animated number Value","title":"Slider"},{"location":"effects/#angle","text":"Attribute Type Description ty integer = 1 Type v Animated number Value","title":"Angle"},{"location":"effects/#color","text":"Attribute Type Description ty integer = 2 Type v Animated Color Value","title":"Color"},{"location":"effects/#point","text":"Attribute Type Description ty integer = 3 Type v Animated Vector Value","title":"Point"},{"location":"effects/#checkbox","text":"Attribute Type Description ty integer = 4 Type v Animated number Value","title":"Checkbox"},{"location":"effects/#ignored","text":"Attribute Type Description ty integer = 6 Type v number Value","title":"Ignored"},{"location":"effects/#drop-down","text":"Attribute Type Description ty integer = 7 Type v Animated number Value","title":"Drop Down"},{"location":"effects/#layer","text":"Attribute Type Description ty integer = 10 Type v Animated number Value","title":"Layer"},{"location":"effects/#layer-style","text":"A layer can also have a list of styles applied to it Attribute Type Description nm string Name, as seen from editors and the like mn string Match name, used in expressions ty integer Style Type Style types: ty Style Type 0 Stroke 1 Drop Shadow 2 Inner Shadow 3 Outer Glow 4 Inner Glow 5 Bevel / Emboss 6 Satin 7 Color Overlay 8 Gradient Overlay","title":"Layer Style"},{"location":"effects/#stroke-style","text":"Attribute Type Description ty integer = 0 Layer Type s Animated number Size c Animated Color Color","title":"Stroke Style"},{"location":"effects/#drop-shadow-style","text":"Attribute Type Description ty integer = 1 Layer Type c Animated Color Color o Animated number Opacity a Animated number Local light angle s Animated number Blur size d Animated number Distance ch Animated number Choke Spread bm Animated number Blend Mode no Animated number Noise lc Animated number Layer knowck out drop shadow","title":"Drop Shadow Style"},{"location":"effects/#inner-shadow-style","text":"Attribute Type Description ty integer = 2 Layer Type c Animated Color Color o Animated number Opacity a Animated number Local light angle s Animated number Blur size d Animated number Distance ch Animated number Choke Spread bm Animated number Blend Mode no Animated number Noise","title":"Inner Shadow Style"},{"location":"effects/#outer-glow-style","text":"Attribute Type Description ty integer = 3 Layer Type c Animated Color Color o Animated number Opacity r Animated number Range ch Animated number Choke Spread bm Animated number Blend Mode no Animated number Noise j Animated number Jitter","title":"Outer Glow Style"},{"location":"effects/#inner-glow-style","text":"Attribute Type Description ty integer = 4 Layer Type c Animated Color Color o Animated number Opacity r Animated number Range sr Animated number Source ch Animated number Choke Spread bm Animated number Blend Mode no Animated number Noise j Animated number Jitter","title":"Inner Glow Style"},{"location":"effects/#bevel-emboss-style","text":"Attribute Type Description ty integer = 5 Layer Type bs Animated number Bevel Style bt Animated number Technique sr Animated number Strength s Animated number Size sf Animated number Soften ga Animated number Use global light a Animated number Local lighting angle ll Animated number Local lighting altitude hm Animated number Highlight Mode hc Animated Color Highlight Color ho Animated number Highlight Opacity sm Animated number Shadow Mode sc Animated Color Shadow Color so Animated number Shadow Opacity","title":"Bevel / Emboss Style"},{"location":"effects/#satin-style","text":"Attribute Type Description ty integer = 6 Layer Type bm Animated number Blend Mode c Animated Color Color o Animated number Opacity a Animated number Angle d Animated number Distance s Animated number Size in Animated number Invert","title":"Satin Style"},{"location":"effects/#color-overlay-style","text":"Attribute Type Description ty integer = 7 Layer Type bm Animated number Blend Mode c Animated Color Color so Animated number Opacity","title":"Color Overlay Style"},{"location":"effects/#gradient-overlay-style","text":"Attribute Type Description ty integer = 8 Layer Type bm Animated number Blend Mode o Animated number Opacity gf Gradient Colors Gradient gs Animated number Smoothness a Animated number Angle gt Gradient Type Gradient Type re Animated number Reverse al Animated number Align with layer s Animated number Scale of Animated number Offset","title":"Gradient Overlay Style"},{"location":"expressions/","text":"Expressions Properties can have expressions associated with them, when this is the case the value of such properties can be modified by using the expression. The expression language is based on JavaScript / ECMAScript. For the most part it uses what is described in the After Effects expressions. More resources on AE expressions: Expression Language Reference After Effects Expression Reference Global objects $bm_rt Name $bm_rt Type Depends on the property Description Output value for the expression Notes Must be declared and be assigned a value in every expression The special variable $bm_rt is used to determine the value of the expression. This variable must be declared by the expression and must have a value compatible with the property; var $bm_rt; $bm_rt = 60; Rotation Expression var $bm_rt = 60; var $bm_rt = 60; Position Expression var $bm_rt = [256, 256]; var $bm_rt = [256, 256]; Show JSON var lottie_player_16 = new PlaygroundPlayer( 16, 'playground_16_3', 'lottie_target_16', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"nm\": \"foo\", \"mn\": \"bar\", \"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [256, 256], \"a\": 0}, \"p\": {\"k\": [256, 256], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ks.r.x = data[\"Rotation Expression\"]; lottie.layers[0].ks.p.x = data[\"Position Expression\"];this.json_viewer_contents = lottie.layers[0].ks; }, {} ); time Name time Type number Description The current time within the composition in seconds Notes Read only Rotation Expression var $bm_rt = time * 360; var $bm_rt = time * 360; Show JSON var lottie_player_17 = new PlaygroundPlayer( 17, 'playground_17_2', 'lottie_target_17', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"nm\": \"foo\", \"mn\": \"bar\", \"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [256, 256], \"a\": 0}, \"p\": {\"k\": [256, 256], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ks.r.x = data[\"Rotation Expression\"];this.json_viewer_contents = lottie.layers[0].ks.r; }, {} ); value Name value Type Depends on the property Description The value the property would have without expressions Notes Read only Position Expression var $bm_rt = []; $bm_rt[0] = value[0] + Math.cos(2 * Math.PI * time) * 100; $bm_rt[1] = value[1]; var $bm_rt = []; $bm_rt[0] = value[0] + Math.cos(2 * Math.PI * time) * 100; $bm_rt[1] = value[1]; Show JSON var lottie_player_18 = new PlaygroundPlayer( 18, 'playground_18_2', 'lottie_target_18', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"nm\": \"foo\", \"mn\": \"bar\", \"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [256, 256], \"a\": 0}, \"p\": {\"k\": [256, 256], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ks.p.x = data[\"Position Expression\"];this.json_viewer_contents = lottie.layers[0].ks.p; }, {} ); thisProperty Name thisProperty Type Property Description Property the expression is operating on Notes Read only thisComp Name thisComp Type Composition Description Composition the property is in Notes Read only thisLayer Name thisLayer Type Layer Description Layer the property is in Notes Read only Animation Structure functions comp() Synopsis comp ( name: string ): Composition Parameters Name Type Default Description name string Composition name Return Type Composition Description Composition object matching the given name Misc Functions posterizeTime() Synopsis posterizeTime ( fps: number ) The rest of the expression will only be updated this many times per second Parameters Name Type Default Description fps number Frames per second timeToFrames() Synopsis timeToFrames ( time: number = time + thisComp.displayStartTime fps: number = 1.0 / thisComp.frameDuration ): number Converts a time in seconds to a number of frames Parameters Name Type Default Description time number time + thisComp.displayStartTime Time in seconds fps number 1.0 / thisComp.frameDuration Frames per second Return Type number Description Number of frames framesToTime() Synopsis framesToTime ( frames: number fps: number = 1.0 / thisComp.frameDuration ): number Converts a number of frames to a time in seconds Parameters Name Type Default Description frames number Number of frames fps number 1.0 / thisComp.frameDuration Frames per second Return Type number Description Time in seconds rgbToHsl() Synopsis rgbToHsl ( rgb: array[3]|array[4] ): array[3]|array[4] Parameters Name Type Default Description rgb array[3] | array[4] RGB(A) color, with components in 0, 1 Return Type array[3] | array[4] Description HSL(A) color, with components in 0, 1 hslToRgb() Synopsis hslToRgb ( hsl: array[3]|array[4] ): array[3]|array[4] Parameters Name Type Default Description hsl array[3] | array[4] HSL(A) color, with components in 0, 1 Return Type array[3] | array[4] Description RGB(A) color, with components in 0, 1 createPath() Synopsis createPath ( points: array in_tangents: array = [] out_tangents: array = [] is_closed: boolean = true ): Path Creates bezier path data Parameters Name Type Default Description points array Array of points (each point is a list with 2 numbers) in_tangents array [] Array of in tangents correponding to the point with the same index out_tangents array [] Array of out tangents correponding to the point with the same index is_closed boolean true Whether the path is closed Return Type Path Math functions add() Synopsis add ( a: any b: any ): any Parameters Name Type Default Description a any b any Return Type any If a and b are numbers, it will return their sum. If they string, their concatenation. If they are vectors, their element-wise sum. If one is a vector and the other a number, it will return the sum of the number by the first element of the vector. This function is also available as $bm_sum and sum . sub() Synopsis sub ( a: any b: any ): any Parameters Name Type Default Description a any b any Return Type any If a and b are numbers, or can be converted to numbers, it will return their difference. If they are vectors, their element-wise difference. This function is also avilable as $bm_sub . mul() Synopsis mul ( a: any b: any ): any Parameters Name Type Default Description a any b any Return Type any If a and b are numbers, or can be converted to numbers, it will return their product. If one of them is a vector and the other a number, it will return a vector with each element multiplied by the number. This function is also avilable as $bm_mul . div() Synopsis div ( a: any b: any ): any Parameters Name Type Default Description a any b any Return Type any If a and b are numbers, or can be converted to numbers, it will return their division. If one of them is a vector and the other a number, it will return a vector with each element divided by the number. This function is also avilable as $bm_div . mod() Synopsis mod ( a: any b: any ): any Parameters Name Type Default Description a any b any Return Type any clamp() Synopsis clamp ( value: number minimum: number maximum: number ): number Clamps a value inside a range Parameters Name Type Default Description value number The value to clamp minimum number Minimum value maximum number Maximum value Return Type number normalize() Synopsis normalize ( vector: array ): number Divides a vector by its length Parameters Name Type Default Description vector array Return Type number Description same as div(vector, length(vector)) length() Synopsis length ( vector: array ): number Parameters Name Type Default Description vector array Return Type number Description length of vector Synopsis length ( a: array b: array ): number Parameters Name Type Default Description a array b array Return Type number Description Distance between a and b . looAt() Synopsis lookAt ( from_point: array[3] to_point: array[3] ): number Parameters Name Type Default Description from_point array[3] to_point array[3] Return Type number Description length of vector seedRandom() Synopsis seedRandom ( seed: number ) Sets the seed for random functions Parameters Name Type Default Description seed number random() Synopsis random (): number Return Type number Description Random number between 0 and 1 Synopsis random ( max: number|array ): number|array Parameters Name Type Default Description max number | array Return Type number | array Description Random number between 0 and max , element wise if the argument is an array Synopsis random ( min: number|array max: number|array ): number|array Parameters Name Type Default Description min number | array max number | array Return Type number | array Description Random number between min and max , element wise if the arguments are arrays linear() Synopsis linear ( t: number value1: number|array value2: number|array ): number|array Parameters Name Type Default Description t number Interpolation factor between 0 and 1 value1 number | array value2 number | array Return Type number | array Description Linear interpolation between value1 and value2 Synopsis linear ( t: number t_min: number t_max: number value1: number|array value2: number|array ): number|array Parameters Name Type Default Description t number Interpolation factor between t_min and t_max t_min number Lower bound for the t range t_max number Lower bound for the t range value1 number | array value2 number | array Return Type number | array Description Linear interpolation between value1 and value2 , t is first normalized inside t_min and t_max ease() Works the same as linear() but with a smooth cubic interpolation. Synopsis ease ( t: number value1: number|array value2: number|array ): number|array Parameters Name Type Default Description t number Interpolation factor between 0 and 1 value1 number | array value2 number | array Return Type number | array Description Interpolation between value1 and value2 Synopsis ease ( t: number t_min: number t_max: number value1: number|array value2: number|array ): number|array Parameters Name Type Default Description t number Interpolation factor between t_min and t_max t_min number Lower bound for the t range t_max number Lower bound for the t range value1 number | array value2 number | array Return Type number | array Description Interpolation between value1 and value2 , t is first normalized inside t_min and t_max easeIn() Interpolation, starts the same as ease() and ends the same as linear() Synopsis easeIn ( t: number value1: number|array value2: number|array ): number|array Parameters Name Type Default Description t number Interpolation factor between 0 and 1 value1 number | array value2 number | array Return Type number | array Description Interpolation between value1 and value2 Synopsis easeIn ( t: number t_min: number t_max: number value1: number|array value2: number|array ): number|array Parameters Name Type Default Description t number Interpolation factor between t_min and t_max t_min number Lower bound for the t range t_max number Lower bound for the t range value1 number | array value2 number | array Return Type number | array Description Interpolation between value1 and value2 , t is first normalized inside t_min and t_max easeOut() Interpolation, starts the same as linear() and ends the same as ease() Synopsis easeOut ( t: number value1: number|array value2: number|array ): number|array Parameters Name Type Default Description t number Interpolation factor between 0 and 1 value1 number | array value2 number | array Return Type number | array Description Interpolation between value1 and value2 Synopsis easeOut ( t: number t_min: number t_max: number value1: number|array value2: number|array ): number|array Parameters Name Type Default Description t number Interpolation factor between t_min and t_max t_min number Lower bound for the t range t_max number Lower bound for the t range value1 number | array value2 number | array Return Type number | array Description Interpolation between value1 and value2 , t is first normalized inside t_min and t_max degreesToRadians() Synopsis degreesToRadians ( degrees: number ): number Parameters Name Type Default Description degrees number Angle in degrees Return Type number Description Angle in radians radiansToDegrees() Synopsis radiansToDegrees ( radians: number ): number Parameters Name Type Default Description radians number Angle in radians Return Type number Description Angle in degrees Property Property.value Name value Type Depends on the property Description The current value the property Notes Read only Property.numKeys Name numKeys Type number Description Number of keyframes Notes Read only Property.propertyIndex Name propertyIndex Type number Description Value of ix in the JSON for this property Notes Read only Property.valueAtTime() Synopsis valueAtTime ( t: number ): any Parameters Name Type Default Description t number Time in seconds Return Type Depends on the property Description The value of the property at the given time (without expressions) Property.getVelocityAtTime() Synopsis getVelocityAtTime ( t: number ): any Parameters Name Type Default Description t number Time in seconds Return Type Depends on the property Description The rate of change for the property, with the same dimensions as the value Property.getSpeedAtTime() Synopsis getSpeedAtTime ( t: number ): number Parameters Name Type Default Description t number Time in seconds Return Type number Description The rate of change for the property as a scalar Property.smooth() Synopsis smooth ( width: number samples: number ): any Parameters Name Type Default Description width number samples number Return Type Depends on the property Property.loopIn() Synopsis loopIn ( type: string duration: number wrap: boolean ): any Parameters Name Type Default Description type string duration number wrap boolean Return Type Depends on the property Property.loopOut() Synopsis loopOut ( type: string duration: number wrap: boolean ): any Parameters Name Type Default Description type string duration number wrap boolean Return Type Depends on the property Composition Composition object Position Expression var $bm_rt = [256, 256] var rotation = comp(\"Animation\").layer(\"Layer\").transform.rotation / 180 * Math.PI; $bm_rt[0] += Math.cos(rotation) * 200; $bm_rt[1] += Math.sin(rotation) * 200; var $bm_rt = [256, 256] var rotation = comp(\"Animation\").layer(\"Layer\").transform.rotation / 180 * Math.PI; $bm_rt[0] += Math.cos(rotation) * 200; $bm_rt[1] += Math.sin(rotation) * 200; Show JSON var lottie_player_19 = new PlaygroundPlayer( 19, 'playground_19_2', 'lottie_target_19', {\"v\": \"5.5.2\", \"nm\": \"Animation\", \"fr\": 60, \"ip\": 0, \"op\": 180, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}, {\"id\": \"precomp0\", \"nm\": \"Precomp\", \"layers\": []}], \"layers\": [{\"nm\": \"Layer\", \"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"nm\": \"Transform\", \"a\": {\"k\": [256, 256], \"a\": 0}, \"p\": {\"k\": [256, 256], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"nm\": \"Rotation\", \"ix\": 123, \"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"i\": {\"x\": [1], \"y\": [1]}, \"o\": {\"x\": [1], \"y\": [1]}}, {\"t\": 180, \"s\": [360]}]}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 180, \"st\": 0, \"bm\": 0, \"ind\": 0, \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ks.p.x = data[\"Position Expression\"];this.json_viewer_contents = lottie.layers[0].ks.p; }, {} ); As a function As a function a composition object can give you access to the layers by name or index Position Expression var $bm_rt = [256, 256] var rotation = thisComp(\"Layer\").transform.rotation / 180 * Math.PI; $bm_rt[0] += Math.cos(rotation) * 200; $bm_rt[1] += Math.sin(rotation) * 200; var $bm_rt = [256, 256] var rotation = thisComp(\"Layer\").transform.rotation / 180 * Math.PI; $bm_rt[0] += Math.cos(rotation) * 200; $bm_rt[1] += Math.sin(rotation) * 200; Show JSON var lottie_player_20 = new PlaygroundPlayer( 20, 'playground_20_2', 'lottie_target_20', {\"v\": \"5.5.2\", \"nm\": \"Animation\", \"fr\": 60, \"ip\": 0, \"op\": 180, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}, {\"id\": \"precomp0\", \"nm\": \"Precomp\", \"layers\": []}], \"layers\": [{\"nm\": \"Layer\", \"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"nm\": \"Transform\", \"a\": {\"k\": [256, 256], \"a\": 0}, \"p\": {\"k\": [256, 256], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"nm\": \"Rotation\", \"ix\": 123, \"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"i\": {\"x\": [1], \"y\": [1]}, \"o\": {\"x\": [1], \"y\": [1]}}, {\"t\": 180, \"s\": [360]}]}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 180, \"st\": 0, \"bm\": 0, \"ind\": 0, \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ks.p.x = data[\"Position Expression\"];this.json_viewer_contents = lottie.layers[0].ks.p; }, {} ); Composition.numLayers Name numLayers Type number Description Number of layers in the composition Composition.width Name width Type number Description Width of the composition, same as w in the JSON Composition.height Name height Type number Description Height of the composition, same as h in the JSON Composition.displayStartTime Name displayStartTime Type number Description Start time of the composition, in seconds. Similar to ip in the JSON but converted into seconds Composition.frameDuration Name frameDuration Type number Description Duration of a frame in second, reciprocal of frames per second Composition.pixelAspect Name pixelAspect Type number Description Pixel aspect ratio, generally 1 Composition.layer() Synopsis layer ( layer: number|string ): Layer Returns the given layer Parameters Name Type Default Description layer number | string Layer name or index Return Type Layer Layer Layer object. Note that it also has all the attributes from Transform . Layer.index Name index Type number Description Layer index, same as ind in the JSON Layer.inPoint Name inPoint Type number Description Same as ip in the JSON but in seconds Layer.outPoint Name outPoint Type number Description Same as op in the JSON but in seconds Layer.startTime Name startTime Type number Description Same as st in the JSON but in seconds Layer.transform Transform attributes can also be accessed from the layer object directly Name transofrm Type Transform Description Layer.source Name source Type string Description For layers referencing an asset, the id of that asses. (Same as refId in the JSON) Layer.width Name width Type number Description Same as Layer.sourceRectAtTime().width Layer.height Name height Type number Description Same as Layer.sourceRectAtTime().height Layer.hasParent Name hasParent Type boolean Description Whether the layer has a parent Layer.parent Name parent Type Layer Description Parent layer Layer.sourceRectAtTime Synopsis sourceRectAtTime (): object Return Type object Description Object with these attributes Layer.effect Synopsis effect ( effect: number|string ): Effect Returns the given effect Parameters Name Type Default Description effect number | string Name or index Return Type Effect Layer.contents Synopsis contents ( shape: number|string ): Shape For shape layers, returns the given shape Parameters Name Type Default Description shape number | string Name or index Return Type Shape Layer space transforms These methods convert between coordinates systems within a layer. Some of these functions have a Vec suffix, which means they should be used for difference between points (the version without this suffix is for points). Layer.toComp Synopsis toComp ( point: Array time: number = time ): Array Maps a point from Layer coordinates to composition coordinates Parameters Name Type Default Description point Array Point time number time Time Return Type Array Layer.fromComp Synopsis toComp ( point: Array time: number = time ): Array Maps a point from composition coordinates to Layer coordinates Parameters Name Type Default Description point Array Point time number time Time Return Type Array Layer.toCompVec Synopsis toComp ( point: Array time: number = time ): Array Maps a vector from Layer coordinates to composition coordinates Parameters Name Type Default Description point Array Vector time number time Time Return Type Array Layer.fromCompVec Synopsis toComp ( point: Array time: number = time ): Array Maps a vector from composition coordinates to Layer coordinates Parameters Name Type Default Description point Array Vector time number time Time Return Type Array Layer.toWorld Synopsis toWorld ( point: Array time: number = time ): Array Maps a point from Layer coordinates to world coordinates Parameters Name Type Default Description point Array Point time number time Time Return Type Array Layer.fromWorld Synopsis toWorld ( point: Array time: number = time ): Array Maps a point from world coordinates to Layer coordinates Parameters Name Type Default Description point Array Point time number time Time Return Type Array Layer.toWorldVec Synopsis toWorld ( point: Array time: number = time ): Array Maps a vector from Layer coordinates to world coordinates Parameters Name Type Default Description point Array Vector time number time Time Return Type Array Layer.fromWorldVec Synopsis toWorld ( point: Array time: number = time ): Array Maps a vector from world coordinates to Layer coordinates Parameters Name Type Default Description point Array Vector time number time Time Return Type Array Transform Name anchorPoint Type array[2] Description Value of a Name position Type array[2] Description Value of p Name scale Type number Description Value of s Name rotation Type number Description Value of r Name opacity Type number Description Value of o Name skew Type number Description Value of sk Name skewAxis Type number Description Value of sa Effect Name active Type boolean Description Whether the effect is active Effect() Synopsis ( property: number|string ): number|Array Returns the value for the given property of the effect Parameters Name Type Default Description property number | string Name or index of the property Return Type number | Array","title":"Expressions"},{"location":"expressions/#expressions","text":"Properties can have expressions associated with them, when this is the case the value of such properties can be modified by using the expression. The expression language is based on JavaScript / ECMAScript. For the most part it uses what is described in the After Effects expressions. More resources on AE expressions: Expression Language Reference After Effects Expression Reference","title":"Expressions"},{"location":"expressions/#global-objects","text":"","title":"Global objects"},{"location":"expressions/#bm_rt","text":"Name $bm_rt Type Depends on the property Description Output value for the expression Notes Must be declared and be assigned a value in every expression The special variable $bm_rt is used to determine the value of the expression. This variable must be declared by the expression and must have a value compatible with the property; var $bm_rt; $bm_rt = 60; Rotation Expression var $bm_rt = 60; var $bm_rt = 60; Position Expression var $bm_rt = [256, 256]; var $bm_rt = [256, 256]; Show JSON var lottie_player_16 = new PlaygroundPlayer( 16, 'playground_16_3', 'lottie_target_16', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"nm\": \"foo\", \"mn\": \"bar\", \"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [256, 256], \"a\": 0}, \"p\": {\"k\": [256, 256], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ks.r.x = data[\"Rotation Expression\"]; lottie.layers[0].ks.p.x = data[\"Position Expression\"];this.json_viewer_contents = lottie.layers[0].ks; }, {} );","title":"$bm_rt"},{"location":"expressions/#time","text":"Name time Type number Description The current time within the composition in seconds Notes Read only Rotation Expression var $bm_rt = time * 360; var $bm_rt = time * 360; Show JSON var lottie_player_17 = new PlaygroundPlayer( 17, 'playground_17_2', 'lottie_target_17', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"nm\": \"foo\", \"mn\": \"bar\", \"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [256, 256], \"a\": 0}, \"p\": {\"k\": [256, 256], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ks.r.x = data[\"Rotation Expression\"];this.json_viewer_contents = lottie.layers[0].ks.r; }, {} );","title":"time"},{"location":"expressions/#value","text":"Name value Type Depends on the property Description The value the property would have without expressions Notes Read only Position Expression var $bm_rt = []; $bm_rt[0] = value[0] + Math.cos(2 * Math.PI * time) * 100; $bm_rt[1] = value[1]; var $bm_rt = []; $bm_rt[0] = value[0] + Math.cos(2 * Math.PI * time) * 100; $bm_rt[1] = value[1]; Show JSON var lottie_player_18 = new PlaygroundPlayer( 18, 'playground_18_2', 'lottie_target_18', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"nm\": \"foo\", \"mn\": \"bar\", \"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [256, 256], \"a\": 0}, \"p\": {\"k\": [256, 256], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ks.p.x = data[\"Position Expression\"];this.json_viewer_contents = lottie.layers[0].ks.p; }, {} );","title":"value"},{"location":"expressions/#thisproperty","text":"Name thisProperty Type Property Description Property the expression is operating on Notes Read only","title":"thisProperty"},{"location":"expressions/#thiscomp","text":"Name thisComp Type Composition Description Composition the property is in Notes Read only","title":"thisComp"},{"location":"expressions/#thislayer","text":"Name thisLayer Type Layer Description Layer the property is in Notes Read only","title":"thisLayer"},{"location":"expressions/#animation-structure-functions","text":"","title":"Animation Structure functions"},{"location":"expressions/#comp","text":"Synopsis comp ( name: string ): Composition Parameters Name Type Default Description name string Composition name Return Type Composition Description Composition object matching the given name","title":"comp()"},{"location":"expressions/#misc-functions","text":"","title":"Misc Functions"},{"location":"expressions/#posterizetime","text":"Synopsis posterizeTime ( fps: number ) The rest of the expression will only be updated this many times per second Parameters Name Type Default Description fps number Frames per second","title":"posterizeTime()"},{"location":"expressions/#timetoframes","text":"Synopsis timeToFrames ( time: number = time + thisComp.displayStartTime fps: number = 1.0 / thisComp.frameDuration ): number Converts a time in seconds to a number of frames Parameters Name Type Default Description time number time + thisComp.displayStartTime Time in seconds fps number 1.0 / thisComp.frameDuration Frames per second Return Type number Description Number of frames","title":"timeToFrames()"},{"location":"expressions/#framestotime","text":"Synopsis framesToTime ( frames: number fps: number = 1.0 / thisComp.frameDuration ): number Converts a number of frames to a time in seconds Parameters Name Type Default Description frames number Number of frames fps number 1.0 / thisComp.frameDuration Frames per second Return Type number Description Time in seconds","title":"framesToTime()"},{"location":"expressions/#rgbtohsl","text":"Synopsis rgbToHsl ( rgb: array[3]|array[4] ): array[3]|array[4] Parameters Name Type Default Description rgb array[3] | array[4] RGB(A) color, with components in 0, 1 Return Type array[3] | array[4] Description HSL(A) color, with components in 0, 1","title":"rgbToHsl()"},{"location":"expressions/#hsltorgb","text":"Synopsis hslToRgb ( hsl: array[3]|array[4] ): array[3]|array[4] Parameters Name Type Default Description hsl array[3] | array[4] HSL(A) color, with components in 0, 1 Return Type array[3] | array[4] Description RGB(A) color, with components in 0, 1","title":"hslToRgb()"},{"location":"expressions/#createpath","text":"Synopsis createPath ( points: array in_tangents: array = [] out_tangents: array = [] is_closed: boolean = true ): Path Creates bezier path data Parameters Name Type Default Description points array Array of points (each point is a list with 2 numbers) in_tangents array [] Array of in tangents correponding to the point with the same index out_tangents array [] Array of out tangents correponding to the point with the same index is_closed boolean true Whether the path is closed Return Type Path","title":"createPath()"},{"location":"expressions/#math-functions","text":"","title":"Math functions"},{"location":"expressions/#add","text":"Synopsis add ( a: any b: any ): any Parameters Name Type Default Description a any b any Return Type any If a and b are numbers, it will return their sum. If they string, their concatenation. If they are vectors, their element-wise sum. If one is a vector and the other a number, it will return the sum of the number by the first element of the vector. This function is also available as $bm_sum and sum .","title":"add()"},{"location":"expressions/#sub","text":"Synopsis sub ( a: any b: any ): any Parameters Name Type Default Description a any b any Return Type any If a and b are numbers, or can be converted to numbers, it will return their difference. If they are vectors, their element-wise difference. This function is also avilable as $bm_sub .","title":"sub()"},{"location":"expressions/#mul","text":"Synopsis mul ( a: any b: any ): any Parameters Name Type Default Description a any b any Return Type any If a and b are numbers, or can be converted to numbers, it will return their product. If one of them is a vector and the other a number, it will return a vector with each element multiplied by the number. This function is also avilable as $bm_mul .","title":"mul()"},{"location":"expressions/#div","text":"Synopsis div ( a: any b: any ): any Parameters Name Type Default Description a any b any Return Type any If a and b are numbers, or can be converted to numbers, it will return their division. If one of them is a vector and the other a number, it will return a vector with each element divided by the number. This function is also avilable as $bm_div .","title":"div()"},{"location":"expressions/#mod","text":"Synopsis mod ( a: any b: any ): any Parameters Name Type Default Description a any b any Return Type any","title":"mod()"},{"location":"expressions/#clamp","text":"Synopsis clamp ( value: number minimum: number maximum: number ): number Clamps a value inside a range Parameters Name Type Default Description value number The value to clamp minimum number Minimum value maximum number Maximum value Return Type number","title":"clamp()"},{"location":"expressions/#normalize","text":"Synopsis normalize ( vector: array ): number Divides a vector by its length Parameters Name Type Default Description vector array Return Type number Description same as div(vector, length(vector))","title":"normalize()"},{"location":"expressions/#length","text":"Synopsis length ( vector: array ): number Parameters Name Type Default Description vector array Return Type number Description length of vector Synopsis length ( a: array b: array ): number Parameters Name Type Default Description a array b array Return Type number Description Distance between a and b .","title":"length()"},{"location":"expressions/#looat","text":"Synopsis lookAt ( from_point: array[3] to_point: array[3] ): number Parameters Name Type Default Description from_point array[3] to_point array[3] Return Type number Description length of vector","title":"looAt()"},{"location":"expressions/#seedrandom","text":"Synopsis seedRandom ( seed: number ) Sets the seed for random functions Parameters Name Type Default Description seed number","title":"seedRandom()"},{"location":"expressions/#random","text":"Synopsis random (): number Return Type number Description Random number between 0 and 1 Synopsis random ( max: number|array ): number|array Parameters Name Type Default Description max number | array Return Type number | array Description Random number between 0 and max , element wise if the argument is an array Synopsis random ( min: number|array max: number|array ): number|array Parameters Name Type Default Description min number | array max number | array Return Type number | array Description Random number between min and max , element wise if the arguments are arrays","title":"random()"},{"location":"expressions/#linear","text":"Synopsis linear ( t: number value1: number|array value2: number|array ): number|array Parameters Name Type Default Description t number Interpolation factor between 0 and 1 value1 number | array value2 number | array Return Type number | array Description Linear interpolation between value1 and value2 Synopsis linear ( t: number t_min: number t_max: number value1: number|array value2: number|array ): number|array Parameters Name Type Default Description t number Interpolation factor between t_min and t_max t_min number Lower bound for the t range t_max number Lower bound for the t range value1 number | array value2 number | array Return Type number | array Description Linear interpolation between value1 and value2 , t is first normalized inside t_min and t_max","title":"linear()"},{"location":"expressions/#ease","text":"Works the same as linear() but with a smooth cubic interpolation. Synopsis ease ( t: number value1: number|array value2: number|array ): number|array Parameters Name Type Default Description t number Interpolation factor between 0 and 1 value1 number | array value2 number | array Return Type number | array Description Interpolation between value1 and value2 Synopsis ease ( t: number t_min: number t_max: number value1: number|array value2: number|array ): number|array Parameters Name Type Default Description t number Interpolation factor between t_min and t_max t_min number Lower bound for the t range t_max number Lower bound for the t range value1 number | array value2 number | array Return Type number | array Description Interpolation between value1 and value2 , t is first normalized inside t_min and t_max","title":"ease()"},{"location":"expressions/#easein","text":"Interpolation, starts the same as ease() and ends the same as linear() Synopsis easeIn ( t: number value1: number|array value2: number|array ): number|array Parameters Name Type Default Description t number Interpolation factor between 0 and 1 value1 number | array value2 number | array Return Type number | array Description Interpolation between value1 and value2 Synopsis easeIn ( t: number t_min: number t_max: number value1: number|array value2: number|array ): number|array Parameters Name Type Default Description t number Interpolation factor between t_min and t_max t_min number Lower bound for the t range t_max number Lower bound for the t range value1 number | array value2 number | array Return Type number | array Description Interpolation between value1 and value2 , t is first normalized inside t_min and t_max","title":"easeIn()"},{"location":"expressions/#easeout","text":"Interpolation, starts the same as linear() and ends the same as ease() Synopsis easeOut ( t: number value1: number|array value2: number|array ): number|array Parameters Name Type Default Description t number Interpolation factor between 0 and 1 value1 number | array value2 number | array Return Type number | array Description Interpolation between value1 and value2 Synopsis easeOut ( t: number t_min: number t_max: number value1: number|array value2: number|array ): number|array Parameters Name Type Default Description t number Interpolation factor between t_min and t_max t_min number Lower bound for the t range t_max number Lower bound for the t range value1 number | array value2 number | array Return Type number | array Description Interpolation between value1 and value2 , t is first normalized inside t_min and t_max","title":"easeOut()"},{"location":"expressions/#degreestoradians","text":"Synopsis degreesToRadians ( degrees: number ): number Parameters Name Type Default Description degrees number Angle in degrees Return Type number Description Angle in radians","title":"degreesToRadians()"},{"location":"expressions/#radianstodegrees","text":"Synopsis radiansToDegrees ( radians: number ): number Parameters Name Type Default Description radians number Angle in radians Return Type number Description Angle in degrees","title":"radiansToDegrees()"},{"location":"expressions/#property","text":"","title":"Property"},{"location":"expressions/#propertyvalue","text":"Name value Type Depends on the property Description The current value the property Notes Read only","title":"Property.value"},{"location":"expressions/#propertynumkeys","text":"Name numKeys Type number Description Number of keyframes Notes Read only","title":"Property.numKeys"},{"location":"expressions/#propertypropertyindex","text":"Name propertyIndex Type number Description Value of ix in the JSON for this property Notes Read only","title":"Property.propertyIndex"},{"location":"expressions/#propertyvalueattime","text":"Synopsis valueAtTime ( t: number ): any Parameters Name Type Default Description t number Time in seconds Return Type Depends on the property Description The value of the property at the given time (without expressions)","title":"Property.valueAtTime()"},{"location":"expressions/#propertygetvelocityattime","text":"Synopsis getVelocityAtTime ( t: number ): any Parameters Name Type Default Description t number Time in seconds Return Type Depends on the property Description The rate of change for the property, with the same dimensions as the value","title":"Property.getVelocityAtTime()"},{"location":"expressions/#propertygetspeedattime","text":"Synopsis getSpeedAtTime ( t: number ): number Parameters Name Type Default Description t number Time in seconds Return Type number Description The rate of change for the property as a scalar","title":"Property.getSpeedAtTime()"},{"location":"expressions/#propertysmooth","text":"Synopsis smooth ( width: number samples: number ): any Parameters Name Type Default Description width number samples number Return Type Depends on the property","title":"Property.smooth()"},{"location":"expressions/#propertyloopin","text":"Synopsis loopIn ( type: string duration: number wrap: boolean ): any Parameters Name Type Default Description type string duration number wrap boolean Return Type Depends on the property","title":"Property.loopIn()"},{"location":"expressions/#propertyloopout","text":"Synopsis loopOut ( type: string duration: number wrap: boolean ): any Parameters Name Type Default Description type string duration number wrap boolean Return Type Depends on the property","title":"Property.loopOut()"},{"location":"expressions/#composition","text":"Composition object Position Expression var $bm_rt = [256, 256] var rotation = comp(\"Animation\").layer(\"Layer\").transform.rotation / 180 * Math.PI; $bm_rt[0] += Math.cos(rotation) * 200; $bm_rt[1] += Math.sin(rotation) * 200; var $bm_rt = [256, 256] var rotation = comp(\"Animation\").layer(\"Layer\").transform.rotation / 180 * Math.PI; $bm_rt[0] += Math.cos(rotation) * 200; $bm_rt[1] += Math.sin(rotation) * 200; Show JSON var lottie_player_19 = new PlaygroundPlayer( 19, 'playground_19_2', 'lottie_target_19', {\"v\": \"5.5.2\", \"nm\": \"Animation\", \"fr\": 60, \"ip\": 0, \"op\": 180, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}, {\"id\": \"precomp0\", \"nm\": \"Precomp\", \"layers\": []}], \"layers\": [{\"nm\": \"Layer\", \"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"nm\": \"Transform\", \"a\": {\"k\": [256, 256], \"a\": 0}, \"p\": {\"k\": [256, 256], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"nm\": \"Rotation\", \"ix\": 123, \"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"i\": {\"x\": [1], \"y\": [1]}, \"o\": {\"x\": [1], \"y\": [1]}}, {\"t\": 180, \"s\": [360]}]}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 180, \"st\": 0, \"bm\": 0, \"ind\": 0, \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ks.p.x = data[\"Position Expression\"];this.json_viewer_contents = lottie.layers[0].ks.p; }, {} );","title":"Composition"},{"location":"expressions/#as-a-function","text":"As a function a composition object can give you access to the layers by name or index Position Expression var $bm_rt = [256, 256] var rotation = thisComp(\"Layer\").transform.rotation / 180 * Math.PI; $bm_rt[0] += Math.cos(rotation) * 200; $bm_rt[1] += Math.sin(rotation) * 200; var $bm_rt = [256, 256] var rotation = thisComp(\"Layer\").transform.rotation / 180 * Math.PI; $bm_rt[0] += Math.cos(rotation) * 200; $bm_rt[1] += Math.sin(rotation) * 200; Show JSON var lottie_player_20 = new PlaygroundPlayer( 20, 'playground_20_2', 'lottie_target_20', {\"v\": \"5.5.2\", \"nm\": \"Animation\", \"fr\": 60, \"ip\": 0, \"op\": 180, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}, {\"id\": \"precomp0\", \"nm\": \"Precomp\", \"layers\": []}], \"layers\": [{\"nm\": \"Layer\", \"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"nm\": \"Transform\", \"a\": {\"k\": [256, 256], \"a\": 0}, \"p\": {\"k\": [256, 256], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"nm\": \"Rotation\", \"ix\": 123, \"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"i\": {\"x\": [1], \"y\": [1]}, \"o\": {\"x\": [1], \"y\": [1]}}, {\"t\": 180, \"s\": [360]}]}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 180, \"st\": 0, \"bm\": 0, \"ind\": 0, \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ks.p.x = data[\"Position Expression\"];this.json_viewer_contents = lottie.layers[0].ks.p; }, {} );","title":"As a function"},{"location":"expressions/#compositionnumlayers","text":"Name numLayers Type number Description Number of layers in the composition","title":"Composition.numLayers"},{"location":"expressions/#compositionwidth","text":"Name width Type number Description Width of the composition, same as w in the JSON","title":"Composition.width"},{"location":"expressions/#compositionheight","text":"Name height Type number Description Height of the composition, same as h in the JSON","title":"Composition.height"},{"location":"expressions/#compositiondisplaystarttime","text":"Name displayStartTime Type number Description Start time of the composition, in seconds. Similar to ip in the JSON but converted into seconds","title":"Composition.displayStartTime"},{"location":"expressions/#compositionframeduration","text":"Name frameDuration Type number Description Duration of a frame in second, reciprocal of frames per second","title":"Composition.frameDuration"},{"location":"expressions/#compositionpixelaspect","text":"Name pixelAspect Type number Description Pixel aspect ratio, generally 1","title":"Composition.pixelAspect"},{"location":"expressions/#compositionlayer","text":"Synopsis layer ( layer: number|string ): Layer Returns the given layer Parameters Name Type Default Description layer number | string Layer name or index Return Type Layer","title":"Composition.layer()"},{"location":"expressions/#layer","text":"Layer object. Note that it also has all the attributes from Transform .","title":"Layer"},{"location":"expressions/#layerindex","text":"Name index Type number Description Layer index, same as ind in the JSON","title":"Layer.index"},{"location":"expressions/#layerinpoint","text":"Name inPoint Type number Description Same as ip in the JSON but in seconds","title":"Layer.inPoint"},{"location":"expressions/#layeroutpoint","text":"Name outPoint Type number Description Same as op in the JSON but in seconds","title":"Layer.outPoint"},{"location":"expressions/#layerstarttime","text":"Name startTime Type number Description Same as st in the JSON but in seconds","title":"Layer.startTime"},{"location":"expressions/#layertransform","text":"Transform attributes can also be accessed from the layer object directly Name transofrm Type Transform Description","title":"Layer.transform"},{"location":"expressions/#layersource","text":"Name source Type string Description For layers referencing an asset, the id of that asses. (Same as refId in the JSON)","title":"Layer.source"},{"location":"expressions/#layerwidth","text":"Name width Type number Description Same as Layer.sourceRectAtTime().width","title":"Layer.width"},{"location":"expressions/#layerheight","text":"Name height Type number Description Same as Layer.sourceRectAtTime().height","title":"Layer.height"},{"location":"expressions/#layerhasparent","text":"Name hasParent Type boolean Description Whether the layer has a parent","title":"Layer.hasParent"},{"location":"expressions/#layerparent","text":"Name parent Type Layer Description Parent layer","title":"Layer.parent"},{"location":"expressions/#layersourcerectattime","text":"Synopsis sourceRectAtTime (): object Return Type object Description Object with these attributes","title":"Layer.sourceRectAtTime"},{"location":"expressions/#layereffect","text":"Synopsis effect ( effect: number|string ): Effect Returns the given effect Parameters Name Type Default Description effect number | string Name or index Return Type Effect","title":"Layer.effect"},{"location":"expressions/#layercontents","text":"Synopsis contents ( shape: number|string ): Shape For shape layers, returns the given shape Parameters Name Type Default Description shape number | string Name or index Return Type Shape","title":"Layer.contents"},{"location":"expressions/#layer-space-transforms","text":"These methods convert between coordinates systems within a layer. Some of these functions have a Vec suffix, which means they should be used for difference between points (the version without this suffix is for points).","title":"Layer space transforms"},{"location":"expressions/#layertocomp","text":"Synopsis toComp ( point: Array time: number = time ): Array Maps a point from Layer coordinates to composition coordinates Parameters Name Type Default Description point Array Point time number time Time Return Type Array","title":"Layer.toComp"},{"location":"expressions/#layerfromcomp","text":"Synopsis toComp ( point: Array time: number = time ): Array Maps a point from composition coordinates to Layer coordinates Parameters Name Type Default Description point Array Point time number time Time Return Type Array","title":"Layer.fromComp"},{"location":"expressions/#layertocompvec","text":"Synopsis toComp ( point: Array time: number = time ): Array Maps a vector from Layer coordinates to composition coordinates Parameters Name Type Default Description point Array Vector time number time Time Return Type Array","title":"Layer.toCompVec"},{"location":"expressions/#layerfromcompvec","text":"Synopsis toComp ( point: Array time: number = time ): Array Maps a vector from composition coordinates to Layer coordinates Parameters Name Type Default Description point Array Vector time number time Time Return Type Array","title":"Layer.fromCompVec"},{"location":"expressions/#layertoworld","text":"Synopsis toWorld ( point: Array time: number = time ): Array Maps a point from Layer coordinates to world coordinates Parameters Name Type Default Description point Array Point time number time Time Return Type Array","title":"Layer.toWorld"},{"location":"expressions/#layerfromworld","text":"Synopsis toWorld ( point: Array time: number = time ): Array Maps a point from world coordinates to Layer coordinates Parameters Name Type Default Description point Array Point time number time Time Return Type Array","title":"Layer.fromWorld"},{"location":"expressions/#layertoworldvec","text":"Synopsis toWorld ( point: Array time: number = time ): Array Maps a vector from Layer coordinates to world coordinates Parameters Name Type Default Description point Array Vector time number time Time Return Type Array","title":"Layer.toWorldVec"},{"location":"expressions/#layerfromworldvec","text":"Synopsis toWorld ( point: Array time: number = time ): Array Maps a vector from world coordinates to Layer coordinates Parameters Name Type Default Description point Array Vector time number time Time Return Type Array","title":"Layer.fromWorldVec"},{"location":"expressions/#transform","text":"Name anchorPoint Type array[2] Description Value of a Name position Type array[2] Description Value of p Name scale Type number Description Value of s Name rotation Type number Description Value of r Name opacity Type number Description Value of o Name skew Type number Description Value of sk Name skewAxis Type number Description Value of sa","title":"Transform"},{"location":"expressions/#effect","text":"Name active Type boolean Description Whether the effect is active","title":"Effect"},{"location":"expressions/#effect_1","text":"Synopsis ( property: number|string ): number|Array Returns the value for the given property of the effect Parameters Name Type Default Description property number | string Name or index of the property Return Type number | Array","title":"Effect()"},{"location":"layers/","text":"Layers Layer There are several layer types, which is specified by the ty attribute: ty Layer Type Description 0 Precomposition Renders a Precomposition 1 Solid Color Static rectangle filling the canvas with a single color 2 Image Renders an Image 3 Null (Empty) No contents, only used for parenting 4 Shape Has an array of shapes 5 Text Renders text 6 Audio Plays some audio 7 Video Placeholder 8 Image Sequence 9 Video 10 Image Placeholder 11 Guide 12 Adjustment 13 Camera 3D Camera 14 Light 15 Data Each layer type has its own properties but there are several common properties: Attribute Type Description nm string Name, as seen from editors and the like mn string Match name, used in expressions ddd 0-1 integer Whether the layer is 3D. Lottie doesn't actually support 3D stuff so this should always be 0 hd boolean Whether the layer is hidden ty integer Layer type, must be one of the values seen above ind integer Layer index for parenting parent integer Parent index for parenting sr number Time Stretch ip number Frame when the layer becomes visible op number Frame when the layer becomes invisible st number Start Time tt Matte Mode Matte mode (see mattes ) td 0-1 integer Matte target (see mattes ) masksProperties array of Mask Masks for the layer ef array of Custom Effect or Drop Shadow Effect or Fill Effect or Gaussian Blur Effect or Set Matte Effect or Pro Levels Effect or Stroke Effect or Tint Effect or Tritone Effect or Radial Wipe or Wavy Effect or Puppet Effect or Spherize Effect or Mesh Warp Effect or Displacement Map Effect or Twirl Effect Effects for the layer sy array of Layer Stroke or Drop Shadow or Inner Shadow or Outer Glow or Inner Glow or Bevel Emboss or Satin or Color Overlay or Gradient Overlay Layer styles ks Transform Layer transform ao 0-1 integer If 1, The layer will rotate itself to match its animated position path tp integer Index of the layer used as matte, if omitted assume the layer above the current one hasMask boolean Whether the layer has masks applied mb boolean Whether motion blur is enabled for the layer bm Blend Mode Blend Mode cl string CSS class used by the SVG renderer ln string id attribute used by the SVG renderer tg string tag name used by the SVG renderer cp boolean This is deprecated in favour of ct ct 0-1 integer Marks that transforms should be applied before masks Note that layers that don't have a visual component (Audio layers for example), won't have a transform and similar. The layer is only visible between its ip and op . If they match the corresponding attributes in Animation , the layer will be visible the whole time, otherwise it will become visible at the frame ip and disappear at op . Parenting Within a list of layers, the ind attribute (if present) must be unique. Layers having a parent attribute matching another layer will inherit their parent's transform (except for opacity). Basically you need multiply the transform matrix by the parent's transform matrix to get a child layer's final transform. The flat layer structure and flexible parenting allows more flexibility but it's different from the more traditional approach of nesting child layers inside the parent layer (like a folder structure). One of the advantages of flexible parenting is you can have children of the same layer be intermixed with unrelated layers. In the following example, the star and the ellipse are in separate layers, but both have the same parent, which moves left and right. Between the two there's an additional layer with the rectangle. var lottie_player_28 = new LottiePlayer( 'lottie_target_28', '../examples/parenting.json', true, {} ); Auto Orient When true, if the transform position is animated, it rotates the layer along the path the position follows. In the following example there are two arrows animated along the same path, with no rotation when the position moves towards the right. The transparent one keeps its rotation the same ( ao is 0), while the solid one follows the path ( ao is 1). var lottie_player_29 = new LottiePlayer( 'lottie_target_29', '../examples/auto_orient.json', true, {} ); Mattes A matte allows using a layer as a mask for another layer. The way it works is the layer defining the mask has a tt attribute with the appropriate value . By defaults it affects the layer on top (the layer before it in the layer list, which has the td attribute), otherwise check the tp attribute. In this example there's a layer with a rectangle and a star being masked by an ellipse: Matte Mode Normal Alpha Inverted Alpha Luma Inverted Luma Show JSON var lottie_player_21 = new PlaygroundPlayer( 21, 'playground_21_2', 'lottie_target_21', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{b3d1b083-9de7-4537-a691-fc9aa42f9742}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 1, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Ellipse (Mask)\", \"ks\": {\"a\": {\"a\": 0, \"k\": [153, 294]}, \"p\": {\"a\": 0, \"k\": [346, 211]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{261eddeb-af92-4be1-932c-790b00c23933}\", \"p\": {\"a\": 0, \"k\": [137.0955223880597, 293.60820895522386]}, \"s\": {\"a\": 0, \"k\": [303.42089552238804, 315.55074626865667]}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{aa9c282c-253d-4d8d-ab05-4819c592fa85}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 1, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 6}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{2b2b0002-ff0c-4978-a33b-db4e0498848d}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.9411764705882353, 0.11372549019607843, 0.0392156862745098]}, \"r\": 1}], \"td\": 1}, {\"ddd\": 0, \"ty\": 4, \"ind\": 2, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Shapes (Masked)\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{528994b7-40ff-4d12-81f8-603f274da12e}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{ce8756d7-289f-4f84-a135-d225d57c42e0}\", \"p\": {\"a\": 0, \"k\": [427.2716417910448, 194.29253731343283]}, \"or\": {\"a\": 0, \"k\": 216.4160919189453}, \"ir\": {\"a\": 0, \"k\": 87.03440856933594}, \"r\": {\"a\": 0, \"k\": 261.54803466796875}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{efd05a25-a43b-451d-83d2-53a477087223}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5019607843137255, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{523ca39c-9e57-4547-bf0e-ba7496003579}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [427.2716417910448, 194.29253731343283]}, \"p\": {\"a\": 0, \"k\": [338.7223880597015, 209.76716417910447]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"gr\", \"nm\": \"Rectangle\", \"mn\": \"{d2d7a5d5-6d91-42e8-b40a-af52a112fe38}\", \"it\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"mn\": \"{9ef8604e-7891-4909-a655-445131b4d842}\", \"p\": {\"a\": 0, \"k\": [209.17611940298502, 226.8]}, \"s\": {\"a\": 0, \"k\": [363.3313432835821, 369.3492537313433]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{444584d2-cb59-4cba-83a1-82cc605837fd}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5019607843137255, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{f75aed67-9b0e-41a9-b859-a14b5b0a320d}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.7686274509803922, 0.8509803921568627, 0.9607843137254902]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [256.1910447761194, 273.8149253731343]}, \"p\": {\"a\": 0, \"k\": [256.1910447761194, 273.8149253731343]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}], \"tt\": 1, \"tp\": 1}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { lottie.layers[1].tt = Number(data[\"Matte Mode\"]);this.json_viewer_contents = [{ ...lottie.layers[0], ks: \"...\", shapes: \"...\" }, { ...lottie.layers[1], ks: \"...\", shapes: \"...\" }] ; }, {} ); Masks A layer can have an array of masks that clip the contents of the layer to a shape. This is similar to mattes , but there are a few differences. With mattes, you use a layer to define the clipping area, while with masks you use an animated bezier curve . Attribute Type Description nm string Name, as seen from editors and the like mn string Match name, used in expressions inv boolean Inverted pt Animated Bezier Shape o Animated number Opacity mode Mask Mode Mode x Animated number Expand Mode None Add Subtract Intersect Lighten Darken Difference Opacity 100 Invert Expand 0 Show JSON var lottie_player_22 = new PlaygroundPlayer( 22, 'playground_22_5', 'lottie_target_22', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{b3d1b083-9de7-4537-a691-fc9aa42f9742}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 2, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Shapes\", \"ks\": {}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{528994b7-40ff-4d12-81f8-603f274da12e}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{ce8756d7-289f-4f84-a135-d225d57c42e0}\", \"p\": {\"a\": 0, \"k\": [427.2716417910448, 194.29253731343283]}, \"or\": {\"a\": 0, \"k\": 216.4160919189453}, \"ir\": {\"a\": 0, \"k\": 87.03440856933594}, \"r\": {\"a\": 0, \"k\": 261.54803466796875}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{efd05a25-a43b-451d-83d2-53a477087223}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5019607843137255, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{523ca39c-9e57-4547-bf0e-ba7496003579}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [427.2716417910448, 194.29253731343283]}, \"p\": {\"a\": 0, \"k\": [338.7223880597015, 209.76716417910447]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"gr\", \"nm\": \"Rectangle\", \"mn\": \"{d2d7a5d5-6d91-42e8-b40a-af52a112fe38}\", \"it\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"mn\": \"{9ef8604e-7891-4909-a655-445131b4d842}\", \"p\": {\"a\": 0, \"k\": [209.17611940298502, 226.8]}, \"s\": {\"a\": 0, \"k\": [363.3313432835821, 369.3492537313433]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{444584d2-cb59-4cba-83a1-82cc605837fd}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5019607843137255, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{f75aed67-9b0e-41a9-b859-a14b5b0a320d}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.7686274509803922, 0.8509803921568627, 0.9607843137254902]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [256.1910447761194, 273.8149253731343]}, \"p\": {\"a\": 0, \"k\": [256.1910447761194, 273.8149253731343]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}], \"hasMask\": true, \"masksProperties\": [{\"mode\": \"a\", \"o\": {\"a\": 0, \"k\": 100}, \"inv\": false, \"x\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [[247.109, 125.719], [66.109, 306.719], [424.109, 389.719]], \"i\": [[0, 0], [0, 0], [0, 0]], \"o\": [[0, 0], [0, 0], [0, 0]]}}}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { let mask = lottie.layers[0].masksProperties[0]; mask.o.k = Number(data[\"Opacity\"]); mask.inv = data[\"Invert\"]; mask.x.k = Number(data[\"Expand\"]); mask.mode = data[\"Mode\"];this.json_viewer_contents = lottie.layers[0].masksProperties[0]; }, {} ); Shape Layer Renders vector data. The only special property for this layer is shapes , an array of shapes . Also has the attributes from Visual Layer . Attribute Type Description ty integer = 4 Layer type shapes Shape List Shapes Precomposition Layer This layer renders a precomposition . You can find more details in the Precompositions page. Also has the attributes from Visual Layer . Attribute Type Description ty integer = 0 Layer type refId string ID of the precomp as specified in the assets w integer Width of the clipping rect h integer Height of the clipping rect tm Animated number Time Remapping Time remapping The tm property maps the time in seconds of the precomposition to show. Basically you get the value of tm at the current frame, then assume that's a time in seconds since the start of the animation, and render the corresponding frame of the precomposition. Follows an example of this, here there are two layers showing the same precomposition, the one at the top right keeps the original time while the bottom one remaps time as follows: frame 0 (0s) maps to 0s (frame 0) in the precomp frame 30 (0.5s) maps to 3s (frame 180) in the precomp frame 60 (1s) maps to 1.5s (frame 90) in the precomp frame 180 (3s) maps to 3s (frame 180) in the precomp Basically it makes the precomp play in the first half second, then rewind to half way for the next half second, and plays back to the end for the remaining 2 seconds. Show JSON var lottie_player_23 = new PlaygroundPlayer( 23, 'playground_23_1', 'lottie_target_23', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{7820523d-dd32-453b-b311-50323a49e4df}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [{\"nm\": \"Composition\", \"mn\": \"{4d838004-a221-48cb-966f-399347c5acb8}\", \"id\": \"{4d838004-a221-48cb-966f-399347c5acb8}\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer 1\", \"mn\": \"{8afc4794-97eb-4533-814b-f92676e324f5}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar 1\", \"mn\": \"{600eb536-73f0-415d-8743-01dd2f26e2b7}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar 1\", \"mn\": \"{0d81b309-da59-4646-812d-ed9212679e27}\", \"p\": {\"a\": 0, \"k\": [166.49999999999997, 144.89999999999998]}, \"or\": {\"a\": 0, \"k\": 103.60950469970703}, \"ir\": {\"a\": 0, \"k\": 51.804752349853516}, \"r\": {\"a\": 0, \"k\": 147.41429138183594}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{5271148f-841e-4e99-9f23-e0b201b46def}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5019607843137255, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{c72fab9f-6a71-4e30-966c-1b863389d19a}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [166.49999999999997, 144.89999999999998]}, \"p\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [106.19999999999997, 126.89999999999998], \"h\": 0, \"o\": {\"x\": [0.3333333333333333], \"y\": [0]}, \"i\": {\"x\": [0.6666666666666666], \"y\": [1]}, \"e\": [413.99999999999994, 413.09999999999997]}, {\"t\": 180, \"s\": [413.99999999999994, 413.09999999999997]}]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}]}], \"layers\": [{\"ty\": 0, \"ddd\": 0, \"nm\": \"Composition\", \"mn\": \"{e3aa5446-47d2-454e-8d20-ed3c5f15612e}\", \"ip\": 0, \"op\": 180, \"ind\": 2, \"st\": 0, \"sr\": 1, \"ks\": {\"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [50, 50]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"refId\": \"{4d838004-a221-48cb-966f-399347c5acb8}\", \"w\": 512, \"h\": 512}, {\"ty\": 0, \"ddd\": 0, \"nm\": \"Remapped\", \"mn\": \"{0f7b917c-b0e8-450f-bb63-812dff786620}\", \"ip\": 0, \"op\": 180, \"ind\": 1, \"st\": 0, \"sr\": 1, \"tm\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"o\": {\"x\": 0, \"y\": 0}, \"i\": {\"x\": 1, \"y\": 1}}, {\"t\": 30, \"s\": [3], \"o\": {\"x\": 0, \"y\": 0}, \"i\": {\"x\": 1, \"y\": 1}}, {\"t\": 60, \"s\": [1.5], \"o\": {\"x\": 0, \"y\": 0}, \"i\": {\"x\": 1, \"y\": 1}}, {\"t\": 180, \"s\": [3], \"o\": {\"x\": 0, \"y\": 0}, \"i\": {\"x\": 1, \"y\": 1}}]}, \"ks\": {\"a\": {\"a\": 0, \"k\": [512, 512]}, \"p\": {\"a\": 0, \"k\": [512, 512]}, \"s\": {\"a\": 0, \"k\": [50, 50]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"refId\": \"{4d838004-a221-48cb-966f-399347c5acb8}\", \"w\": 512, \"h\": 512}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { this.json_viewer_contents = {...lottie.layers[1], ks:{}}; }, {} ); Null Layer This layer doesn't have any special properties. It's often used by animators as a parent to multiple other layers (see parenting ). Also has the attributes from Visual Layer . Attribute Type Description ty integer = 3 Layer type Text Layer For text data, please refer to the section about text for details. Also has the attributes from Visual Layer . Attribute Type Description ty integer = 5 Layer type t Text Data Data Image Layer This layer renders a static image . Also has the attributes from Visual Layer . Attribute Type Description ty integer = 2 Layer type refId string ID of the image as specified in the assets Solid Color Layer This layer represents a rectangle with a single color. Anything you can do with solid layers, you can do better with a shape layer and a rectangle shape since none of this layer's own properties can be animated. Note that the color is represented as a string, unlike most other places. Also has the attributes from Visual Layer . Attribute Type Description ty integer = 1 Layer type sc string Color of the layer, unlike most other places, the color is a #rrggbb hex string sh number Height sw number Width Color Width 512 Height 512 Show JSON var lottie_player_24 = new PlaygroundPlayer( 24, 'playground_24_4', 'lottie_target_24', {\"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"layers\": [{\"ty\": 1, \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": {}, \"sc\": \"#ff0000\", \"sh\": 512, \"sw\": 512}]}, function (lottie, data) { lottie.layers[0].sc = data[\"Color\"]; lottie.layers[0].sw = Number(data[\"Width\"]); lottie.layers[0].sh = Number(data[\"Height\"]);this.json_viewer_contents = lottie.layers[0]; }, {} ); Audio Layer This layer plays a sound . Also has the attributes from Layer . Attribute Type Description ty integer = 6 Layer type au Audio Settings Audio Settings refId string ID of the sound as specified in the assets Audio Settings Attribute Type Description lv Animated Vector Level 3D Layers Layers can have 3D transforms as well: var lottie_player_30 = new LottiePlayer( 'lottie_target_30', '../examples/3d_layers_animation.json', true, {renderer: \"html\"} ); 3D layers need to have the ddd set to 1 (and so does the top-level object). Their transform will habe a and p specified as 3D components. Rotation will be split into 3 properties: rx , ry , rz , and you have and additional orientation property or . Anchor X 0 Y 0 Z 0 Position X 256 Y 256 Z 0 Rotation X 0 Y 30 Z 0 Orientation X 0 Y 0 Z 0 Scale X 100 Y 100 Z 100 Show JSON var lottie_player_25 = new PlaygroundPlayer( 25, 'playground_25_16', 'lottie_target_25', {\"v\": \"5.9.2\", \"fr\": 60, \"ip\": 0, \"op\": 120, \"w\": 512, \"h\": 512, \"nm\": \"3d layers\", \"ddd\": 1, \"layers\": [{\"ddd\": 1, \"ind\": 2, \"ty\": 4, \"nm\": \"Blue Circle\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 0}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [256, 256, 0]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"el\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0.196, 0.314, 0.69]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ind\": 2, \"ty\": 4, \"nm\": \"Yellow Square\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 30}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [256, 256, 0]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [1, 1, 0.3]}, \"o\": {\"a\": 0, \"k\": 100}}]}]}, function (lottie, data) { lottie.layers[1].ks.a.k = [ data[\"ax\"], data[\"ay\"], data[\"az\"] ]; lottie.layers[1].ks.p.k = [ data[\"px\"], data[\"py\"], data[\"pz\"] ]; lottie.layers[1].ks.or.k = [ data[\"orx\"], data[\"ory\"], data[\"orz\"] ]; lottie.layers[1].ks.s.k = [ data[\"sx\"], data[\"sy\"], data[\"sz\"] ]; lottie.layers[1].ks.rx.k = data[\"rx\"]; lottie.layers[1].ks.ry.k = data[\"ry\"]; lottie.layers[1].ks.rz.k = data[\"rz\"];this.json_viewer_contents = lottie.layers[1].ks; }, {renderer: \"html\"} ); Camera Layer Camera for 3D layers. Also has the attributes from Layer . Attribute Type Description ty integer = 13 Layer type ks Transform Layer transform pe Animated number Distance from the Z=0 plane. Small values yield a higher perspective effect. Perspective 256 Position X 0 Y 0 Z -10 Rotation X 0 Y 0 Z 0 Orientation X 0 Y 0 Z 0 Show JSON var lottie_player_26 = new PlaygroundPlayer( 26, 'playground_26_11', 'lottie_target_26', {\"v\": \"5.9.2\", \"fr\": 60, \"ip\": 0, \"op\": 120, \"w\": 512, \"h\": 512, \"nm\": \"3d layers\", \"ddd\": 1, \"layers\": [{\"ddd\": 1, \"ty\": 13, \"nm\": \"Camera\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 0}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0, -10]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"pe\": {\"a\": 0, \"k\": 256}}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Page\", \"ks\": {\"o\": {\"a\": 0, \"k\": 50}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 0}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0, 0]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [1, 1, 1]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall Front\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 0}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0, 200]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0.5, 0.5, 1]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall FR\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 45}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [141, 0, 141]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [1, 0.5, 1]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall FL\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": -45}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [-141, 0, 141]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0, 0.5, 1]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall Left\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": -90}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [-200, 0, 0]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0, 0.5, 0.5]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall Right\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 90}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [200, 0, 0]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [1, 0.5, 0.5]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall BR\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": -45}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [141, 0, -141]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [1, 0.5, 0]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall BL\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 45}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [-141, 0, -141]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0, 0.5, 0]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall Back\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 0}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0, -200]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0.5, 0.5, 0]}, \"o\": {\"a\": 0, \"k\": 100}}]}]}, function (lottie, data) { var index = 0; lottie.layers[index].ks.p.k = [ data[\"px\"], data[\"py\"], data[\"pz\"] ]; lottie.layers[index].ks.or.k = [ data[\"orx\"], data[\"ory\"], data[\"orz\"] ]; lottie.layers[index].ks.rx.k = data[\"rx\"]; lottie.layers[index].ks.ry.k = data[\"ry\"]; lottie.layers[index].ks.rz.k = data[\"rz\"]; lottie.layers[index].pe.k = data[\"Perspective\"];this.json_viewer_contents = lottie.layers[0]; }, {renderer: \"html\"} ); 3D Parenting As with 2D layers, you can parent 3D layers. Position X 0 Y 0 Z -10 Rotation X 0 Y 0 Z 0 Orientation X 0 Y 0 Z 0 Show JSON var lottie_player_27 = new PlaygroundPlayer( 27, 'playground_27_10', 'lottie_target_27', {\"v\": \"5.9.2\", \"fr\": 60, \"ip\": 0, \"op\": 120, \"w\": 512, \"h\": 512, \"nm\": \"3d layers\", \"ddd\": 1, \"layers\": [{\"ddd\": 1, \"ty\": 13, \"nm\": \"Camera\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 0}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0, -10]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"pe\": {\"a\": 0, \"k\": 256}}, {\"ddd\": 1, \"ty\": 4, \"ind\": 1, \"nm\": \"Parent\", \"ks\": {\"o\": {\"a\": 0, \"k\": 50}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 0}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0, 0]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [1, 1, 1]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall Front\", \"parent\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 0}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0, 200]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0.5, 0.5, 1]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall FR\", \"parent\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 45}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [141, 0, 141]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [1, 0.5, 1]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall FL\", \"parent\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": -45}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [-141, 0, 141]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0, 0.5, 1]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall Left\", \"parent\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": -90}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [-200, 0, 0]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0, 0.5, 0.5]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall Right\", \"parent\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 90}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [200, 0, 0]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [1, 0.5, 0.5]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall BR\", \"parent\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": -45}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [141, 0, -141]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [1, 0.5, 0]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall BL\", \"parent\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 45}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [-141, 0, -141]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0, 0.5, 0]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall Back\", \"parent\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 0}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0, -200]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0.5, 0.5, 0]}, \"o\": {\"a\": 0, \"k\": 100}}]}]}, function (lottie, data) { var index = 1; lottie.layers[index].ks.p.k = [ data[\"px\"], data[\"py\"], data[\"pz\"] ]; lottie.layers[index].ks.or.k = [ data[\"orx\"], data[\"ory\"], data[\"orz\"] ]; lottie.layers[index].ks.rx.k = data[\"rx\"]; lottie.layers[index].ks.ry.k = data[\"ry\"]; lottie.layers[index].ks.rz.k = data[\"rz\"];this.json_viewer_contents = lottie.layers[1]; }, {renderer: \"html\"} ); Data Layer This layer links to a data source . Also has the attributes from Layer . Attribute Type Description ty integer = 15 Layer type refId string ID of the data source in assets","title":"Layers"},{"location":"layers/#layers","text":"","title":"Layers"},{"location":"layers/#layer","text":"There are several layer types, which is specified by the ty attribute: ty Layer Type Description 0 Precomposition Renders a Precomposition 1 Solid Color Static rectangle filling the canvas with a single color 2 Image Renders an Image 3 Null (Empty) No contents, only used for parenting 4 Shape Has an array of shapes 5 Text Renders text 6 Audio Plays some audio 7 Video Placeholder 8 Image Sequence 9 Video 10 Image Placeholder 11 Guide 12 Adjustment 13 Camera 3D Camera 14 Light 15 Data Each layer type has its own properties but there are several common properties: Attribute Type Description nm string Name, as seen from editors and the like mn string Match name, used in expressions ddd 0-1 integer Whether the layer is 3D. Lottie doesn't actually support 3D stuff so this should always be 0 hd boolean Whether the layer is hidden ty integer Layer type, must be one of the values seen above ind integer Layer index for parenting parent integer Parent index for parenting sr number Time Stretch ip number Frame when the layer becomes visible op number Frame when the layer becomes invisible st number Start Time tt Matte Mode Matte mode (see mattes ) td 0-1 integer Matte target (see mattes ) masksProperties array of Mask Masks for the layer ef array of Custom Effect or Drop Shadow Effect or Fill Effect or Gaussian Blur Effect or Set Matte Effect or Pro Levels Effect or Stroke Effect or Tint Effect or Tritone Effect or Radial Wipe or Wavy Effect or Puppet Effect or Spherize Effect or Mesh Warp Effect or Displacement Map Effect or Twirl Effect Effects for the layer sy array of Layer Stroke or Drop Shadow or Inner Shadow or Outer Glow or Inner Glow or Bevel Emboss or Satin or Color Overlay or Gradient Overlay Layer styles ks Transform Layer transform ao 0-1 integer If 1, The layer will rotate itself to match its animated position path tp integer Index of the layer used as matte, if omitted assume the layer above the current one hasMask boolean Whether the layer has masks applied mb boolean Whether motion blur is enabled for the layer bm Blend Mode Blend Mode cl string CSS class used by the SVG renderer ln string id attribute used by the SVG renderer tg string tag name used by the SVG renderer cp boolean This is deprecated in favour of ct ct 0-1 integer Marks that transforms should be applied before masks Note that layers that don't have a visual component (Audio layers for example), won't have a transform and similar. The layer is only visible between its ip and op . If they match the corresponding attributes in Animation , the layer will be visible the whole time, otherwise it will become visible at the frame ip and disappear at op .","title":"Layer"},{"location":"layers/#parenting","text":"Within a list of layers, the ind attribute (if present) must be unique. Layers having a parent attribute matching another layer will inherit their parent's transform (except for opacity). Basically you need multiply the transform matrix by the parent's transform matrix to get a child layer's final transform. The flat layer structure and flexible parenting allows more flexibility but it's different from the more traditional approach of nesting child layers inside the parent layer (like a folder structure). One of the advantages of flexible parenting is you can have children of the same layer be intermixed with unrelated layers. In the following example, the star and the ellipse are in separate layers, but both have the same parent, which moves left and right. Between the two there's an additional layer with the rectangle. var lottie_player_28 = new LottiePlayer( 'lottie_target_28', '../examples/parenting.json', true, {} );","title":"Parenting"},{"location":"layers/#auto-orient","text":"When true, if the transform position is animated, it rotates the layer along the path the position follows. In the following example there are two arrows animated along the same path, with no rotation when the position moves towards the right. The transparent one keeps its rotation the same ( ao is 0), while the solid one follows the path ( ao is 1). var lottie_player_29 = new LottiePlayer( 'lottie_target_29', '../examples/auto_orient.json', true, {} );","title":"Auto Orient"},{"location":"layers/#mattes","text":"A matte allows using a layer as a mask for another layer. The way it works is the layer defining the mask has a tt attribute with the appropriate value . By defaults it affects the layer on top (the layer before it in the layer list, which has the td attribute), otherwise check the tp attribute. In this example there's a layer with a rectangle and a star being masked by an ellipse: Matte Mode Normal Alpha Inverted Alpha Luma Inverted Luma Show JSON var lottie_player_21 = new PlaygroundPlayer( 21, 'playground_21_2', 'lottie_target_21', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{b3d1b083-9de7-4537-a691-fc9aa42f9742}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 1, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Ellipse (Mask)\", \"ks\": {\"a\": {\"a\": 0, \"k\": [153, 294]}, \"p\": {\"a\": 0, \"k\": [346, 211]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{261eddeb-af92-4be1-932c-790b00c23933}\", \"p\": {\"a\": 0, \"k\": [137.0955223880597, 293.60820895522386]}, \"s\": {\"a\": 0, \"k\": [303.42089552238804, 315.55074626865667]}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{aa9c282c-253d-4d8d-ab05-4819c592fa85}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 1, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 6}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{2b2b0002-ff0c-4978-a33b-db4e0498848d}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.9411764705882353, 0.11372549019607843, 0.0392156862745098]}, \"r\": 1}], \"td\": 1}, {\"ddd\": 0, \"ty\": 4, \"ind\": 2, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Shapes (Masked)\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{528994b7-40ff-4d12-81f8-603f274da12e}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{ce8756d7-289f-4f84-a135-d225d57c42e0}\", \"p\": {\"a\": 0, \"k\": [427.2716417910448, 194.29253731343283]}, \"or\": {\"a\": 0, \"k\": 216.4160919189453}, \"ir\": {\"a\": 0, \"k\": 87.03440856933594}, \"r\": {\"a\": 0, \"k\": 261.54803466796875}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{efd05a25-a43b-451d-83d2-53a477087223}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5019607843137255, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{523ca39c-9e57-4547-bf0e-ba7496003579}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [427.2716417910448, 194.29253731343283]}, \"p\": {\"a\": 0, \"k\": [338.7223880597015, 209.76716417910447]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"gr\", \"nm\": \"Rectangle\", \"mn\": \"{d2d7a5d5-6d91-42e8-b40a-af52a112fe38}\", \"it\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"mn\": \"{9ef8604e-7891-4909-a655-445131b4d842}\", \"p\": {\"a\": 0, \"k\": [209.17611940298502, 226.8]}, \"s\": {\"a\": 0, \"k\": [363.3313432835821, 369.3492537313433]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{444584d2-cb59-4cba-83a1-82cc605837fd}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5019607843137255, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{f75aed67-9b0e-41a9-b859-a14b5b0a320d}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.7686274509803922, 0.8509803921568627, 0.9607843137254902]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [256.1910447761194, 273.8149253731343]}, \"p\": {\"a\": 0, \"k\": [256.1910447761194, 273.8149253731343]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}], \"tt\": 1, \"tp\": 1}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { lottie.layers[1].tt = Number(data[\"Matte Mode\"]);this.json_viewer_contents = [{ ...lottie.layers[0], ks: \"...\", shapes: \"...\" }, { ...lottie.layers[1], ks: \"...\", shapes: \"...\" }] ; }, {} );","title":"Mattes"},{"location":"layers/#masks","text":"A layer can have an array of masks that clip the contents of the layer to a shape. This is similar to mattes , but there are a few differences. With mattes, you use a layer to define the clipping area, while with masks you use an animated bezier curve . Attribute Type Description nm string Name, as seen from editors and the like mn string Match name, used in expressions inv boolean Inverted pt Animated Bezier Shape o Animated number Opacity mode Mask Mode Mode x Animated number Expand Mode None Add Subtract Intersect Lighten Darken Difference Opacity 100 Invert Expand 0 Show JSON var lottie_player_22 = new PlaygroundPlayer( 22, 'playground_22_5', 'lottie_target_22', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{b3d1b083-9de7-4537-a691-fc9aa42f9742}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 2, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Shapes\", \"ks\": {}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{528994b7-40ff-4d12-81f8-603f274da12e}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{ce8756d7-289f-4f84-a135-d225d57c42e0}\", \"p\": {\"a\": 0, \"k\": [427.2716417910448, 194.29253731343283]}, \"or\": {\"a\": 0, \"k\": 216.4160919189453}, \"ir\": {\"a\": 0, \"k\": 87.03440856933594}, \"r\": {\"a\": 0, \"k\": 261.54803466796875}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{efd05a25-a43b-451d-83d2-53a477087223}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5019607843137255, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{523ca39c-9e57-4547-bf0e-ba7496003579}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [427.2716417910448, 194.29253731343283]}, \"p\": {\"a\": 0, \"k\": [338.7223880597015, 209.76716417910447]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"gr\", \"nm\": \"Rectangle\", \"mn\": \"{d2d7a5d5-6d91-42e8-b40a-af52a112fe38}\", \"it\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"mn\": \"{9ef8604e-7891-4909-a655-445131b4d842}\", \"p\": {\"a\": 0, \"k\": [209.17611940298502, 226.8]}, \"s\": {\"a\": 0, \"k\": [363.3313432835821, 369.3492537313433]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{444584d2-cb59-4cba-83a1-82cc605837fd}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5019607843137255, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{f75aed67-9b0e-41a9-b859-a14b5b0a320d}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.7686274509803922, 0.8509803921568627, 0.9607843137254902]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [256.1910447761194, 273.8149253731343]}, \"p\": {\"a\": 0, \"k\": [256.1910447761194, 273.8149253731343]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}], \"hasMask\": true, \"masksProperties\": [{\"mode\": \"a\", \"o\": {\"a\": 0, \"k\": 100}, \"inv\": false, \"x\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [[247.109, 125.719], [66.109, 306.719], [424.109, 389.719]], \"i\": [[0, 0], [0, 0], [0, 0]], \"o\": [[0, 0], [0, 0], [0, 0]]}}}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { let mask = lottie.layers[0].masksProperties[0]; mask.o.k = Number(data[\"Opacity\"]); mask.inv = data[\"Invert\"]; mask.x.k = Number(data[\"Expand\"]); mask.mode = data[\"Mode\"];this.json_viewer_contents = lottie.layers[0].masksProperties[0]; }, {} );","title":"Masks"},{"location":"layers/#shape-layer","text":"Renders vector data. The only special property for this layer is shapes , an array of shapes . Also has the attributes from Visual Layer . Attribute Type Description ty integer = 4 Layer type shapes Shape List Shapes","title":"Shape Layer"},{"location":"layers/#precomposition-layer","text":"This layer renders a precomposition . You can find more details in the Precompositions page. Also has the attributes from Visual Layer . Attribute Type Description ty integer = 0 Layer type refId string ID of the precomp as specified in the assets w integer Width of the clipping rect h integer Height of the clipping rect tm Animated number Time Remapping","title":"Precomposition Layer"},{"location":"layers/#time-remapping","text":"The tm property maps the time in seconds of the precomposition to show. Basically you get the value of tm at the current frame, then assume that's a time in seconds since the start of the animation, and render the corresponding frame of the precomposition. Follows an example of this, here there are two layers showing the same precomposition, the one at the top right keeps the original time while the bottom one remaps time as follows: frame 0 (0s) maps to 0s (frame 0) in the precomp frame 30 (0.5s) maps to 3s (frame 180) in the precomp frame 60 (1s) maps to 1.5s (frame 90) in the precomp frame 180 (3s) maps to 3s (frame 180) in the precomp Basically it makes the precomp play in the first half second, then rewind to half way for the next half second, and plays back to the end for the remaining 2 seconds. Show JSON var lottie_player_23 = new PlaygroundPlayer( 23, 'playground_23_1', 'lottie_target_23', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{7820523d-dd32-453b-b311-50323a49e4df}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [{\"nm\": \"Composition\", \"mn\": \"{4d838004-a221-48cb-966f-399347c5acb8}\", \"id\": \"{4d838004-a221-48cb-966f-399347c5acb8}\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer 1\", \"mn\": \"{8afc4794-97eb-4533-814b-f92676e324f5}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar 1\", \"mn\": \"{600eb536-73f0-415d-8743-01dd2f26e2b7}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar 1\", \"mn\": \"{0d81b309-da59-4646-812d-ed9212679e27}\", \"p\": {\"a\": 0, \"k\": [166.49999999999997, 144.89999999999998]}, \"or\": {\"a\": 0, \"k\": 103.60950469970703}, \"ir\": {\"a\": 0, \"k\": 51.804752349853516}, \"r\": {\"a\": 0, \"k\": 147.41429138183594}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{5271148f-841e-4e99-9f23-e0b201b46def}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5019607843137255, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{c72fab9f-6a71-4e30-966c-1b863389d19a}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [166.49999999999997, 144.89999999999998]}, \"p\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [106.19999999999997, 126.89999999999998], \"h\": 0, \"o\": {\"x\": [0.3333333333333333], \"y\": [0]}, \"i\": {\"x\": [0.6666666666666666], \"y\": [1]}, \"e\": [413.99999999999994, 413.09999999999997]}, {\"t\": 180, \"s\": [413.99999999999994, 413.09999999999997]}]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}]}], \"layers\": [{\"ty\": 0, \"ddd\": 0, \"nm\": \"Composition\", \"mn\": \"{e3aa5446-47d2-454e-8d20-ed3c5f15612e}\", \"ip\": 0, \"op\": 180, \"ind\": 2, \"st\": 0, \"sr\": 1, \"ks\": {\"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [50, 50]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"refId\": \"{4d838004-a221-48cb-966f-399347c5acb8}\", \"w\": 512, \"h\": 512}, {\"ty\": 0, \"ddd\": 0, \"nm\": \"Remapped\", \"mn\": \"{0f7b917c-b0e8-450f-bb63-812dff786620}\", \"ip\": 0, \"op\": 180, \"ind\": 1, \"st\": 0, \"sr\": 1, \"tm\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"o\": {\"x\": 0, \"y\": 0}, \"i\": {\"x\": 1, \"y\": 1}}, {\"t\": 30, \"s\": [3], \"o\": {\"x\": 0, \"y\": 0}, \"i\": {\"x\": 1, \"y\": 1}}, {\"t\": 60, \"s\": [1.5], \"o\": {\"x\": 0, \"y\": 0}, \"i\": {\"x\": 1, \"y\": 1}}, {\"t\": 180, \"s\": [3], \"o\": {\"x\": 0, \"y\": 0}, \"i\": {\"x\": 1, \"y\": 1}}]}, \"ks\": {\"a\": {\"a\": 0, \"k\": [512, 512]}, \"p\": {\"a\": 0, \"k\": [512, 512]}, \"s\": {\"a\": 0, \"k\": [50, 50]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"refId\": \"{4d838004-a221-48cb-966f-399347c5acb8}\", \"w\": 512, \"h\": 512}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { this.json_viewer_contents = {...lottie.layers[1], ks:{}}; }, {} );","title":"Time remapping"},{"location":"layers/#null-layer","text":"This layer doesn't have any special properties. It's often used by animators as a parent to multiple other layers (see parenting ). Also has the attributes from Visual Layer . Attribute Type Description ty integer = 3 Layer type","title":"Null Layer"},{"location":"layers/#text-layer","text":"For text data, please refer to the section about text for details. Also has the attributes from Visual Layer . Attribute Type Description ty integer = 5 Layer type t Text Data Data","title":"Text Layer"},{"location":"layers/#image-layer","text":"This layer renders a static image . Also has the attributes from Visual Layer . Attribute Type Description ty integer = 2 Layer type refId string ID of the image as specified in the assets","title":"Image Layer"},{"location":"layers/#solid-color-layer","text":"This layer represents a rectangle with a single color. Anything you can do with solid layers, you can do better with a shape layer and a rectangle shape since none of this layer's own properties can be animated. Note that the color is represented as a string, unlike most other places. Also has the attributes from Visual Layer . Attribute Type Description ty integer = 1 Layer type sc string Color of the layer, unlike most other places, the color is a #rrggbb hex string sh number Height sw number Width Color Width 512 Height 512 Show JSON var lottie_player_24 = new PlaygroundPlayer( 24, 'playground_24_4', 'lottie_target_24', {\"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"layers\": [{\"ty\": 1, \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": {}, \"sc\": \"#ff0000\", \"sh\": 512, \"sw\": 512}]}, function (lottie, data) { lottie.layers[0].sc = data[\"Color\"]; lottie.layers[0].sw = Number(data[\"Width\"]); lottie.layers[0].sh = Number(data[\"Height\"]);this.json_viewer_contents = lottie.layers[0]; }, {} );","title":"Solid Color Layer"},{"location":"layers/#audio-layer","text":"This layer plays a sound . Also has the attributes from Layer . Attribute Type Description ty integer = 6 Layer type au Audio Settings Audio Settings refId string ID of the sound as specified in the assets","title":"Audio Layer"},{"location":"layers/#audio-settings","text":"Attribute Type Description lv Animated Vector Level","title":"Audio Settings"},{"location":"layers/#3d-layers","text":"Layers can have 3D transforms as well: var lottie_player_30 = new LottiePlayer( 'lottie_target_30', '../examples/3d_layers_animation.json', true, {renderer: \"html\"} ); 3D layers need to have the ddd set to 1 (and so does the top-level object). Their transform will habe a and p specified as 3D components. Rotation will be split into 3 properties: rx , ry , rz , and you have and additional orientation property or . Anchor X 0 Y 0 Z 0 Position X 256 Y 256 Z 0 Rotation X 0 Y 30 Z 0 Orientation X 0 Y 0 Z 0 Scale X 100 Y 100 Z 100 Show JSON var lottie_player_25 = new PlaygroundPlayer( 25, 'playground_25_16', 'lottie_target_25', {\"v\": \"5.9.2\", \"fr\": 60, \"ip\": 0, \"op\": 120, \"w\": 512, \"h\": 512, \"nm\": \"3d layers\", \"ddd\": 1, \"layers\": [{\"ddd\": 1, \"ind\": 2, \"ty\": 4, \"nm\": \"Blue Circle\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 0}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [256, 256, 0]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"el\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0.196, 0.314, 0.69]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ind\": 2, \"ty\": 4, \"nm\": \"Yellow Square\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 30}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [256, 256, 0]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [1, 1, 0.3]}, \"o\": {\"a\": 0, \"k\": 100}}]}]}, function (lottie, data) { lottie.layers[1].ks.a.k = [ data[\"ax\"], data[\"ay\"], data[\"az\"] ]; lottie.layers[1].ks.p.k = [ data[\"px\"], data[\"py\"], data[\"pz\"] ]; lottie.layers[1].ks.or.k = [ data[\"orx\"], data[\"ory\"], data[\"orz\"] ]; lottie.layers[1].ks.s.k = [ data[\"sx\"], data[\"sy\"], data[\"sz\"] ]; lottie.layers[1].ks.rx.k = data[\"rx\"]; lottie.layers[1].ks.ry.k = data[\"ry\"]; lottie.layers[1].ks.rz.k = data[\"rz\"];this.json_viewer_contents = lottie.layers[1].ks; }, {renderer: \"html\"} );","title":"3D Layers"},{"location":"layers/#camera-layer","text":"Camera for 3D layers. Also has the attributes from Layer . Attribute Type Description ty integer = 13 Layer type ks Transform Layer transform pe Animated number Distance from the Z=0 plane. Small values yield a higher perspective effect. Perspective 256 Position X 0 Y 0 Z -10 Rotation X 0 Y 0 Z 0 Orientation X 0 Y 0 Z 0 Show JSON var lottie_player_26 = new PlaygroundPlayer( 26, 'playground_26_11', 'lottie_target_26', {\"v\": \"5.9.2\", \"fr\": 60, \"ip\": 0, \"op\": 120, \"w\": 512, \"h\": 512, \"nm\": \"3d layers\", \"ddd\": 1, \"layers\": [{\"ddd\": 1, \"ty\": 13, \"nm\": \"Camera\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 0}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0, -10]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"pe\": {\"a\": 0, \"k\": 256}}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Page\", \"ks\": {\"o\": {\"a\": 0, \"k\": 50}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 0}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0, 0]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [1, 1, 1]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall Front\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 0}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0, 200]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0.5, 0.5, 1]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall FR\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 45}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [141, 0, 141]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [1, 0.5, 1]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall FL\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": -45}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [-141, 0, 141]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0, 0.5, 1]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall Left\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": -90}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [-200, 0, 0]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0, 0.5, 0.5]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall Right\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 90}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [200, 0, 0]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [1, 0.5, 0.5]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall BR\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": -45}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [141, 0, -141]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [1, 0.5, 0]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall BL\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 45}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [-141, 0, -141]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0, 0.5, 0]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall Back\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 0}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0, -200]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0.5, 0.5, 0]}, \"o\": {\"a\": 0, \"k\": 100}}]}]}, function (lottie, data) { var index = 0; lottie.layers[index].ks.p.k = [ data[\"px\"], data[\"py\"], data[\"pz\"] ]; lottie.layers[index].ks.or.k = [ data[\"orx\"], data[\"ory\"], data[\"orz\"] ]; lottie.layers[index].ks.rx.k = data[\"rx\"]; lottie.layers[index].ks.ry.k = data[\"ry\"]; lottie.layers[index].ks.rz.k = data[\"rz\"]; lottie.layers[index].pe.k = data[\"Perspective\"];this.json_viewer_contents = lottie.layers[0]; }, {renderer: \"html\"} );","title":"Camera Layer"},{"location":"layers/#3d-parenting","text":"As with 2D layers, you can parent 3D layers. Position X 0 Y 0 Z -10 Rotation X 0 Y 0 Z 0 Orientation X 0 Y 0 Z 0 Show JSON var lottie_player_27 = new PlaygroundPlayer( 27, 'playground_27_10', 'lottie_target_27', {\"v\": \"5.9.2\", \"fr\": 60, \"ip\": 0, \"op\": 120, \"w\": 512, \"h\": 512, \"nm\": \"3d layers\", \"ddd\": 1, \"layers\": [{\"ddd\": 1, \"ty\": 13, \"nm\": \"Camera\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 0}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0, -10]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"pe\": {\"a\": 0, \"k\": 256}}, {\"ddd\": 1, \"ty\": 4, \"ind\": 1, \"nm\": \"Parent\", \"ks\": {\"o\": {\"a\": 0, \"k\": 50}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 0}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0, 0]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [1, 1, 1]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall Front\", \"parent\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 0}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0, 200]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0.5, 0.5, 1]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall FR\", \"parent\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 45}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [141, 0, 141]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [1, 0.5, 1]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall FL\", \"parent\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": -45}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [-141, 0, 141]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0, 0.5, 1]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall Left\", \"parent\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": -90}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [-200, 0, 0]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0, 0.5, 0.5]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall Right\", \"parent\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 90}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [200, 0, 0]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [1, 0.5, 0.5]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall BR\", \"parent\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": -45}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [141, 0, -141]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [1, 0.5, 0]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall BL\", \"parent\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 45}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [-141, 0, -141]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0, 0.5, 0]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall Back\", \"parent\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 0}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0, -200]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0.5, 0.5, 0]}, \"o\": {\"a\": 0, \"k\": 100}}]}]}, function (lottie, data) { var index = 1; lottie.layers[index].ks.p.k = [ data[\"px\"], data[\"py\"], data[\"pz\"] ]; lottie.layers[index].ks.or.k = [ data[\"orx\"], data[\"ory\"], data[\"orz\"] ]; lottie.layers[index].ks.rx.k = data[\"rx\"]; lottie.layers[index].ks.ry.k = data[\"ry\"]; lottie.layers[index].ks.rz.k = data[\"rz\"];this.json_viewer_contents = lottie.layers[1]; }, {renderer: \"html\"} );","title":"3D Parenting"},{"location":"layers/#data-layer","text":"This layer links to a data source . Also has the attributes from Layer . Attribute Type Description ty integer = 15 Layer type refId string ID of the data source in assets","title":"Data Layer"},{"location":"rendering/","text":"Tips for rendering .json-parent:not([hidden]) { display: flex; } .json-parent > pre { width: 50%; } .json-parent > pre > code { height: 100%; } let converter_map = {}; function convert_shape(shape) { return converter_map[shape.ty](shape); } Introduction This page will give tips and example code on how to render certain objects within lottie. Lottie has several implementations and some things might vary from player to player, this guide tries to follow the behaviour of lottie web which is the reference implementation. For shapes, it ensures the stroke order is the same as in lottie web, which is crucial for Trim Path to work correctly. All shapes have the d attribute that if has the value 3 the path should be reversed. Code The code examples take some shortcuts for readablility: all animated properties are shown as static, of course you'd need to get the correct values to render shapes at a given frame. When adding points to a bezier, there are calls to bezier.add_vertex() . Assume the in/out tangents are [0, 0] if not specified. When they are specified they show as set_out_tangent immediately following the corresponding add_vertex . Bezier tangents are assumed to be relative to their vertex since that's how lottie works but it might be useful to keep them as absolute points when rendering. All the examples show the original on the left and the bezier on the right. Explanation for bezier operations is outside the scope of this guide, the code below use a simple bezier library for some operations, you can check its sources for some context on what the various functions do. Rectangle See Rectangle . Note that unlike other shapes, on lottie web when the d attribute is missing, the rectangle defaults as being reversed. Rectangle without rounded corners: Position x 256 Position y 256 Width 256 Height 256 Show JSON function rect(position, size) { let left = position[0] - size[0] / 2; let right = position[0] + size[0] / 2; let top = position[1] - size[1] / 2; let bottom = position[1] + size[1] / 2; let bezier = new Bezier(); bezier.add_vertex(right, top); bezier.add_vertex(right, bottom); bezier.add_vertex(left, bottom); bezier.add_vertex(left, top); return bezier; } // Example invocation rect(shape.p.k, shape.s.k); function rect(position, size) { let left = position[0] - size[0] / 2; let right = position[0] + size[0] / 2; let top = position[1] - size[1] / 2; let bottom = position[1] + size[1] / 2; let bezier = new Bezier(); bezier.add_vertex(right, top); bezier.add_vertex(right, bottom); bezier.add_vertex(left, bottom); bezier.add_vertex(left, top); return bezier; } var lottie_player_31_bezier = new LottiePlayer('lottie_target_31_bezier', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"sh\", \"nm\": \"Shape\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [], \"i\": [], \"o\": []}}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}); var lottie_player_31 = new PlaygroundPlayer( 31, 'playground_31_5', 'lottie_target_31', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { let bezier_lottie = lottie_player_31_bezier.lottie; lottie.layers[0].shapes[0].it[0].p.k = [ data[\"Position x\"], data[\"Position y\"] ]; lottie.layers[0].shapes[0].it[0].s.k = [ data[\"Width\"], data[\"Height\"] ]; this.json_viewer_contents = lottie.layers[0].shapes[0].it[0]; let shape = lottie.layers[0].shapes[0].it[0]; let bez_result = rect(shape.p.k, shape.s.k); if ( !Array.isArray(bez_result) ) bez_result = [bez_result]; let out_shapes = bez_result.map(b => ({ ty: \"sh\", \"ks\": {a: 0, k: b.to_lottie()} })); let bez_target = bezier_lottie.layers[0].shapes[0].it; bez_target.splice(0, bez_target.length - 2, ...out_shapes); lottie_player_31_bezier.reload(); this.set_json('playground_31_5_bezier', out_shapes[0].ks.k); }, {} ); With rounded corners: Position x 256 Position y 256 Width 256 Height 256 Roundness 50 Show JSON function rounded_rect(position, size, roundness) { let left = position[0] - size[0] / 2; let right = position[0] + size[0] / 2; let top = position[1] - size[1] / 2; let bottom = position[1] + size[1] / 2; let rounded = Math.min(size[0] / 2, size[1] / 2, roundness); let bezier = new Bezier(); // top right, going down bezier.add_vertex(right, top + rounded) .set_in_tangent(0, -rounded/2); // bottom right bezier.add_vertex(right, bottom - rounded) .set_out_tangent(0, rounded/2); bezier.add_vertex(right - rounded, bottom) .set_in_tangent(rounded/2, 0); // bottom left bezier.add_vertex(left + rounded, bottom) .set_out_tangent(-rounded/2, 0); bezier.add_vertex(left, bottom - rounded) .set_in_tangent(0, rounded/2); // top left bezier.add_vertex(left, top + rounded) .set_out_tangent(0, -rounded/2); bezier.add_vertex(left + rounded, top) .set_in_tangent(-rounded/2, 0); // back to top right bezier.add_vertex(right - rounded, top) .set_out_tangent(rounded/2, 0); return bezier; } // Example invocation rounded_rect(shape.p.k, shape.s.k, shape.r.k); function rounded_rect(position, size, roundness) { let left = position[0] - size[0] / 2; let right = position[0] + size[0] / 2; let top = position[1] - size[1] / 2; let bottom = position[1] + size[1] / 2; let rounded = Math.min(size[0] / 2, size[1] / 2, roundness); let bezier = new Bezier(); // top right, going down bezier.add_vertex(right, top + rounded) .set_in_tangent(0, -rounded/2); // bottom right bezier.add_vertex(right, bottom - rounded) .set_out_tangent(0, rounded/2); bezier.add_vertex(right - rounded, bottom) .set_in_tangent(rounded/2, 0); // bottom left bezier.add_vertex(left + rounded, bottom) .set_out_tangent(-rounded/2, 0); bezier.add_vertex(left, bottom - rounded) .set_in_tangent(0, rounded/2); // top left bezier.add_vertex(left, top + rounded) .set_out_tangent(0, -rounded/2); bezier.add_vertex(left + rounded, top) .set_in_tangent(-rounded/2, 0); // back to top right bezier.add_vertex(right - rounded, top) .set_out_tangent(rounded/2, 0); return bezier; } converter_map['rc'] = shape => rounded_rect(shape.p.k, shape.s.k, shape.r.k); var lottie_player_32_bezier = new LottiePlayer('lottie_target_32_bezier', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"sh\", \"nm\": \"Shape\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [], \"i\": [], \"o\": []}}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}); var lottie_player_32 = new PlaygroundPlayer( 32, 'playground_32_6', 'lottie_target_32', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { let bezier_lottie = lottie_player_32_bezier.lottie; lottie.layers[0].shapes[0].it[0].p.k = [ data[\"Position x\"], data[\"Position y\"] ]; lottie.layers[0].shapes[0].it[0].s.k = [ data[\"Width\"], data[\"Height\"] ]; lottie.layers[0].shapes[0].it[0].r.k = data[\"Roundness\"]; this.json_viewer_contents = lottie.layers[0].shapes[0].it[0]; let shape = lottie.layers[0].shapes[0].it[0]; let bez_result = rounded_rect(shape.p.k, shape.s.k, shape.r.k); if ( !Array.isArray(bez_result) ) bez_result = [bez_result]; let out_shapes = bez_result.map(b => ({ ty: \"sh\", \"ks\": {a: 0, k: b.to_lottie()} })); let bez_target = bezier_lottie.layers[0].shapes[0].it; bez_target.splice(0, bez_target.length - 2, ...out_shapes); lottie_player_32_bezier.reload(); this.set_json('playground_32_6_bezier', out_shapes[0].ks.k); }, {} ); Ellipse See Ellipse . The stroke direction should start at the top. If you think of the ellipse as a clock, start at 12 go clockwise. The magic number 0.5519 is what lottie uses for this, based on this article . Position x 256 Position y 256 Width 256 Height 256 Show JSON function ellipse(position, size) { const ellipse_constant = 0.5519; let x = position[0]; let y = position[1]; let radius_x = size[0] / 2; let radius_y = size[1] / 2; let tangent_x = radius_x * ellipse_constant; let tangent_y = radius_y * ellipse_constant; let bezier = new Bezier(); bezier.add_vertex(x, y - radius_y) .set_in_tangent(-tangent_x, 0) .set_out_tangent(tangent_x, 0); bezier.add_vertex(x + radius_x, y) .set_in_tangent(0, -tangent_y) .set_out_tangent(0, tangent_y); bezier.add_vertex(x, y + radius_y) .set_in_tangent(tangent_x, 0) .set_out_tangent(-tangent_x, 0); bezier.add_vertex(x - radius_x, y) .set_in_tangent(0, tangent_y) .set_out_tangent(0, -tangent_y); return bezier; } // Example invocation ellipse(shape.p.k, shape.s.k); function ellipse(position, size) { const ellipse_constant = 0.5519; let x = position[0]; let y = position[1]; let radius_x = size[0] / 2; let radius_y = size[1] / 2; let tangent_x = radius_x * ellipse_constant; let tangent_y = radius_y * ellipse_constant; let bezier = new Bezier(); bezier.add_vertex(x, y - radius_y) .set_in_tangent(-tangent_x, 0) .set_out_tangent(tangent_x, 0); bezier.add_vertex(x + radius_x, y) .set_in_tangent(0, -tangent_y) .set_out_tangent(0, tangent_y); bezier.add_vertex(x, y + radius_y) .set_in_tangent(tangent_x, 0) .set_out_tangent(-tangent_x, 0); bezier.add_vertex(x - radius_x, y) .set_in_tangent(0, tangent_y) .set_out_tangent(0, -tangent_y); return bezier; } converter_map['el'] = shape => ellipse(shape.p.k, shape.s.k); var lottie_player_33_bezier = new LottiePlayer('lottie_target_33_bezier', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"sh\", \"nm\": \"Shape\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [], \"i\": [], \"o\": []}}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}); var lottie_player_33 = new PlaygroundPlayer( 33, 'playground_33_5', 'lottie_target_33', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"el\", \"nm\": \"Ellipse\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [256, 256]}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { let bezier_lottie = lottie_player_33_bezier.lottie; lottie.layers[0].shapes[0].it[0].p.k = [ data[\"Position x\"], data[\"Position y\"] ]; lottie.layers[0].shapes[0].it[0].s.k = [ data[\"Width\"], data[\"Height\"] ]; this.json_viewer_contents = lottie.layers[0].shapes[0].it[0]; let shape = lottie.layers[0].shapes[0].it[0]; let bez_result = ellipse(shape.p.k, shape.s.k); if ( !Array.isArray(bez_result) ) bez_result = [bez_result]; let out_shapes = bez_result.map(b => ({ ty: \"sh\", \"ks\": {a: 0, k: b.to_lottie()} })); let bez_target = bezier_lottie.layers[0].shapes[0].it; bez_target.splice(0, bez_target.length - 2, ...out_shapes); lottie_player_33_bezier.reload(); this.set_json('playground_33_5_bezier', out_shapes[0].ks.k); }, {} ); PolyStar Pseudocode for rendering a PolyStar . Points 5 Rotation 0 Outer Radius 200 Inner Radius 100 Outer Roundness 0 Inner Roundness 0 Type Star Polygon Show JSON function polystar( position, type, points, rotation, outer_radius, outer_roundness, inner_radius, inner_roundness ) { let result = new Bezier(); let half_angle = Math.PI / points; let angle_radians = rotation / 180 * Math.PI // Tangents for rounded courners let tangent_len_outer = outer_roundness * outer_radius * 2 * Math.PI / (points * 4 * 100); let tangent_len_inner = inner_roundness * inner_radius * 2 * Math.PI / (points * 4 * 100); for ( let i = 0; i < points; i++ ) { let main_angle = -Math.PI / 2 + angle_radians + i * half_angle * 2; let outer_vertex = new Point( outer_radius * Math.cos(main_angle), outer_radius * Math.sin(main_angle) ); let outer_tangent = new Point(0, 0); if ( outer_radius != 0 ) outer_tangent = new Point( outer_vertex.y / outer_radius * tangent_len_outer, -outer_vertex.x / outer_radius * tangent_len_outer ); result.add_vertex(position.add(outer_vertex)) .set_in_tangent(outer_tangent) .set_out_tangent(outer_tangent.neg()); // Star inner radius if ( type == 1 ) { let inner_vertex = new Point( inner_radius * Math.cos(main_angle + half_angle), inner_radius * Math.sin(main_angle + half_angle) ); let inner_tangent = new Point(0, 0); if ( inner_radius != 0 ) inner_tangent = new Point( inner_vertex.y / inner_radius * tangent_len_inner, -inner_vertex.x / inner_radius * tangent_len_inner ); result.add_vertex(position.add(inner_vertex)) .set_in_tangent(inner_tangent) .set_out_tangent(inner_tangent.neg()); } } return result; } // Example invocation polystar(new Point(shape.p.k), shape.sy, shape.pt.k, shape.r.k, shape.or.k, shape.os.k, shape.ir?.k, shape.is?.k); function polystar( position, type, points, rotation, outer_radius, outer_roundness, inner_radius, inner_roundness ) { let result = new Bezier(); let half_angle = Math.PI / points; let angle_radians = rotation / 180 * Math.PI // Tangents for rounded courners let tangent_len_outer = outer_roundness * outer_radius * 2 * Math.PI / (points * 4 * 100); let tangent_len_inner = inner_roundness * inner_radius * 2 * Math.PI / (points * 4 * 100); for ( let i = 0; i < points; i++ ) { let main_angle = -Math.PI / 2 + angle_radians + i * half_angle * 2; let outer_vertex = new Point( outer_radius * Math.cos(main_angle), outer_radius * Math.sin(main_angle) ); let outer_tangent = new Point(0, 0); if ( outer_radius != 0 ) outer_tangent = new Point( outer_vertex.y / outer_radius * tangent_len_outer, -outer_vertex.x / outer_radius * tangent_len_outer ); result.add_vertex(position.add(outer_vertex)) .set_in_tangent(outer_tangent) .set_out_tangent(outer_tangent.neg()); // Star inner radius if ( type == 1 ) { let inner_vertex = new Point( inner_radius * Math.cos(main_angle + half_angle), inner_radius * Math.sin(main_angle + half_angle) ); let inner_tangent = new Point(0, 0); if ( inner_radius != 0 ) inner_tangent = new Point( inner_vertex.y / inner_radius * tangent_len_inner, -inner_vertex.x / inner_radius * tangent_len_inner ); result.add_vertex(position.add(inner_vertex)) .set_in_tangent(inner_tangent) .set_out_tangent(inner_tangent.neg()); } } return result; } converter_map['sr'] = shape => polystar(new Point(shape.p.k), shape.sy, shape.pt.k, shape.r.k, shape.or.k, shape.os.k, shape.ir?.k, shape.is?.k); var lottie_player_34_bezier = new LottiePlayer('lottie_target_34_bezier', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"sh\", \"nm\": \"Shape\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [], \"i\": [], \"o\": []}}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}); var lottie_player_34 = new PlaygroundPlayer( 34, 'playground_34_8', 'lottie_target_34', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [{\"ty\": 4, \"ddd\": 0, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ip\": 0, \"op\": 180, \"ind\": 0, \"st\": 0, \"sr\": 1, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{9199543e-3552-4e51-a802-623f2a4a2ca1}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.979995422293431, 0.28000305180437934]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { let bezier_lottie = lottie_player_34_bezier.lottie; var star = { \"ty\": \"sr\", \"nm\": \"PolyStar\", \"sy\": Number(data[\"Type\"]), \"p\": { \"a\": 0, \"k\": [ 256, 256 ] }, \"r\": { \"a\": 0, \"k\": data[\"Rotation\"] }, \"pt\": { \"a\": 0, \"k\": data[\"Points\"] }, \"or\": { \"a\": 0, \"k\": data[\"Outer Radius\"] }, \"os\": { \"a\": 0, \"k\": data[\"Outer Roundness\"] }, }; if ( data[\"Type\"] == \"1\" ) { star.ir = { \"a\": 0, \"k\": data[\"Inner Radius\"] }; star.is = { \"a\": 0, \"k\": data[\"Inner Roundness\"] }; } lottie.layers[0].shapes[0].it[0] = star; this.json_viewer_contents = lottie.layers[0].shapes[0].it[0]; let shape = lottie.layers[0].shapes[0].it[0]; let bez_result = polystar(new Point(shape.p.k), shape.sy, shape.pt.k, shape.r.k, shape.or.k, shape.os.k, shape.ir?.k, shape.is?.k); if ( !Array.isArray(bez_result) ) bez_result = [bez_result]; let out_shapes = bez_result.map(b => ({ ty: \"sh\", \"ks\": {a: 0, k: b.to_lottie()} })); let bez_target = bezier_lottie.layers[0].shapes[0].it; bez_target.splice(0, bez_target.length - 2, ...out_shapes); lottie_player_34_bezier.reload(); this.set_json('playground_34_8_bezier', out_shapes[0].ks.k); }, {} ); Pucker Bloat See Pucker / Bloat . Amount 50 Show JSON function pucker_bloat( // Beziers as collected from the other shapes collected_shapes, // \"a\" property from the Pucker/Bloat modifier amount ) { // Normalize to [0, 1] amount /= 100; // Find the mean of the bezier vertices let center = new Point(0, 0); let number_of_vertices = 0; for ( let input_bezier of collected_shapes ) { for ( let point of input_bezier.points ) { center.x += point.pos.x; center.y += point.pos.y; number_of_vertices += 1; } } center.x /= number_of_vertices; center.y /= number_of_vertices; let result = []; for ( let input_bezier of collected_shapes ) { let output_bezier = new Bezier(); for ( let point of input_bezier.points ) { // Here we convert tangents to global coordinates let vertex = lerp(point.pos, center, amount); let in_tangent = lerp(point.in_tangent.add(point.pos), center, -amount).sub(vertex); let out_tangent = lerp(point.out_tangent.add(point.pos), center, -amount).sub(vertex); output_bezier.add_vertex(vertex) .set_in_tangent(in_tangent) .set_out_tangent(out_tangent); } output_bezier.closed = input_bezier.closed; result.push(output_bezier); } return result; } // Example invocation pucker_bloat([convert_shape(star)], modifier.a.k); function pucker_bloat( // Beziers as collected from the other shapes collected_shapes, // \"a\" property from the Pucker/Bloat modifier amount ) { // Normalize to [0, 1] amount /= 100; // Find the mean of the bezier vertices let center = new Point(0, 0); let number_of_vertices = 0; for ( let input_bezier of collected_shapes ) { for ( let point of input_bezier.points ) { center.x += point.pos.x; center.y += point.pos.y; number_of_vertices += 1; } } center.x /= number_of_vertices; center.y /= number_of_vertices; let result = []; for ( let input_bezier of collected_shapes ) { let output_bezier = new Bezier(); for ( let point of input_bezier.points ) { // Here we convert tangents to global coordinates let vertex = lerp(point.pos, center, amount); let in_tangent = lerp(point.in_tangent.add(point.pos), center, -amount).sub(vertex); let out_tangent = lerp(point.out_tangent.add(point.pos), center, -amount).sub(vertex); output_bezier.add_vertex(vertex) .set_in_tangent(in_tangent) .set_out_tangent(out_tangent); } output_bezier.closed = input_bezier.closed; result.push(output_bezier); } return result; } var lottie_player_35_bezier = new LottiePlayer('lottie_target_35_bezier', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"sh\", \"nm\": \"Shape\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [], \"i\": [], \"o\": []}}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}); var lottie_player_35 = new PlaygroundPlayer( 35, 'playground_35_2', 'lottie_target_35', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{9199543e-3552-4e51-a802-623f2a4a2ca1}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 160}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 2, \"os\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"pb\", \"nm\": \"Inflate and Deflate\", \"mn\": \"{b4af429a-546e-4728-a869-711a404c55ae}\", \"a\": {\"a\": 0, \"k\": 50}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"fl\", \"hd\": true, \"nm\": \"Fill\", \"mn\": \"{a1bcc159-6916-4718-841d-a99140c0e74b}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { let bezier_lottie = lottie_player_35_bezier.lottie; lottie.layers[0].shapes[0].it[1].a.k = data[\"Amount\"]; let star = lottie.layers[0].shapes[0].it[0]; this.json_viewer_contents = lottie.layers[0].shapes[0].it[1]; let modifier = lottie.layers[0].shapes[0].it[1]; let bez_result = pucker_bloat([convert_shape(star)], modifier.a.k); if ( !Array.isArray(bez_result) ) bez_result = [bez_result]; let out_shapes = bez_result.map(b => ({ ty: \"sh\", \"ks\": {a: 0, k: b.to_lottie()} })); let bez_target = bezier_lottie.layers[0].shapes[0].it; bez_target.splice(0, bez_target.length - 2, ...out_shapes); lottie_player_35_bezier.reload(); this.set_json('playground_35_2_bezier', out_shapes[0].ks.k); }, {} ); Rounded Corners See Rounded Corners . It approximates rounding using circular arcs. The magic number 0.5519 is what lottie uses for this, based on this article . Radius 50 Show JSON // Helper function to perform rounding on a single vertex function get_vertex_tangent( // Bezier to round bezier, // Vertex in the bezier we are rounding current_vertex, // Index of the next point along the curve closest_index, // Rounding radius round_distance ) { const tangent_length = 0.5519; // closest_index module bezier.length closest_index = closest_index % bezier.points.length; if ( closest_index < 0 ) closest_index += bezier.points.length; let closest_vertex = bezier.points[closest_index].pos; let distance = current_vertex.distance(closest_vertex); let new_pos_perc = distance != 0 ? Math.min(distance/2, round_distance) / distance : 0; let vertex = closest_vertex.sub(current_vertex).mul(new_pos_perc).add(current_vertex); let tangent = vertex.sub(current_vertex).neg().mul(tangent_length); return [vertex, tangent]; } // Rounding for a single continuos curve function round_bezier_corners( // Bezier to round original, // Rounding radius round_distance ) { let result = new Bezier() result.closed = original.closed; for ( let i = 0; i < original.points.length; i++ ) { let point = original.points[i]; // Start and end of a non-closed path don't get rounded if ( !original.closed && (i == 0 || i == original.points.length - 1) ) { result.add_vertex(point.pos) .set_in_tangent(point.in_tangent) .set_out_tangent(point.out_tangent); } else { let [vert1, out_t] = get_vertex_tangent(original, point.pos, i - 1, round_distance); result.add_vertex(vert1) .set_out_tangent(out_t); let [vert2, in_t] = get_vertex_tangent(original, point.pos, i + 1, round_distance); result.add_vertex(vert2) .set_in_tangent(in_t); } } return result; } // Rounding on multiple bezier function round_corners( // Beziers as collected from the other shapes collected_shapes, // \"r\" property from lottie r ) { let result = [] for ( let input_bezier of collected_shapes ) result.push(round_bezier_corners(input_bezier, r)); return result; } // Example invocation round_corners([convert_shape(star)], modifier.r.k); // Helper function to perform rounding on a single vertex function get_vertex_tangent( // Bezier to round bezier, // Vertex in the bezier we are rounding current_vertex, // Index of the next point along the curve closest_index, // Rounding radius round_distance ) { const tangent_length = 0.5519; // closest_index module bezier.length closest_index = closest_index % bezier.points.length; if ( closest_index < 0 ) closest_index += bezier.points.length; let closest_vertex = bezier.points[closest_index].pos; let distance = current_vertex.distance(closest_vertex); let new_pos_perc = distance != 0 ? Math.min(distance/2, round_distance) / distance : 0; let vertex = closest_vertex.sub(current_vertex).mul(new_pos_perc).add(current_vertex); let tangent = vertex.sub(current_vertex).neg().mul(tangent_length); return [vertex, tangent]; } // Rounding for a single continuos curve function round_bezier_corners( // Bezier to round original, // Rounding radius round_distance ) { let result = new Bezier() result.closed = original.closed; for ( let i = 0; i < original.points.length; i++ ) { let point = original.points[i]; // Start and end of a non-closed path don't get rounded if ( !original.closed && (i == 0 || i == original.points.length - 1) ) { result.add_vertex(point.pos) .set_in_tangent(point.in_tangent) .set_out_tangent(point.out_tangent); } else { let [vert1, out_t] = get_vertex_tangent(original, point.pos, i - 1, round_distance); result.add_vertex(vert1) .set_out_tangent(out_t); let [vert2, in_t] = get_vertex_tangent(original, point.pos, i + 1, round_distance); result.add_vertex(vert2) .set_in_tangent(in_t); } } return result; } // Rounding on multiple bezier function round_corners( // Beziers as collected from the other shapes collected_shapes, // \"r\" property from lottie r ) { let result = [] for ( let input_bezier of collected_shapes ) result.push(round_bezier_corners(input_bezier, r)); return result; } var lottie_player_36_bezier = new LottiePlayer('lottie_target_36_bezier', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"sh\", \"nm\": \"Shape\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [], \"i\": [], \"o\": []}}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}); var lottie_player_36 = new PlaygroundPlayer( 36, 'playground_36_2', 'lottie_target_36', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{9199543e-3552-4e51-a802-623f2a4a2ca1}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 222.72242736816406}, \"ir\": {\"a\": 0, \"k\": 111.36121368408203}, \"r\": {\"a\": 0, \"k\": 358.67291259765625}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"rd\", \"nm\": \"Rounded Corners\", \"mn\": \"{dcd7570f-5105-485b-bd43-42ad990b01e8}\", \"r\": {\"a\": 0, \"k\": 50}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"fl\", \"hd\": true, \"nm\": \"Fill\", \"mn\": \"{a1bcc159-6916-4718-841d-a99140c0e74b}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { let bezier_lottie = lottie_player_36_bezier.lottie; lottie.layers[0].shapes[0].it[1].r.k = data[\"Radius\"]; let star = lottie.layers[0].shapes[0].it[0]; this.json_viewer_contents = lottie.layers[0].shapes[0].it[1]; let modifier = lottie.layers[0].shapes[0].it[1]; let bez_result = round_corners([convert_shape(star)], modifier.r.k); if ( !Array.isArray(bez_result) ) bez_result = [bez_result]; let out_shapes = bez_result.map(b => ({ ty: \"sh\", \"ks\": {a: 0, k: b.to_lottie()} })); let bez_target = bezier_lottie.layers[0].shapes[0].it; bez_target.splice(0, bez_target.length - 2, ...out_shapes); lottie_player_36_bezier.reload(); this.set_json('playground_36_2_bezier', out_shapes[0].ks.k); }, {} ); Zig Zag See Zig Zag . Zig Zag Amplitude 10 Frequency 10 Point Type Point Smooth Star Roundness 0 Rotation 0 Points 5 Stroke Width 3 Show JSON function angle_mean(a, b) { if ( Math.abs(a-b) > Math.PI ) return (a + b) / 2 + Math.PI; return (a + b) / 2; } function zig_zag_corner(output_bezier, segment_before, segment_after, amplitude, direction, tangent_length) { let point; let angle; let tan_angle; // We use 0.01 and 0.99 instead of 0 and 1 because they yield better results if ( !segment_before ) { point = segment_after.points[0]; angle = segment_after.normal_angle(0.01); tan_angle = segment_after.tangent_angle(0.01); } else if ( !segment_after ) { point = segment_before.points[3]; angle = segment_before.normal_angle(0.99); tan_angle = segment_before.tangent_angle(0.99); } else { point = segment_after.points[0]; angle = angle_mean(segment_after.normal_angle(0.01), segment_before.normal_angle(0.99)); tan_angle = angle_mean(segment_after.tangent_angle(0.01), segment_before.tangent_angle(0.99)); } let vertex = output_bezier.add_vertex(point.add_polar(angle, direction * amplitude)); if ( tangent_length !== 0 ) { vertex.set_in_tangent(Point.polar(tan_angle, -tangent_length)); vertex.set_out_tangent(Point.polar(tan_angle, tangent_length)); } } function zig_zag_segment(output_bezier, segment, amplitude, frequency, direction, tangent_length) { for ( let i = 0; i < frequency; i++ ) { let f = (i + 1) / (frequency + 1); let t = segment.t_at_length_percent(f); let angle = segment.normal_angle(t); let point = segment.point(t); let vertex = output_bezier.add_vertex(point.add_polar(angle, direction * amplitude)); if ( tangent_length !== 0 ) { let tan_angle = segment.tangent_angle(t); vertex.set_in_tangent(Point.polar(tan_angle, -tangent_length)); vertex.set_out_tangent(Point.polar(tan_angle, tangent_length)); } direction = -direction; } return direction; } function zig_zag_bezier(input_bezier, amplitude, frequency, smooth) { let output_bezier = new Bezier(); output_bezier.closed = input_bezier.closed; let count = input_bezier.segment_count(); if ( count == 0 ) return output_bezier; let direction = -1; let segment = input_bezier.closed ? input_bezier.segment(count - 1) : null; let next_segment = input_bezier.segment(0); next_segment.calculate_length_data(); let tangent_length = smooth ? next_segment.length / (frequency + 1) / 2 : 0; zig_zag_corner(output_bezier, segment, next_segment, amplitude, -1, tangent_length); for ( let i = 0; i < count; i++ ) { segment = next_segment; direction = zig_zag_segment(output_bezier, segment, amplitude, frequency, -direction, tangent_length); if ( i == count - 1 && !input_bezier.closed ) next_segment = null; else next_segment = input_bezier.segment((i + 1) % count); zig_zag_corner(output_bezier, segment, next_segment, amplitude, direction, tangent_length); } return output_bezier; } function zig_zag( // Beziers as collected from the other shapes collected_shapes, amplitude, frequency, point_type ) { // Ensure we have an integer number of segments frequency = Math.max(0, Math.round(frequency)); let result = []; for ( let input_bezier of collected_shapes ) result.push(zig_zag_bezier(input_bezier, amplitude, frequency, point_type === 2)); return result; } // Example invocation zig_zag([convert_shape(star)], modifier.s.k, modifier.r.k, modifier.pt.k); function angle_mean(a, b) { if ( Math.abs(a-b) > Math.PI ) return (a + b) / 2 + Math.PI; return (a + b) / 2; } function zig_zag_corner(output_bezier, segment_before, segment_after, amplitude, direction, tangent_length) { let point; let angle; let tan_angle; // We use 0.01 and 0.99 instead of 0 and 1 because they yield better results if ( !segment_before ) { point = segment_after.points[0]; angle = segment_after.normal_angle(0.01); tan_angle = segment_after.tangent_angle(0.01); } else if ( !segment_after ) { point = segment_before.points[3]; angle = segment_before.normal_angle(0.99); tan_angle = segment_before.tangent_angle(0.99); } else { point = segment_after.points[0]; angle = angle_mean(segment_after.normal_angle(0.01), segment_before.normal_angle(0.99)); tan_angle = angle_mean(segment_after.tangent_angle(0.01), segment_before.tangent_angle(0.99)); } let vertex = output_bezier.add_vertex(point.add_polar(angle, direction * amplitude)); if ( tangent_length !== 0 ) { vertex.set_in_tangent(Point.polar(tan_angle, -tangent_length)); vertex.set_out_tangent(Point.polar(tan_angle, tangent_length)); } } function zig_zag_segment(output_bezier, segment, amplitude, frequency, direction, tangent_length) { for ( let i = 0; i < frequency; i++ ) { let f = (i + 1) / (frequency + 1); let t = segment.t_at_length_percent(f); let angle = segment.normal_angle(t); let point = segment.point(t); let vertex = output_bezier.add_vertex(point.add_polar(angle, direction * amplitude)); if ( tangent_length !== 0 ) { let tan_angle = segment.tangent_angle(t); vertex.set_in_tangent(Point.polar(tan_angle, -tangent_length)); vertex.set_out_tangent(Point.polar(tan_angle, tangent_length)); } direction = -direction; } return direction; } function zig_zag_bezier(input_bezier, amplitude, frequency, smooth) { let output_bezier = new Bezier(); output_bezier.closed = input_bezier.closed; let count = input_bezier.segment_count(); if ( count == 0 ) return output_bezier; let direction = -1; let segment = input_bezier.closed ? input_bezier.segment(count - 1) : null; let next_segment = input_bezier.segment(0); next_segment.calculate_length_data(); let tangent_length = smooth ? next_segment.length / (frequency + 1) / 2 : 0; zig_zag_corner(output_bezier, segment, next_segment, amplitude, -1, tangent_length); for ( let i = 0; i < count; i++ ) { segment = next_segment; direction = zig_zag_segment(output_bezier, segment, amplitude, frequency, -direction, tangent_length); if ( i == count - 1 && !input_bezier.closed ) next_segment = null; else next_segment = input_bezier.segment((i + 1) % count); zig_zag_corner(output_bezier, segment, next_segment, amplitude, direction, tangent_length); } return output_bezier; } function zig_zag( // Beziers as collected from the other shapes collected_shapes, amplitude, frequency, point_type ) { // Ensure we have an integer number of segments frequency = Math.max(0, Math.round(frequency)); let result = []; for ( let input_bezier of collected_shapes ) result.push(zig_zag_bezier(input_bezier, amplitude, frequency, point_type === 2)); return result; } var lottie_player_37_bezier = new LottiePlayer('lottie_target_37_bezier', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"sh\", \"nm\": \"Shape\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [], \"i\": [], \"o\": []}}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}); var lottie_player_37 = new PlaygroundPlayer( 37, 'playground_37_8', 'lottie_target_37', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{9199543e-3552-4e51-a802-623f2a4a2ca1}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 222.72242736816406}, \"ir\": {\"a\": 0, \"k\": 111.36121368408203}, \"r\": {\"a\": 0, \"k\": 358.67291259765625}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"zz\", \"nm\": \"Zig Zag\", \"mn\": \"{b4af429a-546e-4728-a869-711a404c55ae}\", \"r\": {\"a\": 0, \"k\": 0}, \"s\": {\"a\": 0, \"k\": 10}, \"pt\": {\"a\": 0, \"k\": 2}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 3}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { let bezier_lottie = lottie_player_37_bezier.lottie; lottie.layers[0].shapes[0].it[1].s.k = data[\"Amplitude\"]; lottie.layers[0].shapes[0].it[1].r.k = data[\"Frequency\"]; lottie.layers[0].shapes[0].it[1].pt.k = Number(data[\"Point Type\"]); lottie.layers[0].shapes[0].it[0].pt.k = data[\"Points\"]; lottie.layers[0].shapes[0].it[0].r.k = data[\"Rotation\"]; lottie.layers[0].shapes[0].it[0].is.k = data[\"Roundness\"]; lottie.layers[0].shapes[0].it[0].os.k = data[\"Roundness\"]; lottie.layers[0].shapes[0].it[2].w.k = data[\"Stroke Width\"]; let star = lottie.layers[0].shapes[0].it[0]; bezier_lottie.layers[0].shapes[0].it[1].w.k = data[\"Stroke Width\"]; this.json_viewer_contents = lottie.layers[0].shapes[0].it[1]; let modifier = lottie.layers[0].shapes[0].it[1]; let bez_result = zig_zag([convert_shape(star)], modifier.s.k, modifier.r.k, modifier.pt.k); if ( !Array.isArray(bez_result) ) bez_result = [bez_result]; let out_shapes = bez_result.map(b => ({ ty: \"sh\", \"ks\": {a: 0, k: b.to_lottie()} })); let bez_target = bezier_lottie.layers[0].shapes[0].it; bez_target.splice(0, bez_target.length - 2, ...out_shapes); lottie_player_37_bezier.reload(); this.set_json('playground_37_8_bezier', out_shapes[0].ks.k); }, {} ); Offset Path See Offset Path . Offset Path Amount 10 Miter Limit 100 Line Join Miter Round Bevel Star Star Roundness 0 Show JSON /* Simple offset of a linear segment */ function linear_offset(p1, p2, amount) { let angle = Math.atan2(p2.x - p1.x, p2.y - p1.y); return [ p1.add_polar(angle, amount), p2.add_polar(angle, amount) ]; } /* Offset a bezier segment only works well if the segment is flat enough */ function offset_segment(segment, amount) { let [p0, p1a] = linear_offset(segment.points[0], segment.points[1], amount); let [p1b, p2b] = linear_offset(segment.points[1], segment.points[2], amount); let [p2a, p3] = linear_offset(segment.points[2], segment.points[3], amount); let p1 = line_intersection(p0, p1a, p1b, p2b) ?? p1a; let p2 = line_intersection(p2a, p3, p1b, p2b) ?? p2a; return new BezierSegment(p0, p1, p2, p3); } /* Join two segments */ function join_lines(output_bezier, seg1, seg2, line_join, miter_limit) { let p0 = seg1.points[3]; let p1 = seg2.points[0]; // Bevel if ( line_join == 3 ) return p0; // Connected, they don't need a joint if ( p0.is_equal(p1) ) return p0; let last_point = output_bezier.points[output_bezier.points.length - 1]; // Round if ( line_join == 2 ) { const ellipse_constant = 0.5519; let angle_out = seg1.tangent_angle(1); let angle_in = seg2.tangent_angle(0) + Math.PI; let center = line_intersection( p0, p0.add_polar(angle_out + Math.PI / 2, 100), p1, p1.add_polar(angle_out + Math.PI / 2, 100) ); let radius = center ? center.distance(p0) : p0.distance(p1) / 2; last_point.set_out_tangent(Point.polar(angle_out, 2 * radius * ellipse_constant)); output_bezier.add_vertex(p1) .set_in_tangent(Point.polar(angle_in, 2 * radius * ellipse_constant)); return p1; } // Miter let t0 = p0.is_equal(seg1.points[2]) ? seg1.points[0] : seg1.points[2]; let t1 = p1.is_equal(seg2.points[1]) ? seg2.points[3] : seg2.points[1]; let intersection = line_intersection(t0, p0, p1, t1); if ( intersection && intersection.distance(p0) < miter_limit ) { output_bezier.add_vertex(intersection); return intersection; } return p0; } function get_intersection(a, b) { let intersect = a.intersections(b); if ( intersect.length && fuzzy_compare(intersect[0], 1) ) intersect.shift(); if ( intersect.length ) return intersect[0]; return null; } function prune_segment_intersection(a, b) { let out_a = [...a]; let out_b = [...b]; let intersect = get_intersection(a[a.length-1], b[0]); if ( intersect ) { out_a[a.length-1] = a[a.length-1].split(intersect[0])[0]; out_b[0] = b[0].split(intersect[1])[1]; } if ( a.length > 1 && b.length > 1 ) { intersect = get_intersection(a[0], b[b.length - 1]); if ( intersect ) { return [ [a[0].split(intersect[0])[0]], [b[b.length-1].split(intersect[1])[1]], ]; } } return [out_a, out_b]; } function prune_intersections(segments) { for ( let i = 1; i < segments.length; i++ ) { [segments[i-1], segments[i]] = prune_segment_intersection(segments[i - 1], segments[i]); } if ( segments.length > 1 ) [segments[segments.length - 1], segments[0]] = prune_segment_intersection(segments[segments.length - 1], segments[0]); return segments; } function offset_segment_split(segment, amount) { /* We split each bezier segment into smaller pieces based on inflection points, this ensures the control point polygon is convex. (A cubic bezier can have none, one, or two inflection points) */ let flex = segment.inflection_points(); if ( flex.length == 0 ) { return [offset_segment(segment, amount)]; } else if ( flex.length == 1 || flex[1] == 1 ) { let [left, right] = segment.split(flex[0]); return [ offset_segment(left, amount), offset_segment(right, amount) ]; } else { let [left, mid_right] = segment.split(flex[0]); let t = (flex[1] - flex[0]) / (1 - flex[0]); let [mid, right] = mid_right.split(t); return [ offset_segment(left, amount), offset_segment(mid, amount), offset_segment(right, amount) ]; } } function offset_path( // Beziers as collected from the other shapes collected_shapes, amount, line_join, miter_limit, ) { let result = []; for ( let input_bezier of collected_shapes ) { let output_bezier = new Bezier(); output_bezier.closed = input_bezier.closed; let count = input_bezier.segment_count(); let multi_segments = []; for ( let i = 0; i < count; i++ ) multi_segments.push(offset_segment_split(input_bezier.segment(i), amount)); // Open paths are stroked rather than being simply offset if ( !input_bezier.closed ) { for ( let i = count - 1; i >= 0; i-- ) multi_segments.push(offset_segment_split(input_bezier.inverted_segment(i), amount)); } multi_segments = prune_intersections(multi_segments); // Add bezier segments to the output and apply line joints let last_point = null; let last_seg = null; for ( let multi_segment of multi_segments ) { if ( last_seg ) last_point = join_lines(output_bezier, last_seg, multi_segment[0], line_join, miter_limit); last_seg = multi_segment[multi_segment.length - 1]; for ( let segment of multi_segment ) { if ( segment.points[0].is_equal(last_point) ) { output_bezier.points[output_bezier.points.length - 1] .set_out_tangent(segment.points[1].sub(segment.points[0])); } else { output_bezier.add_vertex(segment.points[0]) .set_out_tangent(segment.points[1].sub(segment.points[0])); } output_bezier.add_vertex(segment.points[3]) .set_in_tangent(segment.points[2].sub(segment.points[3])); last_point = segment.points[3]; } } if ( multi_segments.length ) join_lines(output_bezier, last_seg, multi_segments[0][0], line_join, miter_limit); result.push(output_bezier); } return result; } // Example invocation offset_path([convert_shape(star)], modifier.a.k, modifier.lj, modifier.ml.k); /* Simple offset of a linear segment */ function linear_offset(p1, p2, amount) { let angle = Math.atan2(p2.x - p1.x, p2.y - p1.y); return [ p1.add_polar(angle, amount), p2.add_polar(angle, amount) ]; } /* Offset a bezier segment only works well if the segment is flat enough */ function offset_segment(segment, amount) { let [p0, p1a] = linear_offset(segment.points[0], segment.points[1], amount); let [p1b, p2b] = linear_offset(segment.points[1], segment.points[2], amount); let [p2a, p3] = linear_offset(segment.points[2], segment.points[3], amount); let p1 = line_intersection(p0, p1a, p1b, p2b) ?? p1a; let p2 = line_intersection(p2a, p3, p1b, p2b) ?? p2a; return new BezierSegment(p0, p1, p2, p3); } /* Join two segments */ function join_lines(output_bezier, seg1, seg2, line_join, miter_limit) { let p0 = seg1.points[3]; let p1 = seg2.points[0]; // Bevel if ( line_join == 3 ) return p0; // Connected, they don't need a joint if ( p0.is_equal(p1) ) return p0; let last_point = output_bezier.points[output_bezier.points.length - 1]; // Round if ( line_join == 2 ) { const ellipse_constant = 0.5519; let angle_out = seg1.tangent_angle(1); let angle_in = seg2.tangent_angle(0) + Math.PI; let center = line_intersection( p0, p0.add_polar(angle_out + Math.PI / 2, 100), p1, p1.add_polar(angle_out + Math.PI / 2, 100) ); let radius = center ? center.distance(p0) : p0.distance(p1) / 2; last_point.set_out_tangent(Point.polar(angle_out, 2 * radius * ellipse_constant)); output_bezier.add_vertex(p1) .set_in_tangent(Point.polar(angle_in, 2 * radius * ellipse_constant)); return p1; } // Miter let t0 = p0.is_equal(seg1.points[2]) ? seg1.points[0] : seg1.points[2]; let t1 = p1.is_equal(seg2.points[1]) ? seg2.points[3] : seg2.points[1]; let intersection = line_intersection(t0, p0, p1, t1); if ( intersection && intersection.distance(p0) < miter_limit ) { output_bezier.add_vertex(intersection); return intersection; } return p0; } function get_intersection(a, b) { let intersect = a.intersections(b); if ( intersect.length && fuzzy_compare(intersect[0], 1) ) intersect.shift(); if ( intersect.length ) return intersect[0]; return null; } function prune_segment_intersection(a, b) { let out_a = [...a]; let out_b = [...b]; let intersect = get_intersection(a[a.length-1], b[0]); if ( intersect ) { out_a[a.length-1] = a[a.length-1].split(intersect[0])[0]; out_b[0] = b[0].split(intersect[1])[1]; } if ( a.length > 1 && b.length > 1 ) { intersect = get_intersection(a[0], b[b.length - 1]); if ( intersect ) { return [ [a[0].split(intersect[0])[0]], [b[b.length-1].split(intersect[1])[1]], ]; } } return [out_a, out_b]; } function prune_intersections(segments) { for ( let i = 1; i < segments.length; i++ ) { [segments[i-1], segments[i]] = prune_segment_intersection(segments[i - 1], segments[i]); } if ( segments.length > 1 ) [segments[segments.length - 1], segments[0]] = prune_segment_intersection(segments[segments.length - 1], segments[0]); return segments; } function offset_segment_split(segment, amount) { /* We split each bezier segment into smaller pieces based on inflection points, this ensures the control point polygon is convex. (A cubic bezier can have none, one, or two inflection points) */ let flex = segment.inflection_points(); if ( flex.length == 0 ) { return [offset_segment(segment, amount)]; } else if ( flex.length == 1 || flex[1] == 1 ) { let [left, right] = segment.split(flex[0]); return [ offset_segment(left, amount), offset_segment(right, amount) ]; } else { let [left, mid_right] = segment.split(flex[0]); let t = (flex[1] - flex[0]) / (1 - flex[0]); let [mid, right] = mid_right.split(t); return [ offset_segment(left, amount), offset_segment(mid, amount), offset_segment(right, amount) ]; } } function offset_path( // Beziers as collected from the other shapes collected_shapes, amount, line_join, miter_limit, ) { let result = []; for ( let input_bezier of collected_shapes ) { let output_bezier = new Bezier(); output_bezier.closed = input_bezier.closed; let count = input_bezier.segment_count(); let multi_segments = []; for ( let i = 0; i < count; i++ ) multi_segments.push(offset_segment_split(input_bezier.segment(i), amount)); // Open paths are stroked rather than being simply offset if ( !input_bezier.closed ) { for ( let i = count - 1; i >= 0; i-- ) multi_segments.push(offset_segment_split(input_bezier.inverted_segment(i), amount)); } multi_segments = prune_intersections(multi_segments); // Add bezier segments to the output and apply line joints let last_point = null; let last_seg = null; for ( let multi_segment of multi_segments ) { if ( last_seg ) last_point = join_lines(output_bezier, last_seg, multi_segment[0], line_join, miter_limit); last_seg = multi_segment[multi_segment.length - 1]; for ( let segment of multi_segment ) { if ( segment.points[0].is_equal(last_point) ) { output_bezier.points[output_bezier.points.length - 1] .set_out_tangent(segment.points[1].sub(segment.points[0])); } else { output_bezier.add_vertex(segment.points[0]) .set_out_tangent(segment.points[1].sub(segment.points[0])); } output_bezier.add_vertex(segment.points[3]) .set_in_tangent(segment.points[2].sub(segment.points[3])); last_point = segment.points[3]; } } if ( multi_segments.length ) join_lines(output_bezier, last_seg, multi_segments[0][0], line_join, miter_limit); result.push(output_bezier); } return result; } var lottie_player_38_bezier = new LottiePlayer('lottie_target_38_bezier', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"sh\", \"nm\": \"Shape\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [], \"i\": [], \"o\": []}}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}); var lottie_player_38 = new PlaygroundPlayer( 38, 'playground_38_5', 'lottie_target_38', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{9199543e-3552-4e51-a802-623f2a4a2ca1}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 222.72242736816406}, \"ir\": {\"a\": 0, \"k\": 111.36121368408203}, \"r\": {\"a\": 0, \"k\": 358.67291259765625}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"op\", \"nm\": \"Offset Path\", \"mn\": \"{b4af429a-546e-4728-a869-711a404c55ae}\", \"a\": {\"a\": 0, \"k\": 10}, \"lj\": 2, \"ml\": {\"a\": 0, \"k\": 100}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 3}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { let bezier_lottie = lottie_player_38_bezier.lottie; lottie.layers[0].shapes[0].it[0].is.k = data[\"Star Roundness\"]; lottie.layers[0].shapes[0].it[0].os.k = data[\"Star Roundness\"]; lottie.layers[0].shapes[0].it[1].a.k = data[\"Amount\"]; lottie.layers[0].shapes[0].it[1].lj = Number(data[\"Line Join\"]); lottie.layers[0].shapes[0].it[1].ml.k = data[\"Miter Limit\"]; let star = lottie.layers[0].shapes[0].it[0]; bezier_lottie.layers[0].shapes[0].it[1].w.k = 3; this.json_viewer_contents = lottie.layers[0].shapes[0].it[1]; let modifier = lottie.layers[0].shapes[0].it[1]; let bez_result = offset_path([convert_shape(star)], modifier.a.k, modifier.lj, modifier.ml.k); if ( !Array.isArray(bez_result) ) bez_result = [bez_result]; let out_shapes = bez_result.map(b => ({ ty: \"sh\", \"ks\": {a: 0, k: b.to_lottie()} })); let bez_target = bezier_lottie.layers[0].shapes[0].it; bez_target.splice(0, bez_target.length - 2, ...out_shapes); lottie_player_38_bezier.reload(); this.set_json('playground_38_5_bezier', out_shapes[0].ks.k); }, {} ); Trim Path Start 0 End 50 Offset 0 Multiple Shapes Simultaneously Individually Show JSON function trim_path_gather_chunks(collected_shapes, multiple) { let chunks = []; // Shapes are handled as a single unit if ( multiple === 2 ) chunks.push({segments: [], length: 0}); for ( let input_bezier of collected_shapes ) { // Shapes are all affected separately if ( multiple === 1 ) chunks.push({segments: [], length: 0}); let chunk = chunks[chunks.length-1]; for ( let i = 0; i < input_bezier.segment_count(); i++ ) { let segment = input_bezier.segment(i); let length = segment.get_length(); chunk.segments.push(segment); chunk.length += length; } // Use null as a marker to start a new bezier if ( multiple == 2 ) chunk.segments.push(null); } return chunks; } function trim_path_chunk(chunk, start, end, output_shapes) { // Note: start and end have been normalized and have the offset applied // The offset itself was normalized into [0, 1] so this is always true: // 0 <= start < end <= 2 // Some offsets require us to handle different \"splits\" // We want each split to be a pair [s, e] such that // 0 <= s < e <= 1 var splits = []; if ( end <= 1 ) { // Simplest case, the segment is in [0, 1] splits.push([start, end]); } else if ( start > 1 ) { // The whole segment is outside [0, 1] splits.push([start-1, end-1]); } else { // The segment goes over the end point, so we need two splits splits.push([start, 1]); splits.push([0, end-1]); } // Each split is a separate bezier, all left to do is finding the // bezier segment to add to the output for ( let [s, e] of splits ) { let start_length = s * chunk.length; let start_t; let end_length = e * chunk.length; let prev_length = 0; let output_bezier = new Bezier(false); output_shapes.push(output_bezier); for ( let i = 0; i < chunk.segments.length; i++ ) { let segment = chunk.segments[i]; // New bezier marker found if ( segment === null ) { output_bezier = new Bezier(false); output_shapes.push(output_bezier); continue; } if ( segment.length >= end_length ) { let end_t = segment.t_at_length(end_length); if ( segment.length >= start_length ) { start_t = segment.t_at_length(start_length); segment = segment.split(start_t)[1]; end_t = (end_t - start_t) / (1 - start_t); } output_bezier.add_segment(segment.split(end_t)[0], false); break; } if ( start_t === undefined ) { if ( segment.length >= start_length ) { start_t = segment.t_at_length(start_length); output_bezier.add_segment(segment.split(start_t)[1], false); } } else { output_bezier.add_segment(segment, true); } start_length -= segment.length; end_length -= segment.length; } } } function trim_path( collected_shapes, start, end, offset, multiple ) { // Normalize Inputs offset = offset / 360 % 1; if ( offset < 0 ) offset += 1; start = Math.min(1, Math.max(0, start / 100)); end = Math.min(1, Math.max(0, end / 100)); if ( end < start ) [start, end] = [end, start]; // Apply offset start += offset; end += offset; // Handle the degenerate cases if ( fuzzy_compare(start, end) ) return [new Bezier(false)]; if ( fuzzy_zero(start) && fuzzy_compare(end, 1) ) return collected_shapes; // Gather up the segments to trim let chunks = trim_path_gather_chunks(collected_shapes, multiple); let output_shapes = []; for ( let chunk of chunks ) trim_path_chunk(chunk, start, end, output_shapes); return output_shapes; } // Example invocation trim_path(shapes, modifier.s.k, modifier.e.k, modifier.o.k, modifier.m); function trim_path_gather_chunks(collected_shapes, multiple) { let chunks = []; // Shapes are handled as a single unit if ( multiple === 2 ) chunks.push({segments: [], length: 0}); for ( let input_bezier of collected_shapes ) { // Shapes are all affected separately if ( multiple === 1 ) chunks.push({segments: [], length: 0}); let chunk = chunks[chunks.length-1]; for ( let i = 0; i < input_bezier.segment_count(); i++ ) { let segment = input_bezier.segment(i); let length = segment.get_length(); chunk.segments.push(segment); chunk.length += length; } // Use null as a marker to start a new bezier if ( multiple == 2 ) chunk.segments.push(null); } return chunks; } function trim_path_chunk(chunk, start, end, output_shapes) { // Note: start and end have been normalized and have the offset applied // The offset itself was normalized into [0, 1] so this is always true: // 0 <= start < end <= 2 // Some offsets require us to handle different \"splits\" // We want each split to be a pair [s, e] such that // 0 <= s < e <= 1 var splits = []; if ( end <= 1 ) { // Simplest case, the segment is in [0, 1] splits.push([start, end]); } else if ( start > 1 ) { // The whole segment is outside [0, 1] splits.push([start-1, end-1]); } else { // The segment goes over the end point, so we need two splits splits.push([start, 1]); splits.push([0, end-1]); } // Each split is a separate bezier, all left to do is finding the // bezier segment to add to the output for ( let [s, e] of splits ) { let start_length = s * chunk.length; let start_t; let end_length = e * chunk.length; let prev_length = 0; let output_bezier = new Bezier(false); output_shapes.push(output_bezier); for ( let i = 0; i < chunk.segments.length; i++ ) { let segment = chunk.segments[i]; // New bezier marker found if ( segment === null ) { output_bezier = new Bezier(false); output_shapes.push(output_bezier); continue; } if ( segment.length >= end_length ) { let end_t = segment.t_at_length(end_length); if ( segment.length >= start_length ) { start_t = segment.t_at_length(start_length); segment = segment.split(start_t)[1]; end_t = (end_t - start_t) / (1 - start_t); } output_bezier.add_segment(segment.split(end_t)[0], false); break; } if ( start_t === undefined ) { if ( segment.length >= start_length ) { start_t = segment.t_at_length(start_length); output_bezier.add_segment(segment.split(start_t)[1], false); } } else { output_bezier.add_segment(segment, true); } start_length -= segment.length; end_length -= segment.length; } } } function trim_path( collected_shapes, start, end, offset, multiple ) { // Normalize Inputs offset = offset / 360 % 1; if ( offset < 0 ) offset += 1; start = Math.min(1, Math.max(0, start / 100)); end = Math.min(1, Math.max(0, end / 100)); if ( end < start ) [start, end] = [end, start]; // Apply offset start += offset; end += offset; // Handle the degenerate cases if ( fuzzy_compare(start, end) ) return [new Bezier(false)]; if ( fuzzy_zero(start) && fuzzy_compare(end, 1) ) return collected_shapes; // Gather up the segments to trim let chunks = trim_path_gather_chunks(collected_shapes, multiple); let output_shapes = []; for ( let chunk of chunks ) trim_path_chunk(chunk, start, end, output_shapes); return output_shapes; } var lottie_player_39_bezier = new LottiePlayer('lottie_target_39_bezier', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"sh\", \"nm\": \"Shape\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [], \"i\": [], \"o\": []}}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}); var lottie_player_39 = new PlaygroundPlayer( 39, 'playground_39_5', 'lottie_target_39', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [128, 128]}, \"or\": {\"a\": 0, \"k\": 100}, \"ir\": {\"a\": 0, \"k\": 50}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{74587b40-1ef1-445d-b9ab-02b8a42a96aa}\", \"p\": {\"a\": 0, \"k\": [384, 128]}, \"s\": {\"a\": 0, \"k\": [200, 200]}}, {\"ty\": \"rc\", \"nm\": \"Rect\", \"mn\": \"{0776f2df-2619-415c-b10d-f648f2edfa0f}\", \"d\": 1, \"p\": {\"a\": 0, \"k\": [128, 384]}, \"s\": {\"a\": 0, \"k\": [200, 200]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"sr\", \"nm\": \"Triangle\", \"mn\": \"{db373594-d0ae-44ff-9295-30ff72616af2}\", \"p\": {\"a\": 0, \"k\": [384, 384]}, \"or\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 3}, \"sy\": 2, \"os\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"tm\", \"nm\": \"Trim Path\", \"mn\": \"{dcd7570f-5105-485b-bd43-42ad990b01e8}\", \"s\": {\"a\": 0, \"k\": 0}, \"e\": {\"a\": 0, \"k\": 50}, \"o\": {\"a\": 0, \"k\": 0}, \"m\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 20}}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { let bezier_lottie = lottie_player_39_bezier.lottie; lottie.layers[0].shapes[4].s.k = data[\"Start\"]; lottie.layers[0].shapes[4].e.k = data[\"End\"]; lottie.layers[0].shapes[4].o.k = data[\"Offset\"]; lottie.layers[0].shapes[4].m = Number(data[\"Multiple Shapes\"]); let siblings = bezier_lottie.layers[0].shapes[0].it; siblings[siblings.length-2].w.k = 20; let shapes = []; for ( let i = 0; i < 4; i++ ) shapes.push(convert_shape(lottie.layers[0].shapes[i])); this.json_viewer_contents = lottie.layers[0].shapes[4]; let modifier = lottie.layers[0].shapes[4]; let bez_result = trim_path(shapes, modifier.s.k, modifier.e.k, modifier.o.k, modifier.m); if ( !Array.isArray(bez_result) ) bez_result = [bez_result]; let out_shapes = bez_result.map(b => ({ ty: \"sh\", \"ks\": {a: 0, k: b.to_lottie()} })); let bez_target = bezier_lottie.layers[0].shapes[0].it; bez_target.splice(0, bez_target.length - 2, ...out_shapes); lottie_player_39_bezier.reload(); this.set_json('playground_39_5_bezier', out_shapes[0].ks.k); }, {} ); Transform This is how to convert a transform object into a matrix. Assuming the matrix a c 0 0 b d 0 0 0 0 1 0 tx ty 0 1 The names a , b , etc are the ones commonly used for CSS transforms . 4D matrix to allow for 3D transforms, even though currently lottie only supports 2D graphics. Multiplications are right multiplications ( Next = Previous * StepOperation ). If your transform is transposed ( tx , ty are on the last column), perform left multiplication instead. Perform the following operations on a matrix starting from the identity matrix (or the parent object's transform matrix): Translate by -a : 1 0 0 0 0 1 0 0 0 0 1 0 -a[0] -a[1] 0 1 Scale by s/100 : s[0]/100 0 0 0 0 s[1]/100 0 0 0 0 1 0 0 0 0 1 Rotate by -sa (can be skipped if not skewing) cos(-sa) sin(-sa) 0 0 -sin(-sa) cos(-sa) 0 0 0 0 1 0 0 0 0 1 Skew by sk (can be skipped if not skewing) 1 tan(-sk) 0 0 0 1 0 0 0 0 1 0 0 0 0 1 Rotate by sa (can be skipped if not skewing) cos(sa) sin(sa) 0 0 -sin(sa) cos(sa) 0 0 0 0 1 0 0 0 0 1 Rotate by -r cos(-r) sin(-r) 0 0 -sin(-r) cos(-r) 0 0 0 0 1 0 0 0 0 1 If you are handling an auto orient layer, evaluate and apply auto-orient rotation. Translate by p 1 0 0 0 0 1 0 0 0 0 1 0 p[0] p[1] 0 1 Anchor X 256 Anchor Y 256 Position X 256 Position Y 256 Scale X 100 Scale Y 100 Rotation 0 Skew 0 Skew Angle 0 Opacity 100 Show JSON var lottie_player_40 = new PlaygroundPlayer( 40, 'playground_40_11', 'lottie_target_40', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{a3bb98c7-d0dd-4484-b6da-74a0e70eaf2f}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 2, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Anchor\", \"mn\": \"{04f9b742-3603-49fa-9552-ea04de1a3f33}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{4251e46a-bb13-464b-913c-e67c44a218da}\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{7d3070ed-88a3-41aa-a62e-7db8df1bd312}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.9411764705882353, 0.11372549019607843, 0.0392156862745098]}, \"r\": 1}]}, {\"ddd\": 0, \"ty\": 4, \"ind\": 1, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Transformed\", \"mn\": \"{d00298c4-66b4-4ae4-a730-22c1eb85c188}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}, \"sk\": {\"a\": 0, \"k\": 0}, \"sa\": {\"a\": 0, \"k\": 0}}, \"shapes\": [{\"ty\": \"rc\", \"nm\": \"Rectangle 1\", \"mn\": \"{bf8ad877-113b-4df8-a2e2-3bb4af32edf7}\", \"p\": {\"a\": 0, \"k\": [252.75223880597017, 250.60298507462684]}, \"s\": {\"a\": 0, \"k\": [319.8089552238806, 330.98507462686564]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"nm\": \"Fill 1\", \"mn\": \"{b9040dc8-0753-4a6e-b5f1-d508d17bbd4f}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}, \"r\": 1}]}, {\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Reference\", \"mn\": \"{8f351be7-8a51-4310-9dc3-59ed21594815}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"mn\": \"{cb4f7b74-bed1-493b-a0e6-01b00566aedd}\", \"p\": {\"a\": 0, \"k\": [252.75223880597017, 250.60298507462684]}, \"s\": {\"a\": 0, \"k\": [319.8089552238806, 330.98507462686564]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{05064670-7e14-4141-89c1-e0f0f3a1c57d}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.1607843137254902, 0.1843137254901961, 0.4588235294117647]}, \"r\": 1}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { if ( lottie.layers.length == 3 ) { lottie.layers.splice(1, 0, { \"ty\": 4, \"st\": 0, \"ip\": 0, \"op\": 180, \"ks\": {}, \"shapes\": [ { \"ty\": \"sh\", \"ks\": { \"k\": { \"c\": true, \"v\": [], \"i\": [[0, 0], [0, 0], [0, 0], [0, 0]], \"o\": [[0, 0], [0, 0], [0, 0], [0, 0]], }, \"a\": 0 } }, { \"ty\": \"st\", \"o\": { \"a\": 0, \"k\": 100 }, \"w\": { \"a\": 0, \"k\": 2 }, \"c\": { \"a\": 0, \"k\": [ 0.078, 0.741, 0.431 ] } } ] }); } lottie.layers[0].ks.p.k[0] = data[\"Anchor X\"]; lottie.layers[2].ks.a.k[0] = data[\"Anchor X\"]; lottie.layers[0].ks.p.k[1] = data[\"Anchor Y\"]; lottie.layers[2].ks.a.k[1] = data[\"Anchor Y\"]; lottie.layers[2].ks.p.k[0] = data[\"Position X\"]; lottie.layers[2].ks.p.k[1] = data[\"Position Y\"]; lottie.layers[2].ks.s.k[0] = data[\"Scale X\"]; lottie.layers[2].ks.s.k[1] = data[\"Scale Y\"]; lottie.layers[2].ks.r.k = data[\"Rotation\"]; lottie.layers[2].ks.sk.k = data[\"Skew\"]; lottie.layers[2].ks.sa.k = data[\"Skew Angle\"]; lottie.layers[2].ks.o.k = data[\"Opacity\"]; var transform = new LottieMatrix(); transform.translate(-data[\"Anchor X\"], -data[\"Anchor Y\"]); transform.scale(data[\"Scale X\"] / 100, data[\"Scale Y\"] / 100); transform.skew(data[\"Skew\"] * Math.PI / 180, data[\"Skew Angle\"] * Math.PI / 180); transform.rotate(-data[\"Rotation\"] * Math.PI / 180); transform.translate(data[\"Position X\"], data[\"Position Y\"]); var cx = lottie.layers[2].shapes[0].p.k[0]; var cy = lottie.layers[2].shapes[0].p.k[1]; var rx = lottie.layers[2].shapes[0].s.k[0] / 2; var ry = lottie.layers[2].shapes[0].s.k[1] / 2; lottie.layers[1].shapes[0].ks.k.v = [ transform.map(cx - rx, cy - ry).slice(0, 2), transform.map(cx + rx, cy - ry).slice(0, 2), transform.map(cx + rx, cy + ry).slice(0, 2), transform.map(cx - rx, cy + ry).slice(0, 2) ]; this.json_viewer_contents = [ transform.elements.slice(0, 4), transform.elements.slice(4, 8), transform.elements.slice(8, 12), transform.elements.slice(12, 16) ].map(x => Array.from(x)) ; }, {} ); 3D Transform If you have a 3D transform, the process is similar, with a , p , s , using their 3D matrices, note that for p and a the Z axis is inverted. The rotation step is a bit more complicated, with the 2D rotation being equivalent to a Z rotation. The rotation step above is replaced with the following set of steps: Rotate by -rz cos(-r) sin(-r) 0 0 -sin(-r) cos(-r) 0 0 0 0 1 0 0 0 0 1 Rotate by ry cos(r) 0 sin(r) 0 0 1 0 0 -sin(r) 0 cos(-r) 0 0 0 1 Rotate by rx 1 0 0 0 0 cos(r) -sin(r) 0 0 -sin(r) cos(-r) 0 0 0 0 1 Then repeat the steps for or : Rotate by -or[2] (Z axis) cos(-r) sin(-r) 0 0 -sin(-r) cos(-r) 0 0 0 0 1 0 0 0 0 1 Rotate by or[1] (Y axis) cos(r) 0 sin(r) 0 0 1 0 0 -sin(r) 0 cos(-r) 0 0 0 1 Rotate by or[0] (X axis) 1 0 0 0 0 cos(r) -sin(r) 0 0 -sin(r) cos(-r) 0 0 0 0 1 Auto Orient Auto-orient is only relevant for layers that have ao set to 1 an animated position. You get the derivative of the position property at the current time as a pair ( dx , dy ), and find the angle with atan2(dy, dx) , then rotate by that angle clockwise: cos(-r) sin(-r) 0 0 -sin(-r) cos(-r) 0 0 0 0 1 0 0 0 0 1 Animated Properties Assuming a 1D property, a keyframe looks something like this: { \"t\": start_time, \"s\": [ start_value ], \"o\": { \"x\": [ ox ], \"y\": [ oy ] }, \"i\": { \"x\": [ ix ], \"y\": [ iy ] } } Where: t is the time at the start of the keyframe (in frames), s is the value at that time i and o are the in/out bezier tangents The transition between keyframes is defined by two keyframes, for simplicity we'll refer to the named values above plus end_time and end_value corresponding to t and s on the keyframe after the one listed. The transition is given as a cubic bezier curve whose x axis is time and the y axis is the interpolating factor between start_value and end_value . The four points of this bezier curve are: (0, 0), (ox, oy), (iy, iy), (1, 1). x is given by x = (current_time - start_time) / (end_time - start_time) . If the bezier is defined as a t 3 + b t 2 + c t + d = 0 then you need to find the cubic roots of a t 3 + b t 2 + c t + d - x = 0 to find the t corresponding to that x , (You only need to consider real roots in [0, 1]). Then you can find the y by evaluating the bezier at t . The final value is as follows: lerp(y, start_value, end_value) . Show JSON KeyframePreviewEditor.stand_alone(document.getElementById(\"editor_41\"), (lottie) => { var raw_json = JSON.stringify(lottie, undefined, 4); var pretty_json = hljs.highlight(\"json\", raw_json).value; document.getElementById(\"json_viewer_41\").innerHTML = pretty_json; }, {foreground: function () { if ( !this.x_input ) return; var t1 = this.points[0].out_tan.logical_coords(); var t2 = this.points[1].in_tan.logical_coords(); var seg = new BezierSegment( new Point(0, 0), new Point(t1.x, t1.y), new Point(t2.x, t2.y), new Point(1, 1) ); let x = Number(this.x_input.value); this.context.lineWidth = 1; this.context.strokeStyle = \"red\"; this.context.beginPath(); this.context.moveTo(...this.logical_to_canvas(x, 0)); this.context.lineTo(...this.logical_to_canvas(x, 1)); let t = seg.t_at_x(x); let y = seg.value(t).y; this.context.moveTo(...this.logical_to_canvas(0, y)); this.context.lineTo(...this.logical_to_canvas(1, y)); this.table_x.innerText = x; this.table_t.innerText = t; this.table_y.innerText = y; this.context.stroke(); }, init: function (editor, container) { var inp = container.appendChild(document.createElement(\"input\")); var style = \"width: \" + editor.bezier_editor.canvas.width + \"px\"; editor.bezier_editor.x_input = inp; inp.setAttribute(\"type\", \"range\"); inp.setAttribute(\"min\", \"0\"); inp.setAttribute(\"max\", \"1\"); inp.setAttribute(\"value\", \"0\"); inp.setAttribute(\"step\", \"0.01\"); inp.setAttribute(\"style\", style); inp.addEventListener(\"input\", () => editor.bezier_editor.draw_frame()); var table = container.appendChild(document.createElement(\"table\")); table.setAttribute(\"style\", style); for ( let v of \"xty\" ) { var tr = table.appendChild(document.createElement(\"tr\")); tr.appendChild(document.createElement(\"th\")).appendChild(document.createTextNode(v)); var td = tr.appendChild(document.createElement(\"td\")); td.setAttribute(\"style\", \"text-align: left; width: 90%;\"); editor.bezier_editor[\"table_\" + v] = td; } editor.bezier_editor.draw_frame(); }, }); Effects .webgl-shader { transform: scaleY(-1); } Fill Effect Opacity 1 Color Red 1 Green 0.9 Blue 0 Show JSON #version 100 uniform highp vec4 color; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; void main() { highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y); highp vec4 pixel = texture2D(texture_sampler, uv); gl_FragColor = color; gl_FragColor.a = 1.0; gl_FragColor *= pixel.a * color.a; } var lottie_shader_42 = new SinglePassShader(document.getElementById('lottie_target_42_canvas')); lottie_shader_42.set_fragment('#version 100\\n\\nuniform highp vec4 color;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\n\\nvoid main()\\n{\\n highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y);\\n highp vec4 pixel = texture2D(texture_sampler, uv);\\n\\n gl_FragColor = color;\\n gl_FragColor.a = 1.0;\\n gl_FragColor *= pixel.a * color.a;\\n}') var lottie_player_42 = new PlaygroundPlayer( 42, 'playground_42_5', 'lottie_target_42', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 21, \"ef\": [{\"ty\": 3, \"v\": {\"k\": [0, 0], \"a\": 0}}, {\"ty\": 7, \"v\": {\"k\": 0, \"a\": 0}}, {\"ty\": 2, \"v\": {\"k\": [1, 0.9, 0, 1], \"a\": 0}}, {\"ty\": 2, \"v\": {\"k\": [0, 0, 0, 1], \"a\": 0}}, {\"ty\": 7, \"v\": {\"k\": 0, \"a\": 0}}, {\"ty\": 0, \"v\": {\"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"a\": 0, \"k\": 0}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { let shader = lottie_shader_42; lottie.layers[0].ef[0].ef[6].v.k = data[\"Opacity\"]; lottie.layers[0].ef[0].ef[2].v.k[0] = data[\"Red\"]; lottie.layers[0].ef[0].ef[2].v.k[1] = data[\"Green\"]; lottie.layers[0].ef[0].ef[2].v.k[2] = data[\"Blue\"]; shader.set_uniform(\"color\", \"4fv\", [data[\"Red\"], data[\"Green\"], data[\"Blue\"], data[\"Opacity\"]]);this.json_viewer_contents = lottie.layers[0].ef[0]; shader.render(); }, {} ); Tritone Effect Bright Red 1 Green 1 Blue 1 Mid Red 0.3 Green 0.8 Blue 0.3 Dark Red 0 Green 0 Blue 0 Show JSON #version 100 uniform highp vec4 bright; uniform highp vec4 mid; uniform highp vec4 dark; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; void main() { highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y); highp vec4 pixel = texture2D(texture_sampler, uv); highp float lightness = sqrt(pixel.r * pixel.r * 0.299 + pixel.g * pixel.g * 0.587 + pixel.b * pixel.b * 0.114); // If you want results more similar to lottie-web use the lightness below // (this shader has a more accurate lightness calculation) // lightness = sqrt((pixel.r * pixel.r + pixel.g * pixel.g + pixel.b * pixel.b) / 3.0); if ( lightness < 0.5 ) { lightness *= 2.0; gl_FragColor = dark * (1.0 - lightness) + mid * lightness; } else { lightness = (lightness - 0.5) * 2.0; gl_FragColor = mid * (1.0 - lightness) + bright * lightness; } gl_FragColor *= pixel.a; } var lottie_shader_43 = new SinglePassShader(document.getElementById('lottie_target_43_canvas')); lottie_shader_43.set_fragment('#version 100\\n\\nuniform highp vec4 bright;\\nuniform highp vec4 mid;\\nuniform highp vec4 dark;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\n\\nvoid main()\\n{\\n highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y);\\n highp vec4 pixel = texture2D(texture_sampler, uv);\\n\\n highp float lightness = sqrt(pixel.r * pixel.r * 0.299 + pixel.g * pixel.g * 0.587 + pixel.b * pixel.b * 0.114);\\n // If you want results more similar to lottie-web use the lightness below\\n // (this shader has a more accurate lightness calculation)\\n // lightness = sqrt((pixel.r * pixel.r + pixel.g * pixel.g + pixel.b * pixel.b) / 3.0);\\n\\n if ( lightness < 0.5 )\\n {\\n lightness *= 2.0;\\n gl_FragColor = dark * (1.0 - lightness) + mid * lightness;\\n }\\n else\\n {\\n lightness = (lightness - 0.5) * 2.0;\\n gl_FragColor = mid * (1.0 - lightness) + bright * lightness;\\n }\\n\\n gl_FragColor *= pixel.a;\\n}') var lottie_player_43 = new PlaygroundPlayer( 43, 'playground_43_10', 'lottie_target_43', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 23, \"ef\": [{\"ty\": 2, \"v\": {\"k\": [1, 1, 1, 1], \"a\": 0}}, {\"ty\": 2, \"v\": {\"k\": [0.3, 0.8, 0.3, 1], \"a\": 0}}, {\"ty\": 2, \"v\": {\"k\": [0, 0, 0, 1], \"a\": 0}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { let shader = lottie_shader_43; lottie.layers[0].ef[0].ef[0].v.k[0] = data[\"r1\"]; lottie.layers[0].ef[0].ef[0].v.k[1] = data[\"g1\"]; lottie.layers[0].ef[0].ef[0].v.k[2] = data[\"b1\"]; lottie.layers[0].ef[0].ef[1].v.k[0] = data[\"r2\"]; lottie.layers[0].ef[0].ef[1].v.k[1] = data[\"g2\"]; lottie.layers[0].ef[0].ef[1].v.k[2] = data[\"b2\"]; lottie.layers[0].ef[0].ef[2].v.k[0] = data[\"r3\"]; lottie.layers[0].ef[0].ef[2].v.k[1] = data[\"g3\"]; lottie.layers[0].ef[0].ef[2].v.k[2] = data[\"b3\"]; shader.set_uniform(\"bright\", \"4fv\", [data[\"r1\"], data[\"g1\"], data[\"b1\"], 1]); shader.set_uniform(\"mid\", \"4fv\", [data[\"r2\"], data[\"g2\"], data[\"b2\"], 1]); shader.set_uniform(\"dark\", \"4fv\", [data[\"r3\"], data[\"g3\"], data[\"b3\"], 1]); this.json_viewer_contents = lottie.layers[0].ef[0]; shader.render(); }, {} ); Gaussian Blur This is a two-pass shader, the uniform pass is has value 0 on the first pass and value 1 on the second pass. Sigma 25 Direction Both Horizontal Vertical Wrap Show JSON #version 300 es #define PI 3.1415926538 precision highp float; uniform float sigma; uniform int direction; uniform int kernel_size; uniform bool wrap; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; uniform int pass; out vec4 FragColor; vec4 texture_value(vec2 uv) { if ( wrap ) { if ( uv.x < 0. ) uv.x = 1. - uv.x; if ( uv.x > 1. ) uv.x = uv.x - 1.; if ( uv.y < 0. ) uv.y = 1. - uv.y; if ( uv.y > 1. ) uv.y = uv.y - 1.; } else if ( uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1. ) { return vec4(0.0); } return texture(texture_sampler, uv); } vec4 blur_pass(float sigma, int kernel_size, vec2 uv, bool horizontal) { float side = float(kernel_size / 2); vec2 direction_vector = horizontal ? vec2(1.0, 0.0) / canvas_size.x : vec2(0.0, 1.0) / canvas_size.y; vec3 delta_gauss; delta_gauss.x = 1.0 / (sqrt(2.0 * PI) * sigma); delta_gauss.y = exp(-0.5 / (sigma * sigma)); delta_gauss.z = delta_gauss.y * delta_gauss.y; vec4 avg = vec4(0.0, 0.0, 0.0, 0.0); float sum = 0.0; vec4 pixel = texture_value(uv); avg += pixel * delta_gauss.x; sum += delta_gauss.x; delta_gauss.xy *= delta_gauss.yz; for ( float i = 1.0; i <= side; i++) { for ( float s = -1.0; s <= 1.0; s += 2.0 ) { vec2 pos = uv + s * i * direction_vector; pixel = texture_value(pos); avg += pixel * delta_gauss.x; } sum += 2.0 * delta_gauss.x; delta_gauss.xy *= delta_gauss.yz; } avg /= sum; return avg; } void main() { highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y); int actual_kernel_size = kernel_size == 0 ? int(0.5 + 6.0 * sigma) : kernel_size; const float multiplier = 0.25; if ( sigma == 0.0 ) { FragColor = texture(texture_sampler, uv); } else if ( pass == 0 ) { if ( direction != 3 ) FragColor = blur_pass(sigma * multiplier, actual_kernel_size, uv, true); else FragColor = texture(texture_sampler, uv); } else if ( pass == 1 ) { if ( direction != 2 ) FragColor = blur_pass(sigma * multiplier, actual_kernel_size, uv, false); else FragColor = texture(texture_sampler, uv); } } var lottie_shader_44 = new MultiPassShader(document.getElementById('lottie_target_44_canvas')); var program_44_0 = new ShaderProgram(lottie_shader_44.gl); program_44_0.set_fragment('#version 300 es\\n\\n#define PI 3.1415926538\\nprecision highp float;\\n\\nuniform float sigma;\\nuniform int direction;\\nuniform int kernel_size;\\nuniform bool wrap;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\nuniform int pass;\\n\\nout vec4 FragColor;\\n\\n\\nvec4 texture_value(vec2 uv)\\n{\\n if ( wrap )\\n {\\n if ( uv.x < 0. ) uv.x = 1. - uv.x;\\n if ( uv.x > 1. ) uv.x = uv.x - 1.;\\n if ( uv.y < 0. ) uv.y = 1. - uv.y;\\n if ( uv.y > 1. ) uv.y = uv.y - 1.;\\n }\\n else if ( uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1. )\\n {\\n return vec4(0.0);\\n }\\n\\n return texture(texture_sampler, uv);\\n}\\n\\n\\nvec4 blur_pass(float sigma, int kernel_size, vec2 uv, bool horizontal)\\n{\\n float side = float(kernel_size / 2);\\n\\n vec2 direction_vector = horizontal ?\\n vec2(1.0, 0.0) / canvas_size.x :\\n vec2(0.0, 1.0) / canvas_size.y;\\n\\n vec3 delta_gauss;\\n delta_gauss.x = 1.0 / (sqrt(2.0 * PI) * sigma);\\n delta_gauss.y = exp(-0.5 / (sigma * sigma));\\n delta_gauss.z = delta_gauss.y * delta_gauss.y;\\n\\n vec4 avg = vec4(0.0, 0.0, 0.0, 0.0);\\n float sum = 0.0;\\n\\n vec4 pixel = texture_value(uv);\\n avg += pixel * delta_gauss.x;\\n sum += delta_gauss.x;\\n delta_gauss.xy *= delta_gauss.yz;\\n\\n for ( float i = 1.0; i <= side; i++)\\n {\\n for ( float s = -1.0; s <= 1.0; s += 2.0 )\\n {\\n vec2 pos = uv + s * i * direction_vector;\\n pixel = texture_value(pos);\\n avg += pixel * delta_gauss.x;\\n }\\n sum += 2.0 * delta_gauss.x;\\n delta_gauss.xy *= delta_gauss.yz;\\n }\\n\\n avg /= sum;\\n\\n return avg;\\n}\\n\\n\\nvoid main()\\n{\\n highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y);\\n\\n int actual_kernel_size = kernel_size == 0 ? int(0.5 + 6.0 * sigma) : kernel_size;\\n\\n const float multiplier = 0.25;\\n\\n if ( sigma == 0.0 )\\n {\\n FragColor = texture(texture_sampler, uv);\\n }\\n else if ( pass == 0 )\\n {\\n if ( direction != 3 )\\n FragColor = blur_pass(sigma * multiplier, actual_kernel_size, uv, true);\\n else\\n FragColor = texture(texture_sampler, uv);\\n }\\n else if ( pass == 1 )\\n {\\n if ( direction != 2 )\\n FragColor = blur_pass(sigma * multiplier, actual_kernel_size, uv, false);\\n else\\n FragColor = texture(texture_sampler, uv);\\n }\\n}') lottie_shader_44.add_pass(program_44_0, {\"pass\": [\"1i\", 0]}) lottie_shader_44.add_pass(program_44_0, {\"pass\": [\"1i\", 1]}) var lottie_player_44 = new PlaygroundPlayer( 44, 'playground_44_4', 'lottie_target_44', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 29, \"en\": 1, \"ef\": [{\"ty\": 0, \"v\": {\"a\": 0, \"k\": 25}}, {\"ty\": 0, \"v\": {\"k\": 0, \"a\": 0}}, {\"ty\": 4, \"v\": {\"k\": 0, \"a\": 0}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { let shader = lottie_shader_44; lottie.layers[0].ef[0].ef[0].v.k = data[\"Sigma\"]; lottie.layers[0].ef[0].ef[1].v.k = Number(data[\"Direction\"]); lottie.layers[0].ef[0].ef[2].v.k = Number(data[\"Wrap\"]); for ( let pass of [0, 1] ) { shader.set_uniform(pass, \"sigma\", \"1f\", data[\"Sigma\"]); shader.set_uniform(pass, \"direction\", \"1i\", data[\"Direction\"]); shader.set_uniform(pass, \"wrap\", \"1i\", data[\"Wrap\"]); } this.json_viewer_contents = lottie.layers[0].ef[0]; shader.render(); }, {} ); Drop Shadow Effect The effect below is split into multiple shaders: First it generates the shadow Then it has a 2 pass gaussian blur (simplified from the example above) Finally, it composites the original image on top of the blurred shadow Red 0 Green 0 Blue 0 Opacity 128 Angle 135 Distance 10 Blur 7 Show JSON #version 300 es #define PI 3.1415926538 uniform highp vec4 color; uniform mediump float angle; uniform mediump float distance; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; out highp vec4 FragColor; void main() { // Base pixel value highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y); highp vec4 pixel = texture(texture_sampler, uv); // Pixel value at the given offset mediump float radians = -angle * PI / 180.0 + PI / 2.0; highp vec2 shadow_uv = vec2( (gl_FragCoord.x - distance * cos(radians)) / canvas_size.x, 1.0 - (gl_FragCoord.y - distance * sin(radians)) / canvas_size.y ); highp vec4 shadow_pixel = texture(texture_sampler, shadow_uv); // Colorize shadow highp vec4 shadow_color; if ( shadow_uv.x >= 0.0 && shadow_uv.x <= 1.0 && shadow_uv.y >= 0.0 && shadow_uv.y <= 1.0 ) { shadow_color = color; shadow_color.a = 1.0; shadow_color *= shadow_pixel.a * color.a / 255.0; } // Apply shadow below the base pixel FragColor = shadow_color; //pixel * pixel.a + shadow_color * (1.0 - pixel.a); } #version 300 es #define PI 3.1415926538 precision highp float; uniform float sigma; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; uniform int pass; out vec4 FragColor; vec4 blur_pass(float sigma, int kernel_size, vec2 uv, bool horizontal) { float side = float(kernel_size / 2); vec2 direction_vector = horizontal ? vec2(1.0, 0.0) / canvas_size.x : vec2(0.0, 1.0) / canvas_size.y; vec3 delta_gauss; delta_gauss.x = 1.0 / (sqrt(2.0 * PI) * sigma); delta_gauss.y = exp(-0.5 / (sigma * sigma)); delta_gauss.z = delta_gauss.y * delta_gauss.y; vec4 avg = vec4(0.0, 0.0, 0.0, 0.0); float sum = 0.0; vec4 pixel = texture(texture_sampler, uv); avg += pixel * delta_gauss.x; sum += delta_gauss.x; delta_gauss.xy *= delta_gauss.yz; for ( float i = 1.0; i <= side; i++) { for ( float s = -1.0; s <= 1.0; s += 2.0 ) { vec2 pos = uv + s * i * direction_vector; pixel = texture(texture_sampler, pos); avg += pixel * delta_gauss.x; } sum += 2.0 * delta_gauss.x; delta_gauss.xy *= delta_gauss.yz; } avg /= sum; return avg; } void main() { highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y); int kernel_size = int(0.5 + 6.0 * sigma); const float multiplier = 0.25; if ( sigma == 0.0 ) FragColor = texture(texture_sampler, uv); else if ( pass == 1 ) FragColor = blur_pass(sigma * multiplier, kernel_size, uv, true); else if ( pass == 2 ) FragColor = blur_pass(sigma * multiplier, kernel_size, uv, false); } #version 300 es precision highp float; uniform sampler2D original; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; out vec4 FragColor; vec4 alpha_blend(vec4 top, vec4 bottom) { float comp_alpha = bottom.a * (1.0 - top.a); vec4 result; result.a = top.a + comp_alpha; result.rgb = (top.rgb * top.a + bottom.rgb * comp_alpha) / result.a; return result; } void main() { highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y); FragColor = alpha_blend( texture(original, uv), texture(texture_sampler, vec2(uv.x, 1.0 - uv.y)) ); } var lottie_shader_45 = new MultiPassShader(document.getElementById('lottie_target_45_canvas')); lottie_shader_45.add_pass_source('#version 300 es\\n#define PI 3.1415926538\\n\\nuniform highp vec4 color;\\nuniform mediump float angle;\\nuniform mediump float distance;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\n\\nout highp vec4 FragColor;\\n\\nvoid main()\\n{\\n // Base pixel value\\n highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y);\\n highp vec4 pixel = texture(texture_sampler, uv);\\n\\n // Pixel value at the given offset\\n mediump float radians = -angle * PI / 180.0 + PI / 2.0;\\n highp vec2 shadow_uv = vec2(\\n (gl_FragCoord.x - distance * cos(radians)) / canvas_size.x,\\n 1.0 - (gl_FragCoord.y - distance * sin(radians)) / canvas_size.y\\n );\\n highp vec4 shadow_pixel = texture(texture_sampler, shadow_uv);\\n\\n // Colorize shadow\\n highp vec4 shadow_color;\\n\\n if ( shadow_uv.x >= 0.0 && shadow_uv.x <= 1.0 && shadow_uv.y >= 0.0 && shadow_uv.y <= 1.0 )\\n {\\n shadow_color = color;\\n shadow_color.a = 1.0;\\n shadow_color *= shadow_pixel.a * color.a / 255.0;\\n }\\n\\n // Apply shadow below the base pixel\\n FragColor = shadow_color; //pixel * pixel.a + shadow_color * (1.0 - pixel.a);\\n}', {\"pass\": [\"1i\", 0]}) var program_45_1 = new ShaderProgram(lottie_shader_45.gl); program_45_1.set_fragment('#version 300 es\\n\\n#define PI 3.1415926538\\nprecision highp float;\\n\\nuniform float sigma;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\nuniform int pass;\\n\\nout vec4 FragColor;\\n\\nvec4 blur_pass(float sigma, int kernel_size, vec2 uv, bool horizontal)\\n{\\n float side = float(kernel_size / 2);\\n\\n vec2 direction_vector = horizontal ?\\n vec2(1.0, 0.0) / canvas_size.x :\\n vec2(0.0, 1.0) / canvas_size.y;\\n\\n vec3 delta_gauss;\\n delta_gauss.x = 1.0 / (sqrt(2.0 * PI) * sigma);\\n delta_gauss.y = exp(-0.5 / (sigma * sigma));\\n delta_gauss.z = delta_gauss.y * delta_gauss.y;\\n\\n vec4 avg = vec4(0.0, 0.0, 0.0, 0.0);\\n float sum = 0.0;\\n\\n vec4 pixel = texture(texture_sampler, uv);\\n avg += pixel * delta_gauss.x;\\n sum += delta_gauss.x;\\n delta_gauss.xy *= delta_gauss.yz;\\n\\n for ( float i = 1.0; i <= side; i++)\\n {\\n for ( float s = -1.0; s <= 1.0; s += 2.0 )\\n {\\n vec2 pos = uv + s * i * direction_vector;\\n pixel = texture(texture_sampler, pos);\\n avg += pixel * delta_gauss.x;\\n }\\n sum += 2.0 * delta_gauss.x;\\n delta_gauss.xy *= delta_gauss.yz;\\n }\\n\\n avg /= sum;\\n\\n return avg;\\n}\\n\\n\\nvoid main()\\n{\\n highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y);\\n\\n int kernel_size = int(0.5 + 6.0 * sigma);\\n\\n const float multiplier = 0.25;\\n\\n if ( sigma == 0.0 )\\n FragColor = texture(texture_sampler, uv);\\n else if ( pass == 1 )\\n FragColor = blur_pass(sigma * multiplier, kernel_size, uv, true);\\n else if ( pass == 2 )\\n FragColor = blur_pass(sigma * multiplier, kernel_size, uv, false);\\n}') lottie_shader_45.add_pass(program_45_1, {\"pass\": [\"1i\", 1]}) lottie_shader_45.add_pass(program_45_1, {\"pass\": [\"1i\", 2]}) lottie_shader_45.add_pass_source('#version 300 es\\n\\nprecision highp float;\\n\\nuniform sampler2D original;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\n\\nout vec4 FragColor;\\n\\nvec4 alpha_blend(vec4 top, vec4 bottom)\\n{\\n float comp_alpha = bottom.a * (1.0 - top.a);\\n vec4 result;\\n result.a = top.a + comp_alpha;\\n result.rgb = (top.rgb * top.a + bottom.rgb * comp_alpha) / result.a;\\n return result;\\n}\\n\\nvoid main()\\n{\\n highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y);\\n\\n FragColor = alpha_blend(\\n texture(original, uv),\\n texture(texture_sampler, vec2(uv.x, 1.0 - uv.y))\\n );\\n}', {\"pass\": [\"1i\", 3]}) var lottie_player_45 = new PlaygroundPlayer( 45, 'playground_45_8', 'lottie_target_45', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 25, \"ef\": [{\"ty\": 2, \"v\": {\"k\": [0, 0, 0, 1], \"a\": 0}}, {\"ty\": 0, \"v\": {\"k\": 128, \"a\": 0}}, {\"ty\": 1, \"v\": {\"k\": 135, \"a\": 0}}, {\"ty\": 0, \"v\": {\"k\": 10, \"a\": 0}}, {\"ty\": 0, \"v\": {\"k\": 7, \"a\": 0}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { let shader = lottie_shader_45; lottie.layers[0].ef[0].ef[0].v.k[0] = data[\"Red\"]; lottie.layers[0].ef[0].ef[0].v.k[1] = data[\"Green\"]; lottie.layers[0].ef[0].ef[0].v.k[2] = data[\"Blue\"]; lottie.layers[0].ef[0].ef[1].v.k = data[\"Opacity\"]; lottie.layers[0].ef[0].ef[2].v.k = data[\"Angle\"]; lottie.layers[0].ef[0].ef[3].v.k = data[\"Distance\"]; lottie.layers[0].ef[0].ef[4].v.k = data[\"Blur\"]; shader.set_uniform(0, \"color\", \"4fv\", [data[\"Red\"], data[\"Green\"], data[\"Blue\"], data[\"Opacity\"]]); shader.set_uniform(0, \"angle\", \"1f\", data[\"Angle\"]); // 0.77 is just to take into account the canvas is 394 instead of 512 shader.set_uniform(0, \"distance\", \"1f\", data[\"Distance\"] * 0.77); shader.set_uniform(1, \"sigma\", \"1f\", data[\"Blur\"]); shader.set_uniform(2, \"sigma\", \"1f\", data[\"Blur\"]); shader.texture(\"/lottie-docs/examples/blep.png\").set_uniform(shader.passes[3].program, \"original\");this.json_viewer_contents = lottie.layers[0].ef[0]; shader.render(); }, {} ); Pro Levels Effect Composite In Black 0 In White 1 Gamma 1 Out Black 0 Out White 1 Red In Black 0 In White 1 Gamma 1 Out Black 0 Out White 1 Green In Black 0 In White 1 Gamma 1 Out Black 0 Out White 1 Blue In Black 0 In White 1 Gamma 1 Out Black 0 Out White 1 Show JSON #version 100 precision highp float; uniform highp float composite_in_black; uniform highp float composite_in_white; uniform highp float composite_gamma; uniform highp float composite_out_black; uniform highp float composite_out_white; uniform highp float red_in_black; uniform highp float red_in_white; uniform highp float red_gamma; uniform highp float red_out_black; uniform highp float red_out_white; uniform highp float green_in_black; uniform highp float green_in_white; uniform highp float green_gamma; uniform highp float green_out_black; uniform highp float green_out_white; uniform highp float blue_in_black; uniform highp float blue_in_white; uniform highp float blue_gamma; uniform highp float blue_out_black; uniform highp float blue_out_white; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; float adjust_channel(float value, float in_black, float in_white, float gamma, float out_black, float out_white) { float in_delta = in_white - in_black; float out_delta = out_white - out_black; if ( in_delta == 0.0 ) return out_black; // Clamp to input range if ( value <= in_black && value <= in_white ) return out_black; if ( value >= in_black && value >= in_white ) return out_white; // Apply adjustment return out_black + out_delta * pow((value - in_black) / in_delta, 1.0 / gamma); } void main() { // Base pixel value highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y); highp vec4 pixel = texture2D(texture_sampler, uv); // First Pass: composite pixel.rgb = vec3( adjust_channel(pixel.r, composite_in_black, composite_in_white, composite_gamma, composite_out_black, composite_out_white), adjust_channel(pixel.g, composite_in_black, composite_in_white, composite_gamma, composite_out_black, composite_out_white), adjust_channel(pixel.b, composite_in_black, composite_in_white, composite_gamma, composite_out_black, composite_out_white) ); // Second Pass: individual Channels pixel.rgb = vec3( adjust_channel(pixel.r, red_in_black, red_in_white, red_gamma, red_out_black, red_out_white), adjust_channel(pixel.g, green_in_black, green_in_white, green_gamma, green_out_black, green_out_white), adjust_channel(pixel.b, blue_in_black, blue_in_white, blue_gamma, blue_out_black, blue_out_white) ); gl_FragColor.rgb = pixel.rgb * pixel.a; gl_FragColor.a = pixel.a; } var lottie_shader_46 = new SinglePassShader(document.getElementById('lottie_target_46_canvas')); lottie_shader_46.set_fragment('#version 100\\nprecision highp float;\\n\\nuniform highp float composite_in_black;\\nuniform highp float composite_in_white;\\nuniform highp float composite_gamma;\\nuniform highp float composite_out_black;\\nuniform highp float composite_out_white;\\n\\nuniform highp float red_in_black;\\nuniform highp float red_in_white;\\nuniform highp float red_gamma;\\nuniform highp float red_out_black;\\nuniform highp float red_out_white;\\n\\nuniform highp float green_in_black;\\nuniform highp float green_in_white;\\nuniform highp float green_gamma;\\nuniform highp float green_out_black;\\nuniform highp float green_out_white;\\n\\nuniform highp float blue_in_black;\\nuniform highp float blue_in_white;\\nuniform highp float blue_gamma;\\nuniform highp float blue_out_black;\\nuniform highp float blue_out_white;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\n\\n\\nfloat adjust_channel(float value, float in_black, float in_white, float gamma, float out_black, float out_white)\\n{\\n float in_delta = in_white - in_black;\\n float out_delta = out_white - out_black;\\n if ( in_delta == 0.0 )\\n return out_black;\\n\\n // Clamp to input range\\n if ( value <= in_black && value <= in_white )\\n return out_black;\\n\\n if ( value >= in_black && value >= in_white )\\n return out_white;\\n\\n // Apply adjustment\\n return out_black + out_delta * pow((value - in_black) / in_delta, 1.0 / gamma);\\n}\\n\\n\\nvoid main()\\n{\\n // Base pixel value\\n highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y);\\n highp vec4 pixel = texture2D(texture_sampler, uv);\\n\\n // First Pass: composite\\n pixel.rgb = vec3(\\n adjust_channel(pixel.r, composite_in_black, composite_in_white, composite_gamma, composite_out_black, composite_out_white),\\n adjust_channel(pixel.g, composite_in_black, composite_in_white, composite_gamma, composite_out_black, composite_out_white),\\n adjust_channel(pixel.b, composite_in_black, composite_in_white, composite_gamma, composite_out_black, composite_out_white)\\n );\\n\\n // Second Pass: individual Channels\\n pixel.rgb = vec3(\\n adjust_channel(pixel.r, red_in_black, red_in_white, red_gamma, red_out_black, red_out_white),\\n adjust_channel(pixel.g, green_in_black, green_in_white, green_gamma, green_out_black, green_out_white),\\n adjust_channel(pixel.b, blue_in_black, blue_in_white, blue_gamma, blue_out_black, blue_out_white)\\n );\\n\\n gl_FragColor.rgb = pixel.rgb * pixel.a;\\n gl_FragColor.a = pixel.a;\\n}') var lottie_player_46 = new PlaygroundPlayer( 46, 'playground_46_21', 'lottie_target_46', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 24, \"ef\": [{\"ty\": 7, \"v\": {\"nm\": \"00 Dropdown\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"01\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"02\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_outwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"08\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"09 slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"r_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"r_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"r_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"r_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"r_outwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"15 slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"16 slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"g_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"g_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"g_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"g_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"g_outwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"22\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"23\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"b_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"b_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"b_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"b_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"b_outwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"29\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"a_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"a_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"a_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"a_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"a_outwhite slider\", \"a\": 0, \"k\": 1}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { let shader = lottie_shader_46; lottie.layers[0].ef[0].ef[3].v.k = data[\"Composite In Black\"]; lottie.layers[0].ef[0].ef[4].v.k = data[\"Composite In White\"]; lottie.layers[0].ef[0].ef[5].v.k = data[\"Composite Gamma\"]; lottie.layers[0].ef[0].ef[6].v.k = data[\"Composite Out Black\"]; lottie.layers[0].ef[0].ef[7].v.k = data[\"Composite Out White\"]; lottie.layers[0].ef[0].ef[10].v.k = data[\"Red In Black\"]; lottie.layers[0].ef[0].ef[11].v.k = data[\"Red In White\"]; lottie.layers[0].ef[0].ef[12].v.k = data[\"Red Gamma\"]; lottie.layers[0].ef[0].ef[13].v.k = data[\"Red Out Black\"]; lottie.layers[0].ef[0].ef[14].v.k = data[\"Red Out White\"]; lottie.layers[0].ef[0].ef[17].v.k = data[\"Green In Black\"]; lottie.layers[0].ef[0].ef[18].v.k = data[\"Green In White\"]; lottie.layers[0].ef[0].ef[19].v.k = data[\"Green Gamma\"]; lottie.layers[0].ef[0].ef[20].v.k = data[\"Green Out Black\"]; lottie.layers[0].ef[0].ef[21].v.k = data[\"Green Out White\"]; lottie.layers[0].ef[0].ef[24].v.k = data[\"Blue In Black\"]; lottie.layers[0].ef[0].ef[25].v.k = data[\"Blue In White\"]; lottie.layers[0].ef[0].ef[26].v.k = data[\"Blue Gamma\"]; lottie.layers[0].ef[0].ef[27].v.k = data[\"Blue Out Black\"]; lottie.layers[0].ef[0].ef[28].v.k = data[\"Blue Out White\"]; shader.set_uniform(\"composite_in_black\", \"1f\", data[\"Composite In Black\"]); shader.set_uniform(\"composite_in_white\", \"1f\", data[\"Composite In White\"]); shader.set_uniform(\"composite_gamma\", \"1f\", data[\"Composite Gamma\"]); shader.set_uniform(\"composite_out_black\", \"1f\", data[\"Composite Out Black\"]); shader.set_uniform(\"composite_out_white\", \"1f\", data[\"Composite Out White\"]); shader.set_uniform(\"red_in_black\", \"1f\", data[\"Red In Black\"]); shader.set_uniform(\"red_in_white\", \"1f\", data[\"Red In White\"]); shader.set_uniform(\"red_gamma\", \"1f\", data[\"Red Gamma\"]); shader.set_uniform(\"red_out_black\", \"1f\", data[\"Red Out Black\"]); shader.set_uniform(\"red_out_white\", \"1f\", data[\"Red Out White\"]); shader.set_uniform(\"green_in_black\", \"1f\", data[\"Green In Black\"]); shader.set_uniform(\"green_in_white\", \"1f\", data[\"Green In White\"]); shader.set_uniform(\"green_gamma\", \"1f\", data[\"Green Gamma\"]); shader.set_uniform(\"green_out_black\", \"1f\", data[\"Green Out Black\"]); shader.set_uniform(\"green_out_white\", \"1f\", data[\"Green Out White\"]); shader.set_uniform(\"blue_in_black\", \"1f\", data[\"Blue In Black\"]); shader.set_uniform(\"blue_in_white\", \"1f\", data[\"Blue In White\"]); shader.set_uniform(\"blue_gamma\", \"1f\", data[\"Blue Gamma\"]); shader.set_uniform(\"blue_out_black\", \"1f\", data[\"Blue Out Black\"]); shader.set_uniform(\"blue_out_white\", \"1f\", data[\"Blue Out White\"]);this.json_viewer_contents = lottie.layers[0].ef[0]; shader.render(); }, {} ); Matte3 Channel Red Green Blue Alpha Luma Hue Lightness Saturation Full Off Invert Stretch To Fit Show Mask Premultiply Mask Show JSON #version 100 precision highp float; uniform int channel; uniform int invert; uniform int premultiply_mask; uniform int show_mask; uniform sampler2D mask_layer; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; highp vec3 hsl(vec4 c) { float maxc = max(c.r, max(c.g, c.b)); float minc = min(c.r, min(c.g, c.b)); float h = 0.0; float s = 0.0; float l = (maxc + minc) / 2.0; if ( maxc != minc) { float d = maxc - minc; s = l > 0.5 ? d / (2.0 - d) : d / (maxc + minc); if ( maxc == c.r ) h = (c.g - c.b) / d + (c.g < c.b ? 6.0 : 0.0); else if ( maxc == c.g ) h = (c.b - c.r) / d + 2.0; else if ( maxc == c.b ) h = (c.r - c.g) / d + 4.0; h /= 6.0; } return vec3(h, s, l); } highp float opacity(vec4 pixel, int channel, int invert, int premultiply) { if ( premultiply == 1 ) pixel *= pixel.a; highp float opacity; if ( channel == 1 ) opacity = pixel.r; else if ( channel == 2 ) opacity = pixel.g; else if ( channel == 3 ) opacity = pixel.b; else if ( channel == 4 ) opacity = pixel.a; else if ( channel == 5 ) opacity = sqrt(pixel.r * pixel.r * 0.299 + pixel.g * pixel.g * 0.587 + pixel.b * pixel.b * 0.114); else if ( channel == 6 ) opacity = hsl(pixel).x; else if ( channel == 7 ) opacity = hsl(pixel).z; else if ( channel == 8 ) opacity = hsl(pixel).y; else if ( channel == 9 ) opacity = 1.0; else if ( channel == 10 ) opacity = 0.0; return invert == 1 ? 1.0 - opacity : opacity; } vec4 alpha_blend(vec4 top, vec4 bottom) { float comp_alpha = bottom.a * (1.0 - top.a); vec4 result; result.a = top.a + comp_alpha; result.rgb = (top.rgb * top.a + bottom.rgb * comp_alpha) / result.a; return result; } void main() { // Base pixel value highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y); highp vec4 pixel = texture2D(texture_sampler, uv); highp vec4 mask = texture2D(mask_layer, uv); gl_FragColor.a = pixel.a * opacity(mask, channel, invert, premultiply_mask); gl_FragColor.rgb = pixel.rgb * gl_FragColor.a; if ( show_mask == 1 ) gl_FragColor = alpha_blend(gl_FragColor, mask); } var lottie_shader_47 = new SinglePassShader(document.getElementById('lottie_target_47_canvas')); lottie_shader_47.set_fragment('#version 100\\nprecision highp float;\\n\\nuniform int channel;\\nuniform int invert;\\nuniform int premultiply_mask;\\nuniform int show_mask;\\nuniform sampler2D mask_layer;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\n\\nhighp vec3 hsl(vec4 c)\\n{\\n float maxc = max(c.r, max(c.g, c.b));\\n float minc = min(c.r, min(c.g, c.b));\\n float h = 0.0;\\n float s = 0.0;\\n float l = (maxc + minc) / 2.0;\\n\\n if ( maxc != minc)\\n {\\n float d = maxc - minc;\\n s = l > 0.5 ? d / (2.0 - d) : d / (maxc + minc);\\n if ( maxc == c.r )\\n h = (c.g - c.b) / d + (c.g < c.b ? 6.0 : 0.0);\\n else if ( maxc == c.g )\\n h = (c.b - c.r) / d + 2.0;\\n else if ( maxc == c.b )\\n h = (c.r - c.g) / d + 4.0;\\n\\n h /= 6.0;\\n }\\n\\n return vec3(h, s, l);\\n}\\n\\nhighp float opacity(vec4 pixel, int channel, int invert, int premultiply)\\n{\\n if ( premultiply == 1 )\\n pixel *= pixel.a;\\n\\n highp float opacity;\\n\\n if ( channel == 1 )\\n opacity = pixel.r;\\n else if ( channel == 2 )\\n opacity = pixel.g;\\n else if ( channel == 3 )\\n opacity = pixel.b;\\n else if ( channel == 4 )\\n opacity = pixel.a;\\n else if ( channel == 5 )\\n opacity = sqrt(pixel.r * pixel.r * 0.299 + pixel.g * pixel.g * 0.587 + pixel.b * pixel.b * 0.114);\\n else if ( channel == 6 )\\n opacity = hsl(pixel).x;\\n else if ( channel == 7 )\\n opacity = hsl(pixel).z;\\n else if ( channel == 8 )\\n opacity = hsl(pixel).y;\\n else if ( channel == 9 )\\n opacity = 1.0;\\n else if ( channel == 10 )\\n opacity = 0.0;\\n\\n\\n return invert == 1 ? 1.0 - opacity : opacity;\\n}\\n\\nvec4 alpha_blend(vec4 top, vec4 bottom)\\n{\\n float comp_alpha = bottom.a * (1.0 - top.a);\\n vec4 result;\\n result.a = top.a + comp_alpha;\\n result.rgb = (top.rgb * top.a + bottom.rgb * comp_alpha) / result.a;\\n return result;\\n}\\n\\nvoid main()\\n{\\n // Base pixel value\\n highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y);\\n highp vec4 pixel = texture2D(texture_sampler, uv);\\n\\n highp vec4 mask = texture2D(mask_layer, uv);\\n\\n\\n gl_FragColor.a = pixel.a * opacity(mask, channel, invert, premultiply_mask);\\n gl_FragColor.rgb = pixel.rgb * gl_FragColor.a;\\n\\n if ( show_mask == 1 )\\n gl_FragColor = alpha_blend(gl_FragColor, mask);\\n}') var lottie_player_47 = new PlaygroundPlayer( 47, 'playground_47_6', 'lottie_target_47', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}, {\"id\": \"thumbs-up\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/thumbs-up.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {}, \"ip\": 0, \"op\": 60, \"st\": 0, \"ind\": 0, \"ef\": [{\"ty\": 28, \"nm\": \"Set Matte\", \"np\": 8, \"mn\": \"ADBE Set Matte3\", \"ix\": 1, \"en\": 1, \"ef\": [{\"ty\": 10, \"nm\": \"Take Matte From Layer\", \"mn\": \"ADBE Set Matte3-0001\", \"ix\": 1, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 1}}, {\"ty\": 7, \"nm\": \"Use For Matte\", \"mn\": \"ADBE Set Matte3-0002\", \"ix\": 2, \"v\": {\"a\": 0, \"k\": 4, \"ix\": 2}}, {\"ty\": 7, \"nm\": \"Invert Matte\", \"mn\": \"ADBE Set Matte3-0003\", \"ix\": 3, \"v\": {\"a\": 0, \"k\": 0, \"ix\": 3}}, {\"ty\": 7, \"nm\": \"If Layer Sizes Differ\", \"mn\": \"ADBE Set Matte3-0004\", \"ix\": 4, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 4}}, {\"ty\": 7, \"nm\": \"Composite Matte with Original\", \"mn\": \"ADBE Set Matte3-0005\", \"ix\": 5, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 5}}, {\"ty\": 7, \"nm\": \"Premultiply Matte Layer\", \"mn\": \"ADBE Set Matte3-0006\", \"ix\": 6, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 6}}]}], \"refId\": \"blep\"}, {\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {}, \"ip\": 0, \"op\": 60, \"st\": 0, \"ind\": 1, \"refId\": \"thumbs-up\"}]}, function (lottie, data) { let shader = lottie_shader_47; lottie.layers[0].ef[0].ef[1].v.k = Number(data[\"Channel\"]); lottie.layers[0].ef[0].ef[2].v.k = Number(data[\"Invert\"]); lottie.layers[0].ef[0].ef[3].v.k = Number(data[\"Stretch To Fit\"]); lottie.layers[0].ef[0].ef[4].v.k = Number(data[\"Show Mask\"]); lottie.layers[0].ef[0].ef[5].v.k = Number(data[\"Premultiply Mask\"]); shader.set_uniform(\"channel\", \"1i\", Number(data[\"Channel\"])); shader.set_uniform(\"invert\", \"1i\", Number(data[\"Invert\"])); shader.set_uniform(\"show_mask\", \"1i\", Number(data[\"Show Mask\"])); shader.set_uniform(\"premultiply_mask\", \"1i\", Number(data[\"Premultiply Mask\"])); shader.texture(\"/lottie-docs/examples/thumbs-up.png\").set_uniform(shader.program, \"mask_layer\"); this.json_viewer_contents = lottie.layers[0].ef[0]; shader.render(); }, {} ); Bulge Center X 286 Center Y 277 Radius X 197 Radius Y 179 Height 1.9 Show JSON #version 100 precision highp float; uniform vec2 center; uniform vec2 radius; uniform float height; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; vec2 normalize_uv(vec2 coord) { return vec2(coord.x / canvas_size.x, coord.y / canvas_size.y); } vec2 exponential_displacement(vec2 uv, float magnitude) { return uv * pow(dot(uv, uv), magnitude) - uv; } vec2 spherical_displacement(vec2 uv, float magnitude) { float radius = (1.0 + magnitude) / (2.0 * sqrt(magnitude)); float arc_ratio = asin(length(uv) / radius) / asin(1.0 / radius); return normalize(uv) * arc_ratio - uv; } vec2 displace(vec2 owo) { float t = dot(owo, owo); if (t >= 1.0) return owo; float magnitude = abs(height); // We modify the magniture to more closely match AE magnitude = (2.0/(1.0+exp(-3.0*magnitude))-1.0) * (0.23 * magnitude + 0.14); // If the above is too expensive, you can use this instead: // magnitude = magnitude * 0.275; // Both of the above were derived by interpolating sample points float sign = height > 0.0 ? 1.0 : -1.0; vec2 displacement = exponential_displacement(owo, magnitude) + spherical_displacement(owo, magnitude) ; return owo + displacement * magnitude * sign; } void main() { highp vec2 uv = normalize_uv(gl_FragCoord.xy); vec2 norm_center = normalize_uv(center); vec2 norm_radius = normalize_uv(radius); // forward transform uv = (uv - norm_center) / norm_radius; //displace uv = displace(uv); // backward transform uv = uv * norm_radius + norm_center; gl_FragColor = texture2D(texture_sampler, uv); } var lottie_shader_48 = new SinglePassShader(document.getElementById('lottie_target_48_canvas')); lottie_shader_48.set_fragment('#version 100\\n\\nprecision highp float;\\n\\nuniform vec2 center;\\nuniform vec2 radius;\\nuniform float height;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\n\\nvec2 normalize_uv(vec2 coord)\\n{\\n return vec2(coord.x / canvas_size.x, coord.y / canvas_size.y);\\n}\\n\\nvec2 exponential_displacement(vec2 uv, float magnitude)\\n{\\n return uv * pow(dot(uv, uv), magnitude) - uv;\\n}\\n\\n\\nvec2 spherical_displacement(vec2 uv, float magnitude)\\n{\\n float radius = (1.0 + magnitude) / (2.0 * sqrt(magnitude));\\n\\n\\n float arc_ratio = asin(length(uv) / radius) / asin(1.0 / radius);\\n return normalize(uv) * arc_ratio - uv;\\n}\\n\\nvec2 displace(vec2 owo)\\n{\\n float t = dot(owo, owo);\\n if (t >= 1.0)\\n return owo;\\n\\n float magnitude = abs(height);\\n // We modify the magniture to more closely match AE\\n magnitude = (2.0/(1.0+exp(-3.0*magnitude))-1.0) * (0.23 * magnitude + 0.14);\\n // If the above is too expensive, you can use this instead:\\n // magnitude = magnitude * 0.275;\\n // Both of the above were derived by interpolating sample points\\n\\n float sign = height > 0.0 ? 1.0 : -1.0;\\n vec2 displacement =\\n exponential_displacement(owo, magnitude) +\\n spherical_displacement(owo, magnitude)\\n ;\\n return owo + displacement * magnitude * sign;\\n\\n}\\n\\nvoid main()\\n{\\n highp vec2 uv = normalize_uv(gl_FragCoord.xy);\\n vec2 norm_center = normalize_uv(center);\\n vec2 norm_radius = normalize_uv(radius);\\n\\n // forward transform\\n uv = (uv - norm_center) / norm_radius;\\n //displace\\n uv = displace(uv);\\n // backward transform\\n uv = uv * norm_radius + norm_center;\\n\\n gl_FragColor = texture2D(texture_sampler, uv);\\n}') var lottie_player_48 = new PlaygroundPlayer( 48, 'playground_48_6', 'lottie_target_48', {\"v\": \"5.9.0\", \"fr\": 60, \"ip\": 0, \"op\": 1800, \"w\": 512, \"h\": 512, \"nm\": \"Comp 1\", \"ddd\": 0, \"assets\": [{\"id\": \"image_0\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ind\": 1, \"ty\": 2, \"nm\": \"blep.png\", \"cl\": \"png\", \"refId\": \"image_0\", \"sr\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100, \"ix\": 11}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 10}, \"p\": {\"a\": 0, \"k\": [256, 256, 0], \"ix\": 2, \"l\": 2}, \"a\": {\"a\": 0, \"k\": [256, 256, 0], \"ix\": 1, \"l\": 2}, \"s\": {\"a\": 0, \"k\": [100, 100, 100], \"ix\": 6, \"l\": 2}}, \"ao\": 0, \"ef\": [{\"ty\": 5, \"nm\": \"Bulge\", \"np\": 9, \"mn\": \"ADBE Bulge\", \"ix\": 1, \"en\": 1, \"ef\": [{\"ty\": 0, \"nm\": \"Horizontal Radius\", \"mn\": \"ADBE Bulge-0001\", \"ix\": 1, \"v\": {\"a\": 0, \"k\": 197, \"ix\": 1}}, {\"ty\": 0, \"nm\": \"Vertical Radius\", \"mn\": \"ADBE Bulge-0002\", \"ix\": 2, \"v\": {\"a\": 0, \"k\": 179, \"ix\": 2}}, {\"ty\": 3, \"nm\": \"Bulge Center\", \"mn\": \"ADBE Bulge-0003\", \"ix\": 3, \"v\": {\"a\": 0, \"k\": [286, 277], \"ix\": 3}}, {\"ty\": 0, \"nm\": \"Bulge Height\", \"mn\": \"ADBE Bulge-0004\", \"ix\": 4, \"v\": {\"a\": 0, \"k\": 1.85, \"ix\": 4}}, {\"ty\": 0, \"nm\": \"Taper Radius\", \"mn\": \"ADBE Bulge-0005\", \"ix\": 5, \"v\": {\"a\": 0, \"k\": 0, \"ix\": 5}}, {\"ty\": 7, \"nm\": \"Antialiasing (Best Qual Only)\", \"mn\": \"ADBE Bulge-0006\", \"ix\": 6, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 6}}, {\"ty\": 7, \"nm\": \"Pinning\", \"mn\": \"ADBE Bulge-0007\", \"ix\": 7, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 7}}]}], \"ip\": 0, \"op\": 1800, \"st\": 0, \"bm\": 0}], \"markers\": []}, function (lottie, data) { let shader = lottie_shader_48; lottie.layers[0].ef[0].ef[0].v.k = data[\"Radius X\"]; lottie.layers[0].ef[0].ef[1].v.k = data[\"Radius Y\"]; lottie.layers[0].ef[0].ef[2].v.k = [data[\"Center X\"], data[\"Center Y\"]]; lottie.layers[0].ef[0].ef[3].v.k = data[\"Height\"]; shader.set_uniform(\"center\", \"2fv\", [data[\"Center X\"] * 0.77, data[\"Center Y\"] * 0.77]); shader.set_uniform(\"radius\", \"2fv\", [data[\"Radius X\"] * 0.77, data[\"Radius Y\"] * 0.77]); shader.set_uniform(\"height\", \"1f\", data[\"Height\"]); this.json_viewer_contents = lottie.layers[0].ef[0]; shader.render(); }, {} ); Wave Warp This effect is animated by default, so it has a \"time\" slider (in seconds). Shape Sine Square Triangle Sawtooth Circle Semicircle Uncircle Noise Smooth noise Amplitude 10 Wavelength 40 Direction 90 Phase 0 Speed 1 Time 0 Show JSON #version 100 #define PI 3.1415926538 #define TAU 6.283185307 precision highp float; uniform int shape; uniform float amplitude; uniform float wavelength; uniform float angle; uniform float speed; uniform float phase; uniform float time; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; vec2 normalize_uv(vec2 coord) { return vec2(coord.x / canvas_size.x, coord.y / canvas_size.y); } float clamp_angle(float angle) { return mod(angle, TAU); } vec2 project(vec2 a , vec2 b) { return dot(a, b) / dot(b, b) * b; } float semicircle(float x) { return sqrt(1.0 - pow(clamp_angle(x) / PI - 1.0, 2.0)); } // Adapted from http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/ highp float noise(float x) { highp float a = 12.9898; highp float b = 78.233; highp float c = 43758.5453; highp float dt = x * a; highp float sn = mod(dt, PI); return fract(sin(sn) * c) * 2.0 - 1.0; } // Interpolate between two random points float smooth_noise(float x) { float x_fract = fract(x); float x_int = x - x_fract; float n1 = noise(x_int); float n2 = noise(x_int + 1.0); return (n1 * (1.0 - x_fract) + n2 * x_fract); } vec2 displace(vec2 uv) { float rad = angle / 180.0 * PI; vec2 normal = vec2(cos(rad), sin(rad)); rad -= PI /2.0; vec2 direction = vec2(cos(rad), sin(rad)); float x = length(project(uv, direction)); x = x / wavelength * PI - time * speed * TAU + phase / 180.0 * PI; float y; if ( shape == 1 ) // sine y = sin(x); else if ( shape == 2 ) // square y = clamp_angle(x) < PI ? 1.0 : -1.0; else if ( shape == 3 ) // triangle y = 1.0 - abs(clamp_angle(x) - PI) / PI * 2.0; else if ( shape == 4 ) // sawtooth y = 1.0 - clamp_angle(x) / PI; else if ( shape == 5 ) // circle y = sign(clamp_angle(x) - PI) * semicircle(2.0 * x); else if ( shape == 6 ) // semi circle y = 2.0 * semicircle(x) - 1.0; else if ( shape == 7 ) // uncircle y = sign(clamp_angle(-x) - PI) * (semicircle(2.0 * x) - 1.0); else if ( shape == 8 ) // noise y = noise(x); else if ( shape == 9 ) // smooth noise y = smooth_noise(x * 4.0) ; return uv + y * normal * amplitude; } void main() { vec2 uv = displace(gl_FragCoord.xy); gl_FragColor = texture2D(texture_sampler, normalize_uv(uv)); } var lottie_shader_49 = new SinglePassShader(document.getElementById('lottie_target_49_canvas')); lottie_shader_49.set_fragment('#version 100\\n\\n#define PI 3.1415926538\\n#define TAU 6.283185307\\n\\nprecision highp float;\\n\\nuniform int shape;\\nuniform float amplitude;\\nuniform float wavelength;\\nuniform float angle;\\nuniform float speed;\\nuniform float phase;\\nuniform float time;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\n\\n\\nvec2 normalize_uv(vec2 coord)\\n{\\n return vec2(coord.x / canvas_size.x, coord.y / canvas_size.y);\\n}\\n\\nfloat clamp_angle(float angle)\\n{\\n return mod(angle, TAU);\\n}\\n\\nvec2 project(vec2 a , vec2 b)\\n{\\n return dot(a, b) / dot(b, b) * b;\\n}\\n\\nfloat semicircle(float x)\\n{\\n return sqrt(1.0 - pow(clamp_angle(x) / PI - 1.0, 2.0));\\n}\\n\\n// Adapted from http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\\nhighp float noise(float x)\\n{\\n highp float a = 12.9898;\\n highp float b = 78.233;\\n highp float c = 43758.5453;\\n highp float dt = x * a;\\n highp float sn = mod(dt, PI);\\n return fract(sin(sn) * c) * 2.0 - 1.0;\\n}\\n\\n// Interpolate between two random points\\nfloat smooth_noise(float x)\\n{\\n float x_fract = fract(x);\\n float x_int = x - x_fract;\\n float n1 = noise(x_int);\\n float n2 = noise(x_int + 1.0);\\n return (n1 * (1.0 - x_fract) + n2 * x_fract);\\n}\\n\\nvec2 displace(vec2 uv)\\n{\\n float rad = angle / 180.0 * PI;\\n vec2 normal = vec2(cos(rad), sin(rad));\\n rad -= PI /2.0;\\n vec2 direction = vec2(cos(rad), sin(rad));\\n float x = length(project(uv, direction));\\n\\n x = x / wavelength * PI - time * speed * TAU + phase / 180.0 * PI;\\n\\n\\n float y;\\n\\n if ( shape == 1 ) // sine\\n y = sin(x);\\n else if ( shape == 2 ) // square\\n y = clamp_angle(x) < PI ? 1.0 : -1.0;\\n else if ( shape == 3 ) // triangle\\n y = 1.0 - abs(clamp_angle(x) - PI) / PI * 2.0;\\n else if ( shape == 4 ) // sawtooth\\n y = 1.0 - clamp_angle(x) / PI;\\n else if ( shape == 5 ) // circle\\n y = sign(clamp_angle(x) - PI) * semicircle(2.0 * x);\\n else if ( shape == 6 ) // semi circle\\n y = 2.0 * semicircle(x) - 1.0;\\n else if ( shape == 7 ) // uncircle\\n y = sign(clamp_angle(-x) - PI) * (semicircle(2.0 * x) - 1.0);\\n else if ( shape == 8 ) // noise\\n y = noise(x);\\n else if ( shape == 9 ) // smooth noise\\n y = smooth_noise(x * 4.0) ;\\n\\n return uv + y * normal * amplitude;\\n\\n}\\n\\nvoid main()\\n{\\n vec2 uv = displace(gl_FragCoord.xy);\\n gl_FragColor = texture2D(texture_sampler, normalize_uv(uv));\\n}') var lottie_player_49 = new PlaygroundPlayer( 49, 'playground_49_8', 'lottie_target_49', {\"v\": \"5.9.0\", \"fr\": 60, \"ip\": 0, \"op\": 1800, \"w\": 512, \"h\": 512, \"nm\": \"Comp 1\", \"ddd\": 0, \"assets\": [{\"id\": \"image_0\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ind\": 1, \"ty\": 2, \"nm\": \"blep.png\", \"cl\": \"png\", \"refId\": \"image_0\", \"sr\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100, \"ix\": 11}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 10}, \"p\": {\"a\": 0, \"k\": [256, 256, 0], \"ix\": 2, \"l\": 2}, \"a\": {\"a\": 0, \"k\": [256, 256, 0], \"ix\": 1, \"l\": 2}, \"s\": {\"a\": 0, \"k\": [100, 100, 100], \"ix\": 6, \"l\": 2}}, \"ao\": 0, \"ef\": [{\"ty\": 5, \"nm\": \"Wave Warp\", \"np\": 10, \"mn\": \"ADBE Wave Warp\", \"ix\": 1, \"en\": 1, \"ef\": [{\"ty\": 7, \"nm\": \"Wave Type\", \"mn\": \"ADBE Wave Warp-0001\", \"ix\": 1, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 1}}, {\"ty\": 0, \"nm\": \"Wave Height\", \"mn\": \"ADBE Wave Warp-0002\", \"ix\": 2, \"v\": {\"a\": 0, \"k\": 10, \"ix\": 2}}, {\"ty\": 0, \"nm\": \"Wave Width\", \"mn\": \"ADBE Wave Warp-0003\", \"ix\": 3, \"v\": {\"a\": 0, \"k\": 64, \"ix\": 3}}, {\"ty\": 0, \"nm\": \"Direction\", \"mn\": \"ADBE Wave Warp-0004\", \"ix\": 4, \"v\": {\"a\": 0, \"k\": 90, \"ix\": 4}}, {\"ty\": 7, \"nm\": \"Wave Speed\", \"mn\": \"ADBE Wave Warp-0005\", \"ix\": 5, \"v\": {\"a\": 0, \"k\": 2, \"ix\": 5}}, {\"ty\": 7, \"nm\": \"Pinning\", \"mn\": \"ADBE Wave Warp-0006\", \"ix\": 6, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 6}}, {\"ty\": 0, \"nm\": \"Phase\", \"mn\": \"ADBE Wave Warp-0007\", \"ix\": 7, \"v\": {\"a\": 0, \"k\": 0, \"ix\": 7}}, {\"ty\": 7, \"nm\": \"Antialiasing (Best Quality)\", \"mn\": \"ADBE Wave Warp-0008\", \"ix\": 8, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 8}}]}], \"ip\": 0, \"op\": 1800, \"st\": 0, \"bm\": 0}], \"markers\": []}, function (lottie, data) { let shader = lottie_shader_49; lottie.layers[0].ef[0].ef[0].v.k = Number(data[\"Shape\"]); lottie.layers[0].ef[0].ef[1].v.k = data[\"Amplitude\"]; lottie.layers[0].ef[0].ef[2].v.k = data[\"Wavelength\"]; lottie.layers[0].ef[0].ef[3].v.k = data[\"Direction\"]; lottie.layers[0].ef[0].ef[5].v.k = data[\"Speed\"]; // 5 \"pinning\" not implemented lottie.layers[0].ef[0].ef[6].v.k = data[\"Phase\"]; // & \"antialiasing\" unused shader.set_uniform(\"shape\", \"1i\", Number(data[\"Shape\"])); shader.set_uniform(\"amplitude\", \"1f\", data[\"Amplitude\"]); shader.set_uniform(\"wavelength\", \"1f\", data[\"Wavelength\"]); shader.set_uniform(\"angle\", \"1f\", data[\"Direction\"]); shader.set_uniform(\"phase\", \"1f\", data[\"Phase\"]); shader.set_uniform(\"speed\", \"1f\", data[\"Speed\"]); shader.set_uniform(\"time\", \"1f\", data[\"Time\"]); this.json_viewer_contents = lottie.layers[0].ef[0]; shader.render(); }, {} );","title":"Tips for rendering"},{"location":"rendering/#tips-for-rendering","text":".json-parent:not([hidden]) { display: flex; } .json-parent > pre { width: 50%; } .json-parent > pre > code { height: 100%; } let converter_map = {}; function convert_shape(shape) { return converter_map[shape.ty](shape); }","title":"Tips for rendering"},{"location":"rendering/#introduction","text":"This page will give tips and example code on how to render certain objects within lottie. Lottie has several implementations and some things might vary from player to player, this guide tries to follow the behaviour of lottie web which is the reference implementation. For shapes, it ensures the stroke order is the same as in lottie web, which is crucial for Trim Path to work correctly. All shapes have the d attribute that if has the value 3 the path should be reversed.","title":"Introduction"},{"location":"rendering/#code","text":"The code examples take some shortcuts for readablility: all animated properties are shown as static, of course you'd need to get the correct values to render shapes at a given frame. When adding points to a bezier, there are calls to bezier.add_vertex() . Assume the in/out tangents are [0, 0] if not specified. When they are specified they show as set_out_tangent immediately following the corresponding add_vertex . Bezier tangents are assumed to be relative to their vertex since that's how lottie works but it might be useful to keep them as absolute points when rendering. All the examples show the original on the left and the bezier on the right. Explanation for bezier operations is outside the scope of this guide, the code below use a simple bezier library for some operations, you can check its sources for some context on what the various functions do.","title":"Code"},{"location":"rendering/#rectangle","text":"See Rectangle . Note that unlike other shapes, on lottie web when the d attribute is missing, the rectangle defaults as being reversed. Rectangle without rounded corners: Position x 256 Position y 256 Width 256 Height 256 Show JSON function rect(position, size) { let left = position[0] - size[0] / 2; let right = position[0] + size[0] / 2; let top = position[1] - size[1] / 2; let bottom = position[1] + size[1] / 2; let bezier = new Bezier(); bezier.add_vertex(right, top); bezier.add_vertex(right, bottom); bezier.add_vertex(left, bottom); bezier.add_vertex(left, top); return bezier; } // Example invocation rect(shape.p.k, shape.s.k); function rect(position, size) { let left = position[0] - size[0] / 2; let right = position[0] + size[0] / 2; let top = position[1] - size[1] / 2; let bottom = position[1] + size[1] / 2; let bezier = new Bezier(); bezier.add_vertex(right, top); bezier.add_vertex(right, bottom); bezier.add_vertex(left, bottom); bezier.add_vertex(left, top); return bezier; } var lottie_player_31_bezier = new LottiePlayer('lottie_target_31_bezier', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"sh\", \"nm\": \"Shape\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [], \"i\": [], \"o\": []}}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}); var lottie_player_31 = new PlaygroundPlayer( 31, 'playground_31_5', 'lottie_target_31', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { let bezier_lottie = lottie_player_31_bezier.lottie; lottie.layers[0].shapes[0].it[0].p.k = [ data[\"Position x\"], data[\"Position y\"] ]; lottie.layers[0].shapes[0].it[0].s.k = [ data[\"Width\"], data[\"Height\"] ]; this.json_viewer_contents = lottie.layers[0].shapes[0].it[0]; let shape = lottie.layers[0].shapes[0].it[0]; let bez_result = rect(shape.p.k, shape.s.k); if ( !Array.isArray(bez_result) ) bez_result = [bez_result]; let out_shapes = bez_result.map(b => ({ ty: \"sh\", \"ks\": {a: 0, k: b.to_lottie()} })); let bez_target = bezier_lottie.layers[0].shapes[0].it; bez_target.splice(0, bez_target.length - 2, ...out_shapes); lottie_player_31_bezier.reload(); this.set_json('playground_31_5_bezier', out_shapes[0].ks.k); }, {} ); With rounded corners: Position x 256 Position y 256 Width 256 Height 256 Roundness 50 Show JSON function rounded_rect(position, size, roundness) { let left = position[0] - size[0] / 2; let right = position[0] + size[0] / 2; let top = position[1] - size[1] / 2; let bottom = position[1] + size[1] / 2; let rounded = Math.min(size[0] / 2, size[1] / 2, roundness); let bezier = new Bezier(); // top right, going down bezier.add_vertex(right, top + rounded) .set_in_tangent(0, -rounded/2); // bottom right bezier.add_vertex(right, bottom - rounded) .set_out_tangent(0, rounded/2); bezier.add_vertex(right - rounded, bottom) .set_in_tangent(rounded/2, 0); // bottom left bezier.add_vertex(left + rounded, bottom) .set_out_tangent(-rounded/2, 0); bezier.add_vertex(left, bottom - rounded) .set_in_tangent(0, rounded/2); // top left bezier.add_vertex(left, top + rounded) .set_out_tangent(0, -rounded/2); bezier.add_vertex(left + rounded, top) .set_in_tangent(-rounded/2, 0); // back to top right bezier.add_vertex(right - rounded, top) .set_out_tangent(rounded/2, 0); return bezier; } // Example invocation rounded_rect(shape.p.k, shape.s.k, shape.r.k); function rounded_rect(position, size, roundness) { let left = position[0] - size[0] / 2; let right = position[0] + size[0] / 2; let top = position[1] - size[1] / 2; let bottom = position[1] + size[1] / 2; let rounded = Math.min(size[0] / 2, size[1] / 2, roundness); let bezier = new Bezier(); // top right, going down bezier.add_vertex(right, top + rounded) .set_in_tangent(0, -rounded/2); // bottom right bezier.add_vertex(right, bottom - rounded) .set_out_tangent(0, rounded/2); bezier.add_vertex(right - rounded, bottom) .set_in_tangent(rounded/2, 0); // bottom left bezier.add_vertex(left + rounded, bottom) .set_out_tangent(-rounded/2, 0); bezier.add_vertex(left, bottom - rounded) .set_in_tangent(0, rounded/2); // top left bezier.add_vertex(left, top + rounded) .set_out_tangent(0, -rounded/2); bezier.add_vertex(left + rounded, top) .set_in_tangent(-rounded/2, 0); // back to top right bezier.add_vertex(right - rounded, top) .set_out_tangent(rounded/2, 0); return bezier; } converter_map['rc'] = shape => rounded_rect(shape.p.k, shape.s.k, shape.r.k); var lottie_player_32_bezier = new LottiePlayer('lottie_target_32_bezier', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"sh\", \"nm\": \"Shape\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [], \"i\": [], \"o\": []}}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}); var lottie_player_32 = new PlaygroundPlayer( 32, 'playground_32_6', 'lottie_target_32', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { let bezier_lottie = lottie_player_32_bezier.lottie; lottie.layers[0].shapes[0].it[0].p.k = [ data[\"Position x\"], data[\"Position y\"] ]; lottie.layers[0].shapes[0].it[0].s.k = [ data[\"Width\"], data[\"Height\"] ]; lottie.layers[0].shapes[0].it[0].r.k = data[\"Roundness\"]; this.json_viewer_contents = lottie.layers[0].shapes[0].it[0]; let shape = lottie.layers[0].shapes[0].it[0]; let bez_result = rounded_rect(shape.p.k, shape.s.k, shape.r.k); if ( !Array.isArray(bez_result) ) bez_result = [bez_result]; let out_shapes = bez_result.map(b => ({ ty: \"sh\", \"ks\": {a: 0, k: b.to_lottie()} })); let bez_target = bezier_lottie.layers[0].shapes[0].it; bez_target.splice(0, bez_target.length - 2, ...out_shapes); lottie_player_32_bezier.reload(); this.set_json('playground_32_6_bezier', out_shapes[0].ks.k); }, {} );","title":"Rectangle"},{"location":"rendering/#ellipse","text":"See Ellipse . The stroke direction should start at the top. If you think of the ellipse as a clock, start at 12 go clockwise. The magic number 0.5519 is what lottie uses for this, based on this article . Position x 256 Position y 256 Width 256 Height 256 Show JSON function ellipse(position, size) { const ellipse_constant = 0.5519; let x = position[0]; let y = position[1]; let radius_x = size[0] / 2; let radius_y = size[1] / 2; let tangent_x = radius_x * ellipse_constant; let tangent_y = radius_y * ellipse_constant; let bezier = new Bezier(); bezier.add_vertex(x, y - radius_y) .set_in_tangent(-tangent_x, 0) .set_out_tangent(tangent_x, 0); bezier.add_vertex(x + radius_x, y) .set_in_tangent(0, -tangent_y) .set_out_tangent(0, tangent_y); bezier.add_vertex(x, y + radius_y) .set_in_tangent(tangent_x, 0) .set_out_tangent(-tangent_x, 0); bezier.add_vertex(x - radius_x, y) .set_in_tangent(0, tangent_y) .set_out_tangent(0, -tangent_y); return bezier; } // Example invocation ellipse(shape.p.k, shape.s.k); function ellipse(position, size) { const ellipse_constant = 0.5519; let x = position[0]; let y = position[1]; let radius_x = size[0] / 2; let radius_y = size[1] / 2; let tangent_x = radius_x * ellipse_constant; let tangent_y = radius_y * ellipse_constant; let bezier = new Bezier(); bezier.add_vertex(x, y - radius_y) .set_in_tangent(-tangent_x, 0) .set_out_tangent(tangent_x, 0); bezier.add_vertex(x + radius_x, y) .set_in_tangent(0, -tangent_y) .set_out_tangent(0, tangent_y); bezier.add_vertex(x, y + radius_y) .set_in_tangent(tangent_x, 0) .set_out_tangent(-tangent_x, 0); bezier.add_vertex(x - radius_x, y) .set_in_tangent(0, tangent_y) .set_out_tangent(0, -tangent_y); return bezier; } converter_map['el'] = shape => ellipse(shape.p.k, shape.s.k); var lottie_player_33_bezier = new LottiePlayer('lottie_target_33_bezier', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"sh\", \"nm\": \"Shape\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [], \"i\": [], \"o\": []}}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}); var lottie_player_33 = new PlaygroundPlayer( 33, 'playground_33_5', 'lottie_target_33', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"el\", \"nm\": \"Ellipse\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [256, 256]}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { let bezier_lottie = lottie_player_33_bezier.lottie; lottie.layers[0].shapes[0].it[0].p.k = [ data[\"Position x\"], data[\"Position y\"] ]; lottie.layers[0].shapes[0].it[0].s.k = [ data[\"Width\"], data[\"Height\"] ]; this.json_viewer_contents = lottie.layers[0].shapes[0].it[0]; let shape = lottie.layers[0].shapes[0].it[0]; let bez_result = ellipse(shape.p.k, shape.s.k); if ( !Array.isArray(bez_result) ) bez_result = [bez_result]; let out_shapes = bez_result.map(b => ({ ty: \"sh\", \"ks\": {a: 0, k: b.to_lottie()} })); let bez_target = bezier_lottie.layers[0].shapes[0].it; bez_target.splice(0, bez_target.length - 2, ...out_shapes); lottie_player_33_bezier.reload(); this.set_json('playground_33_5_bezier', out_shapes[0].ks.k); }, {} );","title":"Ellipse"},{"location":"rendering/#polystar","text":"Pseudocode for rendering a PolyStar . Points 5 Rotation 0 Outer Radius 200 Inner Radius 100 Outer Roundness 0 Inner Roundness 0 Type Star Polygon Show JSON function polystar( position, type, points, rotation, outer_radius, outer_roundness, inner_radius, inner_roundness ) { let result = new Bezier(); let half_angle = Math.PI / points; let angle_radians = rotation / 180 * Math.PI // Tangents for rounded courners let tangent_len_outer = outer_roundness * outer_radius * 2 * Math.PI / (points * 4 * 100); let tangent_len_inner = inner_roundness * inner_radius * 2 * Math.PI / (points * 4 * 100); for ( let i = 0; i < points; i++ ) { let main_angle = -Math.PI / 2 + angle_radians + i * half_angle * 2; let outer_vertex = new Point( outer_radius * Math.cos(main_angle), outer_radius * Math.sin(main_angle) ); let outer_tangent = new Point(0, 0); if ( outer_radius != 0 ) outer_tangent = new Point( outer_vertex.y / outer_radius * tangent_len_outer, -outer_vertex.x / outer_radius * tangent_len_outer ); result.add_vertex(position.add(outer_vertex)) .set_in_tangent(outer_tangent) .set_out_tangent(outer_tangent.neg()); // Star inner radius if ( type == 1 ) { let inner_vertex = new Point( inner_radius * Math.cos(main_angle + half_angle), inner_radius * Math.sin(main_angle + half_angle) ); let inner_tangent = new Point(0, 0); if ( inner_radius != 0 ) inner_tangent = new Point( inner_vertex.y / inner_radius * tangent_len_inner, -inner_vertex.x / inner_radius * tangent_len_inner ); result.add_vertex(position.add(inner_vertex)) .set_in_tangent(inner_tangent) .set_out_tangent(inner_tangent.neg()); } } return result; } // Example invocation polystar(new Point(shape.p.k), shape.sy, shape.pt.k, shape.r.k, shape.or.k, shape.os.k, shape.ir?.k, shape.is?.k); function polystar( position, type, points, rotation, outer_radius, outer_roundness, inner_radius, inner_roundness ) { let result = new Bezier(); let half_angle = Math.PI / points; let angle_radians = rotation / 180 * Math.PI // Tangents for rounded courners let tangent_len_outer = outer_roundness * outer_radius * 2 * Math.PI / (points * 4 * 100); let tangent_len_inner = inner_roundness * inner_radius * 2 * Math.PI / (points * 4 * 100); for ( let i = 0; i < points; i++ ) { let main_angle = -Math.PI / 2 + angle_radians + i * half_angle * 2; let outer_vertex = new Point( outer_radius * Math.cos(main_angle), outer_radius * Math.sin(main_angle) ); let outer_tangent = new Point(0, 0); if ( outer_radius != 0 ) outer_tangent = new Point( outer_vertex.y / outer_radius * tangent_len_outer, -outer_vertex.x / outer_radius * tangent_len_outer ); result.add_vertex(position.add(outer_vertex)) .set_in_tangent(outer_tangent) .set_out_tangent(outer_tangent.neg()); // Star inner radius if ( type == 1 ) { let inner_vertex = new Point( inner_radius * Math.cos(main_angle + half_angle), inner_radius * Math.sin(main_angle + half_angle) ); let inner_tangent = new Point(0, 0); if ( inner_radius != 0 ) inner_tangent = new Point( inner_vertex.y / inner_radius * tangent_len_inner, -inner_vertex.x / inner_radius * tangent_len_inner ); result.add_vertex(position.add(inner_vertex)) .set_in_tangent(inner_tangent) .set_out_tangent(inner_tangent.neg()); } } return result; } converter_map['sr'] = shape => polystar(new Point(shape.p.k), shape.sy, shape.pt.k, shape.r.k, shape.or.k, shape.os.k, shape.ir?.k, shape.is?.k); var lottie_player_34_bezier = new LottiePlayer('lottie_target_34_bezier', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"sh\", \"nm\": \"Shape\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [], \"i\": [], \"o\": []}}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}); var lottie_player_34 = new PlaygroundPlayer( 34, 'playground_34_8', 'lottie_target_34', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [{\"ty\": 4, \"ddd\": 0, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ip\": 0, \"op\": 180, \"ind\": 0, \"st\": 0, \"sr\": 1, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{9199543e-3552-4e51-a802-623f2a4a2ca1}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.979995422293431, 0.28000305180437934]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { let bezier_lottie = lottie_player_34_bezier.lottie; var star = { \"ty\": \"sr\", \"nm\": \"PolyStar\", \"sy\": Number(data[\"Type\"]), \"p\": { \"a\": 0, \"k\": [ 256, 256 ] }, \"r\": { \"a\": 0, \"k\": data[\"Rotation\"] }, \"pt\": { \"a\": 0, \"k\": data[\"Points\"] }, \"or\": { \"a\": 0, \"k\": data[\"Outer Radius\"] }, \"os\": { \"a\": 0, \"k\": data[\"Outer Roundness\"] }, }; if ( data[\"Type\"] == \"1\" ) { star.ir = { \"a\": 0, \"k\": data[\"Inner Radius\"] }; star.is = { \"a\": 0, \"k\": data[\"Inner Roundness\"] }; } lottie.layers[0].shapes[0].it[0] = star; this.json_viewer_contents = lottie.layers[0].shapes[0].it[0]; let shape = lottie.layers[0].shapes[0].it[0]; let bez_result = polystar(new Point(shape.p.k), shape.sy, shape.pt.k, shape.r.k, shape.or.k, shape.os.k, shape.ir?.k, shape.is?.k); if ( !Array.isArray(bez_result) ) bez_result = [bez_result]; let out_shapes = bez_result.map(b => ({ ty: \"sh\", \"ks\": {a: 0, k: b.to_lottie()} })); let bez_target = bezier_lottie.layers[0].shapes[0].it; bez_target.splice(0, bez_target.length - 2, ...out_shapes); lottie_player_34_bezier.reload(); this.set_json('playground_34_8_bezier', out_shapes[0].ks.k); }, {} );","title":"PolyStar"},{"location":"rendering/#pucker-bloat","text":"See Pucker / Bloat . Amount 50 Show JSON function pucker_bloat( // Beziers as collected from the other shapes collected_shapes, // \"a\" property from the Pucker/Bloat modifier amount ) { // Normalize to [0, 1] amount /= 100; // Find the mean of the bezier vertices let center = new Point(0, 0); let number_of_vertices = 0; for ( let input_bezier of collected_shapes ) { for ( let point of input_bezier.points ) { center.x += point.pos.x; center.y += point.pos.y; number_of_vertices += 1; } } center.x /= number_of_vertices; center.y /= number_of_vertices; let result = []; for ( let input_bezier of collected_shapes ) { let output_bezier = new Bezier(); for ( let point of input_bezier.points ) { // Here we convert tangents to global coordinates let vertex = lerp(point.pos, center, amount); let in_tangent = lerp(point.in_tangent.add(point.pos), center, -amount).sub(vertex); let out_tangent = lerp(point.out_tangent.add(point.pos), center, -amount).sub(vertex); output_bezier.add_vertex(vertex) .set_in_tangent(in_tangent) .set_out_tangent(out_tangent); } output_bezier.closed = input_bezier.closed; result.push(output_bezier); } return result; } // Example invocation pucker_bloat([convert_shape(star)], modifier.a.k); function pucker_bloat( // Beziers as collected from the other shapes collected_shapes, // \"a\" property from the Pucker/Bloat modifier amount ) { // Normalize to [0, 1] amount /= 100; // Find the mean of the bezier vertices let center = new Point(0, 0); let number_of_vertices = 0; for ( let input_bezier of collected_shapes ) { for ( let point of input_bezier.points ) { center.x += point.pos.x; center.y += point.pos.y; number_of_vertices += 1; } } center.x /= number_of_vertices; center.y /= number_of_vertices; let result = []; for ( let input_bezier of collected_shapes ) { let output_bezier = new Bezier(); for ( let point of input_bezier.points ) { // Here we convert tangents to global coordinates let vertex = lerp(point.pos, center, amount); let in_tangent = lerp(point.in_tangent.add(point.pos), center, -amount).sub(vertex); let out_tangent = lerp(point.out_tangent.add(point.pos), center, -amount).sub(vertex); output_bezier.add_vertex(vertex) .set_in_tangent(in_tangent) .set_out_tangent(out_tangent); } output_bezier.closed = input_bezier.closed; result.push(output_bezier); } return result; } var lottie_player_35_bezier = new LottiePlayer('lottie_target_35_bezier', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"sh\", \"nm\": \"Shape\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [], \"i\": [], \"o\": []}}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}); var lottie_player_35 = new PlaygroundPlayer( 35, 'playground_35_2', 'lottie_target_35', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{9199543e-3552-4e51-a802-623f2a4a2ca1}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 160}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 2, \"os\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"pb\", \"nm\": \"Inflate and Deflate\", \"mn\": \"{b4af429a-546e-4728-a869-711a404c55ae}\", \"a\": {\"a\": 0, \"k\": 50}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"fl\", \"hd\": true, \"nm\": \"Fill\", \"mn\": \"{a1bcc159-6916-4718-841d-a99140c0e74b}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { let bezier_lottie = lottie_player_35_bezier.lottie; lottie.layers[0].shapes[0].it[1].a.k = data[\"Amount\"]; let star = lottie.layers[0].shapes[0].it[0]; this.json_viewer_contents = lottie.layers[0].shapes[0].it[1]; let modifier = lottie.layers[0].shapes[0].it[1]; let bez_result = pucker_bloat([convert_shape(star)], modifier.a.k); if ( !Array.isArray(bez_result) ) bez_result = [bez_result]; let out_shapes = bez_result.map(b => ({ ty: \"sh\", \"ks\": {a: 0, k: b.to_lottie()} })); let bez_target = bezier_lottie.layers[0].shapes[0].it; bez_target.splice(0, bez_target.length - 2, ...out_shapes); lottie_player_35_bezier.reload(); this.set_json('playground_35_2_bezier', out_shapes[0].ks.k); }, {} );","title":"Pucker Bloat"},{"location":"rendering/#rounded-corners","text":"See Rounded Corners . It approximates rounding using circular arcs. The magic number 0.5519 is what lottie uses for this, based on this article . Radius 50 Show JSON // Helper function to perform rounding on a single vertex function get_vertex_tangent( // Bezier to round bezier, // Vertex in the bezier we are rounding current_vertex, // Index of the next point along the curve closest_index, // Rounding radius round_distance ) { const tangent_length = 0.5519; // closest_index module bezier.length closest_index = closest_index % bezier.points.length; if ( closest_index < 0 ) closest_index += bezier.points.length; let closest_vertex = bezier.points[closest_index].pos; let distance = current_vertex.distance(closest_vertex); let new_pos_perc = distance != 0 ? Math.min(distance/2, round_distance) / distance : 0; let vertex = closest_vertex.sub(current_vertex).mul(new_pos_perc).add(current_vertex); let tangent = vertex.sub(current_vertex).neg().mul(tangent_length); return [vertex, tangent]; } // Rounding for a single continuos curve function round_bezier_corners( // Bezier to round original, // Rounding radius round_distance ) { let result = new Bezier() result.closed = original.closed; for ( let i = 0; i < original.points.length; i++ ) { let point = original.points[i]; // Start and end of a non-closed path don't get rounded if ( !original.closed && (i == 0 || i == original.points.length - 1) ) { result.add_vertex(point.pos) .set_in_tangent(point.in_tangent) .set_out_tangent(point.out_tangent); } else { let [vert1, out_t] = get_vertex_tangent(original, point.pos, i - 1, round_distance); result.add_vertex(vert1) .set_out_tangent(out_t); let [vert2, in_t] = get_vertex_tangent(original, point.pos, i + 1, round_distance); result.add_vertex(vert2) .set_in_tangent(in_t); } } return result; } // Rounding on multiple bezier function round_corners( // Beziers as collected from the other shapes collected_shapes, // \"r\" property from lottie r ) { let result = [] for ( let input_bezier of collected_shapes ) result.push(round_bezier_corners(input_bezier, r)); return result; } // Example invocation round_corners([convert_shape(star)], modifier.r.k); // Helper function to perform rounding on a single vertex function get_vertex_tangent( // Bezier to round bezier, // Vertex in the bezier we are rounding current_vertex, // Index of the next point along the curve closest_index, // Rounding radius round_distance ) { const tangent_length = 0.5519; // closest_index module bezier.length closest_index = closest_index % bezier.points.length; if ( closest_index < 0 ) closest_index += bezier.points.length; let closest_vertex = bezier.points[closest_index].pos; let distance = current_vertex.distance(closest_vertex); let new_pos_perc = distance != 0 ? Math.min(distance/2, round_distance) / distance : 0; let vertex = closest_vertex.sub(current_vertex).mul(new_pos_perc).add(current_vertex); let tangent = vertex.sub(current_vertex).neg().mul(tangent_length); return [vertex, tangent]; } // Rounding for a single continuos curve function round_bezier_corners( // Bezier to round original, // Rounding radius round_distance ) { let result = new Bezier() result.closed = original.closed; for ( let i = 0; i < original.points.length; i++ ) { let point = original.points[i]; // Start and end of a non-closed path don't get rounded if ( !original.closed && (i == 0 || i == original.points.length - 1) ) { result.add_vertex(point.pos) .set_in_tangent(point.in_tangent) .set_out_tangent(point.out_tangent); } else { let [vert1, out_t] = get_vertex_tangent(original, point.pos, i - 1, round_distance); result.add_vertex(vert1) .set_out_tangent(out_t); let [vert2, in_t] = get_vertex_tangent(original, point.pos, i + 1, round_distance); result.add_vertex(vert2) .set_in_tangent(in_t); } } return result; } // Rounding on multiple bezier function round_corners( // Beziers as collected from the other shapes collected_shapes, // \"r\" property from lottie r ) { let result = [] for ( let input_bezier of collected_shapes ) result.push(round_bezier_corners(input_bezier, r)); return result; } var lottie_player_36_bezier = new LottiePlayer('lottie_target_36_bezier', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"sh\", \"nm\": \"Shape\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [], \"i\": [], \"o\": []}}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}); var lottie_player_36 = new PlaygroundPlayer( 36, 'playground_36_2', 'lottie_target_36', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{9199543e-3552-4e51-a802-623f2a4a2ca1}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 222.72242736816406}, \"ir\": {\"a\": 0, \"k\": 111.36121368408203}, \"r\": {\"a\": 0, \"k\": 358.67291259765625}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"rd\", \"nm\": \"Rounded Corners\", \"mn\": \"{dcd7570f-5105-485b-bd43-42ad990b01e8}\", \"r\": {\"a\": 0, \"k\": 50}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"fl\", \"hd\": true, \"nm\": \"Fill\", \"mn\": \"{a1bcc159-6916-4718-841d-a99140c0e74b}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { let bezier_lottie = lottie_player_36_bezier.lottie; lottie.layers[0].shapes[0].it[1].r.k = data[\"Radius\"]; let star = lottie.layers[0].shapes[0].it[0]; this.json_viewer_contents = lottie.layers[0].shapes[0].it[1]; let modifier = lottie.layers[0].shapes[0].it[1]; let bez_result = round_corners([convert_shape(star)], modifier.r.k); if ( !Array.isArray(bez_result) ) bez_result = [bez_result]; let out_shapes = bez_result.map(b => ({ ty: \"sh\", \"ks\": {a: 0, k: b.to_lottie()} })); let bez_target = bezier_lottie.layers[0].shapes[0].it; bez_target.splice(0, bez_target.length - 2, ...out_shapes); lottie_player_36_bezier.reload(); this.set_json('playground_36_2_bezier', out_shapes[0].ks.k); }, {} );","title":"Rounded Corners"},{"location":"rendering/#zig-zag","text":"See Zig Zag . Zig Zag Amplitude 10 Frequency 10 Point Type Point Smooth Star Roundness 0 Rotation 0 Points 5 Stroke Width 3 Show JSON function angle_mean(a, b) { if ( Math.abs(a-b) > Math.PI ) return (a + b) / 2 + Math.PI; return (a + b) / 2; } function zig_zag_corner(output_bezier, segment_before, segment_after, amplitude, direction, tangent_length) { let point; let angle; let tan_angle; // We use 0.01 and 0.99 instead of 0 and 1 because they yield better results if ( !segment_before ) { point = segment_after.points[0]; angle = segment_after.normal_angle(0.01); tan_angle = segment_after.tangent_angle(0.01); } else if ( !segment_after ) { point = segment_before.points[3]; angle = segment_before.normal_angle(0.99); tan_angle = segment_before.tangent_angle(0.99); } else { point = segment_after.points[0]; angle = angle_mean(segment_after.normal_angle(0.01), segment_before.normal_angle(0.99)); tan_angle = angle_mean(segment_after.tangent_angle(0.01), segment_before.tangent_angle(0.99)); } let vertex = output_bezier.add_vertex(point.add_polar(angle, direction * amplitude)); if ( tangent_length !== 0 ) { vertex.set_in_tangent(Point.polar(tan_angle, -tangent_length)); vertex.set_out_tangent(Point.polar(tan_angle, tangent_length)); } } function zig_zag_segment(output_bezier, segment, amplitude, frequency, direction, tangent_length) { for ( let i = 0; i < frequency; i++ ) { let f = (i + 1) / (frequency + 1); let t = segment.t_at_length_percent(f); let angle = segment.normal_angle(t); let point = segment.point(t); let vertex = output_bezier.add_vertex(point.add_polar(angle, direction * amplitude)); if ( tangent_length !== 0 ) { let tan_angle = segment.tangent_angle(t); vertex.set_in_tangent(Point.polar(tan_angle, -tangent_length)); vertex.set_out_tangent(Point.polar(tan_angle, tangent_length)); } direction = -direction; } return direction; } function zig_zag_bezier(input_bezier, amplitude, frequency, smooth) { let output_bezier = new Bezier(); output_bezier.closed = input_bezier.closed; let count = input_bezier.segment_count(); if ( count == 0 ) return output_bezier; let direction = -1; let segment = input_bezier.closed ? input_bezier.segment(count - 1) : null; let next_segment = input_bezier.segment(0); next_segment.calculate_length_data(); let tangent_length = smooth ? next_segment.length / (frequency + 1) / 2 : 0; zig_zag_corner(output_bezier, segment, next_segment, amplitude, -1, tangent_length); for ( let i = 0; i < count; i++ ) { segment = next_segment; direction = zig_zag_segment(output_bezier, segment, amplitude, frequency, -direction, tangent_length); if ( i == count - 1 && !input_bezier.closed ) next_segment = null; else next_segment = input_bezier.segment((i + 1) % count); zig_zag_corner(output_bezier, segment, next_segment, amplitude, direction, tangent_length); } return output_bezier; } function zig_zag( // Beziers as collected from the other shapes collected_shapes, amplitude, frequency, point_type ) { // Ensure we have an integer number of segments frequency = Math.max(0, Math.round(frequency)); let result = []; for ( let input_bezier of collected_shapes ) result.push(zig_zag_bezier(input_bezier, amplitude, frequency, point_type === 2)); return result; } // Example invocation zig_zag([convert_shape(star)], modifier.s.k, modifier.r.k, modifier.pt.k); function angle_mean(a, b) { if ( Math.abs(a-b) > Math.PI ) return (a + b) / 2 + Math.PI; return (a + b) / 2; } function zig_zag_corner(output_bezier, segment_before, segment_after, amplitude, direction, tangent_length) { let point; let angle; let tan_angle; // We use 0.01 and 0.99 instead of 0 and 1 because they yield better results if ( !segment_before ) { point = segment_after.points[0]; angle = segment_after.normal_angle(0.01); tan_angle = segment_after.tangent_angle(0.01); } else if ( !segment_after ) { point = segment_before.points[3]; angle = segment_before.normal_angle(0.99); tan_angle = segment_before.tangent_angle(0.99); } else { point = segment_after.points[0]; angle = angle_mean(segment_after.normal_angle(0.01), segment_before.normal_angle(0.99)); tan_angle = angle_mean(segment_after.tangent_angle(0.01), segment_before.tangent_angle(0.99)); } let vertex = output_bezier.add_vertex(point.add_polar(angle, direction * amplitude)); if ( tangent_length !== 0 ) { vertex.set_in_tangent(Point.polar(tan_angle, -tangent_length)); vertex.set_out_tangent(Point.polar(tan_angle, tangent_length)); } } function zig_zag_segment(output_bezier, segment, amplitude, frequency, direction, tangent_length) { for ( let i = 0; i < frequency; i++ ) { let f = (i + 1) / (frequency + 1); let t = segment.t_at_length_percent(f); let angle = segment.normal_angle(t); let point = segment.point(t); let vertex = output_bezier.add_vertex(point.add_polar(angle, direction * amplitude)); if ( tangent_length !== 0 ) { let tan_angle = segment.tangent_angle(t); vertex.set_in_tangent(Point.polar(tan_angle, -tangent_length)); vertex.set_out_tangent(Point.polar(tan_angle, tangent_length)); } direction = -direction; } return direction; } function zig_zag_bezier(input_bezier, amplitude, frequency, smooth) { let output_bezier = new Bezier(); output_bezier.closed = input_bezier.closed; let count = input_bezier.segment_count(); if ( count == 0 ) return output_bezier; let direction = -1; let segment = input_bezier.closed ? input_bezier.segment(count - 1) : null; let next_segment = input_bezier.segment(0); next_segment.calculate_length_data(); let tangent_length = smooth ? next_segment.length / (frequency + 1) / 2 : 0; zig_zag_corner(output_bezier, segment, next_segment, amplitude, -1, tangent_length); for ( let i = 0; i < count; i++ ) { segment = next_segment; direction = zig_zag_segment(output_bezier, segment, amplitude, frequency, -direction, tangent_length); if ( i == count - 1 && !input_bezier.closed ) next_segment = null; else next_segment = input_bezier.segment((i + 1) % count); zig_zag_corner(output_bezier, segment, next_segment, amplitude, direction, tangent_length); } return output_bezier; } function zig_zag( // Beziers as collected from the other shapes collected_shapes, amplitude, frequency, point_type ) { // Ensure we have an integer number of segments frequency = Math.max(0, Math.round(frequency)); let result = []; for ( let input_bezier of collected_shapes ) result.push(zig_zag_bezier(input_bezier, amplitude, frequency, point_type === 2)); return result; } var lottie_player_37_bezier = new LottiePlayer('lottie_target_37_bezier', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"sh\", \"nm\": \"Shape\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [], \"i\": [], \"o\": []}}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}); var lottie_player_37 = new PlaygroundPlayer( 37, 'playground_37_8', 'lottie_target_37', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{9199543e-3552-4e51-a802-623f2a4a2ca1}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 222.72242736816406}, \"ir\": {\"a\": 0, \"k\": 111.36121368408203}, \"r\": {\"a\": 0, \"k\": 358.67291259765625}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"zz\", \"nm\": \"Zig Zag\", \"mn\": \"{b4af429a-546e-4728-a869-711a404c55ae}\", \"r\": {\"a\": 0, \"k\": 0}, \"s\": {\"a\": 0, \"k\": 10}, \"pt\": {\"a\": 0, \"k\": 2}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 3}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { let bezier_lottie = lottie_player_37_bezier.lottie; lottie.layers[0].shapes[0].it[1].s.k = data[\"Amplitude\"]; lottie.layers[0].shapes[0].it[1].r.k = data[\"Frequency\"]; lottie.layers[0].shapes[0].it[1].pt.k = Number(data[\"Point Type\"]); lottie.layers[0].shapes[0].it[0].pt.k = data[\"Points\"]; lottie.layers[0].shapes[0].it[0].r.k = data[\"Rotation\"]; lottie.layers[0].shapes[0].it[0].is.k = data[\"Roundness\"]; lottie.layers[0].shapes[0].it[0].os.k = data[\"Roundness\"]; lottie.layers[0].shapes[0].it[2].w.k = data[\"Stroke Width\"]; let star = lottie.layers[0].shapes[0].it[0]; bezier_lottie.layers[0].shapes[0].it[1].w.k = data[\"Stroke Width\"]; this.json_viewer_contents = lottie.layers[0].shapes[0].it[1]; let modifier = lottie.layers[0].shapes[0].it[1]; let bez_result = zig_zag([convert_shape(star)], modifier.s.k, modifier.r.k, modifier.pt.k); if ( !Array.isArray(bez_result) ) bez_result = [bez_result]; let out_shapes = bez_result.map(b => ({ ty: \"sh\", \"ks\": {a: 0, k: b.to_lottie()} })); let bez_target = bezier_lottie.layers[0].shapes[0].it; bez_target.splice(0, bez_target.length - 2, ...out_shapes); lottie_player_37_bezier.reload(); this.set_json('playground_37_8_bezier', out_shapes[0].ks.k); }, {} );","title":"Zig Zag"},{"location":"rendering/#offset-path","text":"See Offset Path . Offset Path Amount 10 Miter Limit 100 Line Join Miter Round Bevel Star Star Roundness 0 Show JSON /* Simple offset of a linear segment */ function linear_offset(p1, p2, amount) { let angle = Math.atan2(p2.x - p1.x, p2.y - p1.y); return [ p1.add_polar(angle, amount), p2.add_polar(angle, amount) ]; } /* Offset a bezier segment only works well if the segment is flat enough */ function offset_segment(segment, amount) { let [p0, p1a] = linear_offset(segment.points[0], segment.points[1], amount); let [p1b, p2b] = linear_offset(segment.points[1], segment.points[2], amount); let [p2a, p3] = linear_offset(segment.points[2], segment.points[3], amount); let p1 = line_intersection(p0, p1a, p1b, p2b) ?? p1a; let p2 = line_intersection(p2a, p3, p1b, p2b) ?? p2a; return new BezierSegment(p0, p1, p2, p3); } /* Join two segments */ function join_lines(output_bezier, seg1, seg2, line_join, miter_limit) { let p0 = seg1.points[3]; let p1 = seg2.points[0]; // Bevel if ( line_join == 3 ) return p0; // Connected, they don't need a joint if ( p0.is_equal(p1) ) return p0; let last_point = output_bezier.points[output_bezier.points.length - 1]; // Round if ( line_join == 2 ) { const ellipse_constant = 0.5519; let angle_out = seg1.tangent_angle(1); let angle_in = seg2.tangent_angle(0) + Math.PI; let center = line_intersection( p0, p0.add_polar(angle_out + Math.PI / 2, 100), p1, p1.add_polar(angle_out + Math.PI / 2, 100) ); let radius = center ? center.distance(p0) : p0.distance(p1) / 2; last_point.set_out_tangent(Point.polar(angle_out, 2 * radius * ellipse_constant)); output_bezier.add_vertex(p1) .set_in_tangent(Point.polar(angle_in, 2 * radius * ellipse_constant)); return p1; } // Miter let t0 = p0.is_equal(seg1.points[2]) ? seg1.points[0] : seg1.points[2]; let t1 = p1.is_equal(seg2.points[1]) ? seg2.points[3] : seg2.points[1]; let intersection = line_intersection(t0, p0, p1, t1); if ( intersection && intersection.distance(p0) < miter_limit ) { output_bezier.add_vertex(intersection); return intersection; } return p0; } function get_intersection(a, b) { let intersect = a.intersections(b); if ( intersect.length && fuzzy_compare(intersect[0], 1) ) intersect.shift(); if ( intersect.length ) return intersect[0]; return null; } function prune_segment_intersection(a, b) { let out_a = [...a]; let out_b = [...b]; let intersect = get_intersection(a[a.length-1], b[0]); if ( intersect ) { out_a[a.length-1] = a[a.length-1].split(intersect[0])[0]; out_b[0] = b[0].split(intersect[1])[1]; } if ( a.length > 1 && b.length > 1 ) { intersect = get_intersection(a[0], b[b.length - 1]); if ( intersect ) { return [ [a[0].split(intersect[0])[0]], [b[b.length-1].split(intersect[1])[1]], ]; } } return [out_a, out_b]; } function prune_intersections(segments) { for ( let i = 1; i < segments.length; i++ ) { [segments[i-1], segments[i]] = prune_segment_intersection(segments[i - 1], segments[i]); } if ( segments.length > 1 ) [segments[segments.length - 1], segments[0]] = prune_segment_intersection(segments[segments.length - 1], segments[0]); return segments; } function offset_segment_split(segment, amount) { /* We split each bezier segment into smaller pieces based on inflection points, this ensures the control point polygon is convex. (A cubic bezier can have none, one, or two inflection points) */ let flex = segment.inflection_points(); if ( flex.length == 0 ) { return [offset_segment(segment, amount)]; } else if ( flex.length == 1 || flex[1] == 1 ) { let [left, right] = segment.split(flex[0]); return [ offset_segment(left, amount), offset_segment(right, amount) ]; } else { let [left, mid_right] = segment.split(flex[0]); let t = (flex[1] - flex[0]) / (1 - flex[0]); let [mid, right] = mid_right.split(t); return [ offset_segment(left, amount), offset_segment(mid, amount), offset_segment(right, amount) ]; } } function offset_path( // Beziers as collected from the other shapes collected_shapes, amount, line_join, miter_limit, ) { let result = []; for ( let input_bezier of collected_shapes ) { let output_bezier = new Bezier(); output_bezier.closed = input_bezier.closed; let count = input_bezier.segment_count(); let multi_segments = []; for ( let i = 0; i < count; i++ ) multi_segments.push(offset_segment_split(input_bezier.segment(i), amount)); // Open paths are stroked rather than being simply offset if ( !input_bezier.closed ) { for ( let i = count - 1; i >= 0; i-- ) multi_segments.push(offset_segment_split(input_bezier.inverted_segment(i), amount)); } multi_segments = prune_intersections(multi_segments); // Add bezier segments to the output and apply line joints let last_point = null; let last_seg = null; for ( let multi_segment of multi_segments ) { if ( last_seg ) last_point = join_lines(output_bezier, last_seg, multi_segment[0], line_join, miter_limit); last_seg = multi_segment[multi_segment.length - 1]; for ( let segment of multi_segment ) { if ( segment.points[0].is_equal(last_point) ) { output_bezier.points[output_bezier.points.length - 1] .set_out_tangent(segment.points[1].sub(segment.points[0])); } else { output_bezier.add_vertex(segment.points[0]) .set_out_tangent(segment.points[1].sub(segment.points[0])); } output_bezier.add_vertex(segment.points[3]) .set_in_tangent(segment.points[2].sub(segment.points[3])); last_point = segment.points[3]; } } if ( multi_segments.length ) join_lines(output_bezier, last_seg, multi_segments[0][0], line_join, miter_limit); result.push(output_bezier); } return result; } // Example invocation offset_path([convert_shape(star)], modifier.a.k, modifier.lj, modifier.ml.k); /* Simple offset of a linear segment */ function linear_offset(p1, p2, amount) { let angle = Math.atan2(p2.x - p1.x, p2.y - p1.y); return [ p1.add_polar(angle, amount), p2.add_polar(angle, amount) ]; } /* Offset a bezier segment only works well if the segment is flat enough */ function offset_segment(segment, amount) { let [p0, p1a] = linear_offset(segment.points[0], segment.points[1], amount); let [p1b, p2b] = linear_offset(segment.points[1], segment.points[2], amount); let [p2a, p3] = linear_offset(segment.points[2], segment.points[3], amount); let p1 = line_intersection(p0, p1a, p1b, p2b) ?? p1a; let p2 = line_intersection(p2a, p3, p1b, p2b) ?? p2a; return new BezierSegment(p0, p1, p2, p3); } /* Join two segments */ function join_lines(output_bezier, seg1, seg2, line_join, miter_limit) { let p0 = seg1.points[3]; let p1 = seg2.points[0]; // Bevel if ( line_join == 3 ) return p0; // Connected, they don't need a joint if ( p0.is_equal(p1) ) return p0; let last_point = output_bezier.points[output_bezier.points.length - 1]; // Round if ( line_join == 2 ) { const ellipse_constant = 0.5519; let angle_out = seg1.tangent_angle(1); let angle_in = seg2.tangent_angle(0) + Math.PI; let center = line_intersection( p0, p0.add_polar(angle_out + Math.PI / 2, 100), p1, p1.add_polar(angle_out + Math.PI / 2, 100) ); let radius = center ? center.distance(p0) : p0.distance(p1) / 2; last_point.set_out_tangent(Point.polar(angle_out, 2 * radius * ellipse_constant)); output_bezier.add_vertex(p1) .set_in_tangent(Point.polar(angle_in, 2 * radius * ellipse_constant)); return p1; } // Miter let t0 = p0.is_equal(seg1.points[2]) ? seg1.points[0] : seg1.points[2]; let t1 = p1.is_equal(seg2.points[1]) ? seg2.points[3] : seg2.points[1]; let intersection = line_intersection(t0, p0, p1, t1); if ( intersection && intersection.distance(p0) < miter_limit ) { output_bezier.add_vertex(intersection); return intersection; } return p0; } function get_intersection(a, b) { let intersect = a.intersections(b); if ( intersect.length && fuzzy_compare(intersect[0], 1) ) intersect.shift(); if ( intersect.length ) return intersect[0]; return null; } function prune_segment_intersection(a, b) { let out_a = [...a]; let out_b = [...b]; let intersect = get_intersection(a[a.length-1], b[0]); if ( intersect ) { out_a[a.length-1] = a[a.length-1].split(intersect[0])[0]; out_b[0] = b[0].split(intersect[1])[1]; } if ( a.length > 1 && b.length > 1 ) { intersect = get_intersection(a[0], b[b.length - 1]); if ( intersect ) { return [ [a[0].split(intersect[0])[0]], [b[b.length-1].split(intersect[1])[1]], ]; } } return [out_a, out_b]; } function prune_intersections(segments) { for ( let i = 1; i < segments.length; i++ ) { [segments[i-1], segments[i]] = prune_segment_intersection(segments[i - 1], segments[i]); } if ( segments.length > 1 ) [segments[segments.length - 1], segments[0]] = prune_segment_intersection(segments[segments.length - 1], segments[0]); return segments; } function offset_segment_split(segment, amount) { /* We split each bezier segment into smaller pieces based on inflection points, this ensures the control point polygon is convex. (A cubic bezier can have none, one, or two inflection points) */ let flex = segment.inflection_points(); if ( flex.length == 0 ) { return [offset_segment(segment, amount)]; } else if ( flex.length == 1 || flex[1] == 1 ) { let [left, right] = segment.split(flex[0]); return [ offset_segment(left, amount), offset_segment(right, amount) ]; } else { let [left, mid_right] = segment.split(flex[0]); let t = (flex[1] - flex[0]) / (1 - flex[0]); let [mid, right] = mid_right.split(t); return [ offset_segment(left, amount), offset_segment(mid, amount), offset_segment(right, amount) ]; } } function offset_path( // Beziers as collected from the other shapes collected_shapes, amount, line_join, miter_limit, ) { let result = []; for ( let input_bezier of collected_shapes ) { let output_bezier = new Bezier(); output_bezier.closed = input_bezier.closed; let count = input_bezier.segment_count(); let multi_segments = []; for ( let i = 0; i < count; i++ ) multi_segments.push(offset_segment_split(input_bezier.segment(i), amount)); // Open paths are stroked rather than being simply offset if ( !input_bezier.closed ) { for ( let i = count - 1; i >= 0; i-- ) multi_segments.push(offset_segment_split(input_bezier.inverted_segment(i), amount)); } multi_segments = prune_intersections(multi_segments); // Add bezier segments to the output and apply line joints let last_point = null; let last_seg = null; for ( let multi_segment of multi_segments ) { if ( last_seg ) last_point = join_lines(output_bezier, last_seg, multi_segment[0], line_join, miter_limit); last_seg = multi_segment[multi_segment.length - 1]; for ( let segment of multi_segment ) { if ( segment.points[0].is_equal(last_point) ) { output_bezier.points[output_bezier.points.length - 1] .set_out_tangent(segment.points[1].sub(segment.points[0])); } else { output_bezier.add_vertex(segment.points[0]) .set_out_tangent(segment.points[1].sub(segment.points[0])); } output_bezier.add_vertex(segment.points[3]) .set_in_tangent(segment.points[2].sub(segment.points[3])); last_point = segment.points[3]; } } if ( multi_segments.length ) join_lines(output_bezier, last_seg, multi_segments[0][0], line_join, miter_limit); result.push(output_bezier); } return result; } var lottie_player_38_bezier = new LottiePlayer('lottie_target_38_bezier', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"sh\", \"nm\": \"Shape\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [], \"i\": [], \"o\": []}}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}); var lottie_player_38 = new PlaygroundPlayer( 38, 'playground_38_5', 'lottie_target_38', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{9199543e-3552-4e51-a802-623f2a4a2ca1}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 222.72242736816406}, \"ir\": {\"a\": 0, \"k\": 111.36121368408203}, \"r\": {\"a\": 0, \"k\": 358.67291259765625}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"op\", \"nm\": \"Offset Path\", \"mn\": \"{b4af429a-546e-4728-a869-711a404c55ae}\", \"a\": {\"a\": 0, \"k\": 10}, \"lj\": 2, \"ml\": {\"a\": 0, \"k\": 100}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 3}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { let bezier_lottie = lottie_player_38_bezier.lottie; lottie.layers[0].shapes[0].it[0].is.k = data[\"Star Roundness\"]; lottie.layers[0].shapes[0].it[0].os.k = data[\"Star Roundness\"]; lottie.layers[0].shapes[0].it[1].a.k = data[\"Amount\"]; lottie.layers[0].shapes[0].it[1].lj = Number(data[\"Line Join\"]); lottie.layers[0].shapes[0].it[1].ml.k = data[\"Miter Limit\"]; let star = lottie.layers[0].shapes[0].it[0]; bezier_lottie.layers[0].shapes[0].it[1].w.k = 3; this.json_viewer_contents = lottie.layers[0].shapes[0].it[1]; let modifier = lottie.layers[0].shapes[0].it[1]; let bez_result = offset_path([convert_shape(star)], modifier.a.k, modifier.lj, modifier.ml.k); if ( !Array.isArray(bez_result) ) bez_result = [bez_result]; let out_shapes = bez_result.map(b => ({ ty: \"sh\", \"ks\": {a: 0, k: b.to_lottie()} })); let bez_target = bezier_lottie.layers[0].shapes[0].it; bez_target.splice(0, bez_target.length - 2, ...out_shapes); lottie_player_38_bezier.reload(); this.set_json('playground_38_5_bezier', out_shapes[0].ks.k); }, {} );","title":"Offset Path"},{"location":"rendering/#trim-path","text":"Start 0 End 50 Offset 0 Multiple Shapes Simultaneously Individually Show JSON function trim_path_gather_chunks(collected_shapes, multiple) { let chunks = []; // Shapes are handled as a single unit if ( multiple === 2 ) chunks.push({segments: [], length: 0}); for ( let input_bezier of collected_shapes ) { // Shapes are all affected separately if ( multiple === 1 ) chunks.push({segments: [], length: 0}); let chunk = chunks[chunks.length-1]; for ( let i = 0; i < input_bezier.segment_count(); i++ ) { let segment = input_bezier.segment(i); let length = segment.get_length(); chunk.segments.push(segment); chunk.length += length; } // Use null as a marker to start a new bezier if ( multiple == 2 ) chunk.segments.push(null); } return chunks; } function trim_path_chunk(chunk, start, end, output_shapes) { // Note: start and end have been normalized and have the offset applied // The offset itself was normalized into [0, 1] so this is always true: // 0 <= start < end <= 2 // Some offsets require us to handle different \"splits\" // We want each split to be a pair [s, e] such that // 0 <= s < e <= 1 var splits = []; if ( end <= 1 ) { // Simplest case, the segment is in [0, 1] splits.push([start, end]); } else if ( start > 1 ) { // The whole segment is outside [0, 1] splits.push([start-1, end-1]); } else { // The segment goes over the end point, so we need two splits splits.push([start, 1]); splits.push([0, end-1]); } // Each split is a separate bezier, all left to do is finding the // bezier segment to add to the output for ( let [s, e] of splits ) { let start_length = s * chunk.length; let start_t; let end_length = e * chunk.length; let prev_length = 0; let output_bezier = new Bezier(false); output_shapes.push(output_bezier); for ( let i = 0; i < chunk.segments.length; i++ ) { let segment = chunk.segments[i]; // New bezier marker found if ( segment === null ) { output_bezier = new Bezier(false); output_shapes.push(output_bezier); continue; } if ( segment.length >= end_length ) { let end_t = segment.t_at_length(end_length); if ( segment.length >= start_length ) { start_t = segment.t_at_length(start_length); segment = segment.split(start_t)[1]; end_t = (end_t - start_t) / (1 - start_t); } output_bezier.add_segment(segment.split(end_t)[0], false); break; } if ( start_t === undefined ) { if ( segment.length >= start_length ) { start_t = segment.t_at_length(start_length); output_bezier.add_segment(segment.split(start_t)[1], false); } } else { output_bezier.add_segment(segment, true); } start_length -= segment.length; end_length -= segment.length; } } } function trim_path( collected_shapes, start, end, offset, multiple ) { // Normalize Inputs offset = offset / 360 % 1; if ( offset < 0 ) offset += 1; start = Math.min(1, Math.max(0, start / 100)); end = Math.min(1, Math.max(0, end / 100)); if ( end < start ) [start, end] = [end, start]; // Apply offset start += offset; end += offset; // Handle the degenerate cases if ( fuzzy_compare(start, end) ) return [new Bezier(false)]; if ( fuzzy_zero(start) && fuzzy_compare(end, 1) ) return collected_shapes; // Gather up the segments to trim let chunks = trim_path_gather_chunks(collected_shapes, multiple); let output_shapes = []; for ( let chunk of chunks ) trim_path_chunk(chunk, start, end, output_shapes); return output_shapes; } // Example invocation trim_path(shapes, modifier.s.k, modifier.e.k, modifier.o.k, modifier.m); function trim_path_gather_chunks(collected_shapes, multiple) { let chunks = []; // Shapes are handled as a single unit if ( multiple === 2 ) chunks.push({segments: [], length: 0}); for ( let input_bezier of collected_shapes ) { // Shapes are all affected separately if ( multiple === 1 ) chunks.push({segments: [], length: 0}); let chunk = chunks[chunks.length-1]; for ( let i = 0; i < input_bezier.segment_count(); i++ ) { let segment = input_bezier.segment(i); let length = segment.get_length(); chunk.segments.push(segment); chunk.length += length; } // Use null as a marker to start a new bezier if ( multiple == 2 ) chunk.segments.push(null); } return chunks; } function trim_path_chunk(chunk, start, end, output_shapes) { // Note: start and end have been normalized and have the offset applied // The offset itself was normalized into [0, 1] so this is always true: // 0 <= start < end <= 2 // Some offsets require us to handle different \"splits\" // We want each split to be a pair [s, e] such that // 0 <= s < e <= 1 var splits = []; if ( end <= 1 ) { // Simplest case, the segment is in [0, 1] splits.push([start, end]); } else if ( start > 1 ) { // The whole segment is outside [0, 1] splits.push([start-1, end-1]); } else { // The segment goes over the end point, so we need two splits splits.push([start, 1]); splits.push([0, end-1]); } // Each split is a separate bezier, all left to do is finding the // bezier segment to add to the output for ( let [s, e] of splits ) { let start_length = s * chunk.length; let start_t; let end_length = e * chunk.length; let prev_length = 0; let output_bezier = new Bezier(false); output_shapes.push(output_bezier); for ( let i = 0; i < chunk.segments.length; i++ ) { let segment = chunk.segments[i]; // New bezier marker found if ( segment === null ) { output_bezier = new Bezier(false); output_shapes.push(output_bezier); continue; } if ( segment.length >= end_length ) { let end_t = segment.t_at_length(end_length); if ( segment.length >= start_length ) { start_t = segment.t_at_length(start_length); segment = segment.split(start_t)[1]; end_t = (end_t - start_t) / (1 - start_t); } output_bezier.add_segment(segment.split(end_t)[0], false); break; } if ( start_t === undefined ) { if ( segment.length >= start_length ) { start_t = segment.t_at_length(start_length); output_bezier.add_segment(segment.split(start_t)[1], false); } } else { output_bezier.add_segment(segment, true); } start_length -= segment.length; end_length -= segment.length; } } } function trim_path( collected_shapes, start, end, offset, multiple ) { // Normalize Inputs offset = offset / 360 % 1; if ( offset < 0 ) offset += 1; start = Math.min(1, Math.max(0, start / 100)); end = Math.min(1, Math.max(0, end / 100)); if ( end < start ) [start, end] = [end, start]; // Apply offset start += offset; end += offset; // Handle the degenerate cases if ( fuzzy_compare(start, end) ) return [new Bezier(false)]; if ( fuzzy_zero(start) && fuzzy_compare(end, 1) ) return collected_shapes; // Gather up the segments to trim let chunks = trim_path_gather_chunks(collected_shapes, multiple); let output_shapes = []; for ( let chunk of chunks ) trim_path_chunk(chunk, start, end, output_shapes); return output_shapes; } var lottie_player_39_bezier = new LottiePlayer('lottie_target_39_bezier', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"sh\", \"nm\": \"Shape\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [], \"i\": [], \"o\": []}}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}); var lottie_player_39 = new PlaygroundPlayer( 39, 'playground_39_5', 'lottie_target_39', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [128, 128]}, \"or\": {\"a\": 0, \"k\": 100}, \"ir\": {\"a\": 0, \"k\": 50}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{74587b40-1ef1-445d-b9ab-02b8a42a96aa}\", \"p\": {\"a\": 0, \"k\": [384, 128]}, \"s\": {\"a\": 0, \"k\": [200, 200]}}, {\"ty\": \"rc\", \"nm\": \"Rect\", \"mn\": \"{0776f2df-2619-415c-b10d-f648f2edfa0f}\", \"d\": 1, \"p\": {\"a\": 0, \"k\": [128, 384]}, \"s\": {\"a\": 0, \"k\": [200, 200]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"sr\", \"nm\": \"Triangle\", \"mn\": \"{db373594-d0ae-44ff-9295-30ff72616af2}\", \"p\": {\"a\": 0, \"k\": [384, 384]}, \"or\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 3}, \"sy\": 2, \"os\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"tm\", \"nm\": \"Trim Path\", \"mn\": \"{dcd7570f-5105-485b-bd43-42ad990b01e8}\", \"s\": {\"a\": 0, \"k\": 0}, \"e\": {\"a\": 0, \"k\": 50}, \"o\": {\"a\": 0, \"k\": 0}, \"m\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 20}}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { let bezier_lottie = lottie_player_39_bezier.lottie; lottie.layers[0].shapes[4].s.k = data[\"Start\"]; lottie.layers[0].shapes[4].e.k = data[\"End\"]; lottie.layers[0].shapes[4].o.k = data[\"Offset\"]; lottie.layers[0].shapes[4].m = Number(data[\"Multiple Shapes\"]); let siblings = bezier_lottie.layers[0].shapes[0].it; siblings[siblings.length-2].w.k = 20; let shapes = []; for ( let i = 0; i < 4; i++ ) shapes.push(convert_shape(lottie.layers[0].shapes[i])); this.json_viewer_contents = lottie.layers[0].shapes[4]; let modifier = lottie.layers[0].shapes[4]; let bez_result = trim_path(shapes, modifier.s.k, modifier.e.k, modifier.o.k, modifier.m); if ( !Array.isArray(bez_result) ) bez_result = [bez_result]; let out_shapes = bez_result.map(b => ({ ty: \"sh\", \"ks\": {a: 0, k: b.to_lottie()} })); let bez_target = bezier_lottie.layers[0].shapes[0].it; bez_target.splice(0, bez_target.length - 2, ...out_shapes); lottie_player_39_bezier.reload(); this.set_json('playground_39_5_bezier', out_shapes[0].ks.k); }, {} );","title":"Trim Path"},{"location":"rendering/#transform","text":"This is how to convert a transform object into a matrix. Assuming the matrix a c 0 0 b d 0 0 0 0 1 0 tx ty 0 1 The names a , b , etc are the ones commonly used for CSS transforms . 4D matrix to allow for 3D transforms, even though currently lottie only supports 2D graphics. Multiplications are right multiplications ( Next = Previous * StepOperation ). If your transform is transposed ( tx , ty are on the last column), perform left multiplication instead. Perform the following operations on a matrix starting from the identity matrix (or the parent object's transform matrix): Translate by -a : 1 0 0 0 0 1 0 0 0 0 1 0 -a[0] -a[1] 0 1 Scale by s/100 : s[0]/100 0 0 0 0 s[1]/100 0 0 0 0 1 0 0 0 0 1 Rotate by -sa (can be skipped if not skewing) cos(-sa) sin(-sa) 0 0 -sin(-sa) cos(-sa) 0 0 0 0 1 0 0 0 0 1 Skew by sk (can be skipped if not skewing) 1 tan(-sk) 0 0 0 1 0 0 0 0 1 0 0 0 0 1 Rotate by sa (can be skipped if not skewing) cos(sa) sin(sa) 0 0 -sin(sa) cos(sa) 0 0 0 0 1 0 0 0 0 1 Rotate by -r cos(-r) sin(-r) 0 0 -sin(-r) cos(-r) 0 0 0 0 1 0 0 0 0 1 If you are handling an auto orient layer, evaluate and apply auto-orient rotation. Translate by p 1 0 0 0 0 1 0 0 0 0 1 0 p[0] p[1] 0 1 Anchor X 256 Anchor Y 256 Position X 256 Position Y 256 Scale X 100 Scale Y 100 Rotation 0 Skew 0 Skew Angle 0 Opacity 100 Show JSON var lottie_player_40 = new PlaygroundPlayer( 40, 'playground_40_11', 'lottie_target_40', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{a3bb98c7-d0dd-4484-b6da-74a0e70eaf2f}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 2, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Anchor\", \"mn\": \"{04f9b742-3603-49fa-9552-ea04de1a3f33}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{4251e46a-bb13-464b-913c-e67c44a218da}\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{7d3070ed-88a3-41aa-a62e-7db8df1bd312}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.9411764705882353, 0.11372549019607843, 0.0392156862745098]}, \"r\": 1}]}, {\"ddd\": 0, \"ty\": 4, \"ind\": 1, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Transformed\", \"mn\": \"{d00298c4-66b4-4ae4-a730-22c1eb85c188}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}, \"sk\": {\"a\": 0, \"k\": 0}, \"sa\": {\"a\": 0, \"k\": 0}}, \"shapes\": [{\"ty\": \"rc\", \"nm\": \"Rectangle 1\", \"mn\": \"{bf8ad877-113b-4df8-a2e2-3bb4af32edf7}\", \"p\": {\"a\": 0, \"k\": [252.75223880597017, 250.60298507462684]}, \"s\": {\"a\": 0, \"k\": [319.8089552238806, 330.98507462686564]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"nm\": \"Fill 1\", \"mn\": \"{b9040dc8-0753-4a6e-b5f1-d508d17bbd4f}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}, \"r\": 1}]}, {\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Reference\", \"mn\": \"{8f351be7-8a51-4310-9dc3-59ed21594815}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"mn\": \"{cb4f7b74-bed1-493b-a0e6-01b00566aedd}\", \"p\": {\"a\": 0, \"k\": [252.75223880597017, 250.60298507462684]}, \"s\": {\"a\": 0, \"k\": [319.8089552238806, 330.98507462686564]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{05064670-7e14-4141-89c1-e0f0f3a1c57d}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.1607843137254902, 0.1843137254901961, 0.4588235294117647]}, \"r\": 1}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { if ( lottie.layers.length == 3 ) { lottie.layers.splice(1, 0, { \"ty\": 4, \"st\": 0, \"ip\": 0, \"op\": 180, \"ks\": {}, \"shapes\": [ { \"ty\": \"sh\", \"ks\": { \"k\": { \"c\": true, \"v\": [], \"i\": [[0, 0], [0, 0], [0, 0], [0, 0]], \"o\": [[0, 0], [0, 0], [0, 0], [0, 0]], }, \"a\": 0 } }, { \"ty\": \"st\", \"o\": { \"a\": 0, \"k\": 100 }, \"w\": { \"a\": 0, \"k\": 2 }, \"c\": { \"a\": 0, \"k\": [ 0.078, 0.741, 0.431 ] } } ] }); } lottie.layers[0].ks.p.k[0] = data[\"Anchor X\"]; lottie.layers[2].ks.a.k[0] = data[\"Anchor X\"]; lottie.layers[0].ks.p.k[1] = data[\"Anchor Y\"]; lottie.layers[2].ks.a.k[1] = data[\"Anchor Y\"]; lottie.layers[2].ks.p.k[0] = data[\"Position X\"]; lottie.layers[2].ks.p.k[1] = data[\"Position Y\"]; lottie.layers[2].ks.s.k[0] = data[\"Scale X\"]; lottie.layers[2].ks.s.k[1] = data[\"Scale Y\"]; lottie.layers[2].ks.r.k = data[\"Rotation\"]; lottie.layers[2].ks.sk.k = data[\"Skew\"]; lottie.layers[2].ks.sa.k = data[\"Skew Angle\"]; lottie.layers[2].ks.o.k = data[\"Opacity\"]; var transform = new LottieMatrix(); transform.translate(-data[\"Anchor X\"], -data[\"Anchor Y\"]); transform.scale(data[\"Scale X\"] / 100, data[\"Scale Y\"] / 100); transform.skew(data[\"Skew\"] * Math.PI / 180, data[\"Skew Angle\"] * Math.PI / 180); transform.rotate(-data[\"Rotation\"] * Math.PI / 180); transform.translate(data[\"Position X\"], data[\"Position Y\"]); var cx = lottie.layers[2].shapes[0].p.k[0]; var cy = lottie.layers[2].shapes[0].p.k[1]; var rx = lottie.layers[2].shapes[0].s.k[0] / 2; var ry = lottie.layers[2].shapes[0].s.k[1] / 2; lottie.layers[1].shapes[0].ks.k.v = [ transform.map(cx - rx, cy - ry).slice(0, 2), transform.map(cx + rx, cy - ry).slice(0, 2), transform.map(cx + rx, cy + ry).slice(0, 2), transform.map(cx - rx, cy + ry).slice(0, 2) ]; this.json_viewer_contents = [ transform.elements.slice(0, 4), transform.elements.slice(4, 8), transform.elements.slice(8, 12), transform.elements.slice(12, 16) ].map(x => Array.from(x)) ; }, {} );","title":"Transform"},{"location":"rendering/#3d-transform","text":"If you have a 3D transform, the process is similar, with a , p , s , using their 3D matrices, note that for p and a the Z axis is inverted. The rotation step is a bit more complicated, with the 2D rotation being equivalent to a Z rotation. The rotation step above is replaced with the following set of steps: Rotate by -rz cos(-r) sin(-r) 0 0 -sin(-r) cos(-r) 0 0 0 0 1 0 0 0 0 1 Rotate by ry cos(r) 0 sin(r) 0 0 1 0 0 -sin(r) 0 cos(-r) 0 0 0 1 Rotate by rx 1 0 0 0 0 cos(r) -sin(r) 0 0 -sin(r) cos(-r) 0 0 0 0 1 Then repeat the steps for or : Rotate by -or[2] (Z axis) cos(-r) sin(-r) 0 0 -sin(-r) cos(-r) 0 0 0 0 1 0 0 0 0 1 Rotate by or[1] (Y axis) cos(r) 0 sin(r) 0 0 1 0 0 -sin(r) 0 cos(-r) 0 0 0 1 Rotate by or[0] (X axis) 1 0 0 0 0 cos(r) -sin(r) 0 0 -sin(r) cos(-r) 0 0 0 0 1","title":"3D Transform"},{"location":"rendering/#auto-orient","text":"Auto-orient is only relevant for layers that have ao set to 1 an animated position. You get the derivative of the position property at the current time as a pair ( dx , dy ), and find the angle with atan2(dy, dx) , then rotate by that angle clockwise: cos(-r) sin(-r) 0 0 -sin(-r) cos(-r) 0 0 0 0 1 0 0 0 0 1","title":"Auto Orient"},{"location":"rendering/#animated-properties","text":"Assuming a 1D property, a keyframe looks something like this: { \"t\": start_time, \"s\": [ start_value ], \"o\": { \"x\": [ ox ], \"y\": [ oy ] }, \"i\": { \"x\": [ ix ], \"y\": [ iy ] } } Where: t is the time at the start of the keyframe (in frames), s is the value at that time i and o are the in/out bezier tangents The transition between keyframes is defined by two keyframes, for simplicity we'll refer to the named values above plus end_time and end_value corresponding to t and s on the keyframe after the one listed. The transition is given as a cubic bezier curve whose x axis is time and the y axis is the interpolating factor between start_value and end_value . The four points of this bezier curve are: (0, 0), (ox, oy), (iy, iy), (1, 1). x is given by x = (current_time - start_time) / (end_time - start_time) . If the bezier is defined as a t 3 + b t 2 + c t + d = 0 then you need to find the cubic roots of a t 3 + b t 2 + c t + d - x = 0 to find the t corresponding to that x , (You only need to consider real roots in [0, 1]). Then you can find the y by evaluating the bezier at t . The final value is as follows: lerp(y, start_value, end_value) . Show JSON KeyframePreviewEditor.stand_alone(document.getElementById(\"editor_41\"), (lottie) => { var raw_json = JSON.stringify(lottie, undefined, 4); var pretty_json = hljs.highlight(\"json\", raw_json).value; document.getElementById(\"json_viewer_41\").innerHTML = pretty_json; }, {foreground: function () { if ( !this.x_input ) return; var t1 = this.points[0].out_tan.logical_coords(); var t2 = this.points[1].in_tan.logical_coords(); var seg = new BezierSegment( new Point(0, 0), new Point(t1.x, t1.y), new Point(t2.x, t2.y), new Point(1, 1) ); let x = Number(this.x_input.value); this.context.lineWidth = 1; this.context.strokeStyle = \"red\"; this.context.beginPath(); this.context.moveTo(...this.logical_to_canvas(x, 0)); this.context.lineTo(...this.logical_to_canvas(x, 1)); let t = seg.t_at_x(x); let y = seg.value(t).y; this.context.moveTo(...this.logical_to_canvas(0, y)); this.context.lineTo(...this.logical_to_canvas(1, y)); this.table_x.innerText = x; this.table_t.innerText = t; this.table_y.innerText = y; this.context.stroke(); }, init: function (editor, container) { var inp = container.appendChild(document.createElement(\"input\")); var style = \"width: \" + editor.bezier_editor.canvas.width + \"px\"; editor.bezier_editor.x_input = inp; inp.setAttribute(\"type\", \"range\"); inp.setAttribute(\"min\", \"0\"); inp.setAttribute(\"max\", \"1\"); inp.setAttribute(\"value\", \"0\"); inp.setAttribute(\"step\", \"0.01\"); inp.setAttribute(\"style\", style); inp.addEventListener(\"input\", () => editor.bezier_editor.draw_frame()); var table = container.appendChild(document.createElement(\"table\")); table.setAttribute(\"style\", style); for ( let v of \"xty\" ) { var tr = table.appendChild(document.createElement(\"tr\")); tr.appendChild(document.createElement(\"th\")).appendChild(document.createTextNode(v)); var td = tr.appendChild(document.createElement(\"td\")); td.setAttribute(\"style\", \"text-align: left; width: 90%;\"); editor.bezier_editor[\"table_\" + v] = td; } editor.bezier_editor.draw_frame(); }, });","title":"Animated Properties"},{"location":"rendering/#effects","text":".webgl-shader { transform: scaleY(-1); }","title":"Effects"},{"location":"rendering/#fill-effect","text":"Opacity 1 Color Red 1 Green 0.9 Blue 0 Show JSON #version 100 uniform highp vec4 color; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; void main() { highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y); highp vec4 pixel = texture2D(texture_sampler, uv); gl_FragColor = color; gl_FragColor.a = 1.0; gl_FragColor *= pixel.a * color.a; } var lottie_shader_42 = new SinglePassShader(document.getElementById('lottie_target_42_canvas')); lottie_shader_42.set_fragment('#version 100\\n\\nuniform highp vec4 color;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\n\\nvoid main()\\n{\\n highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y);\\n highp vec4 pixel = texture2D(texture_sampler, uv);\\n\\n gl_FragColor = color;\\n gl_FragColor.a = 1.0;\\n gl_FragColor *= pixel.a * color.a;\\n}') var lottie_player_42 = new PlaygroundPlayer( 42, 'playground_42_5', 'lottie_target_42', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 21, \"ef\": [{\"ty\": 3, \"v\": {\"k\": [0, 0], \"a\": 0}}, {\"ty\": 7, \"v\": {\"k\": 0, \"a\": 0}}, {\"ty\": 2, \"v\": {\"k\": [1, 0.9, 0, 1], \"a\": 0}}, {\"ty\": 2, \"v\": {\"k\": [0, 0, 0, 1], \"a\": 0}}, {\"ty\": 7, \"v\": {\"k\": 0, \"a\": 0}}, {\"ty\": 0, \"v\": {\"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"a\": 0, \"k\": 0}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { let shader = lottie_shader_42; lottie.layers[0].ef[0].ef[6].v.k = data[\"Opacity\"]; lottie.layers[0].ef[0].ef[2].v.k[0] = data[\"Red\"]; lottie.layers[0].ef[0].ef[2].v.k[1] = data[\"Green\"]; lottie.layers[0].ef[0].ef[2].v.k[2] = data[\"Blue\"]; shader.set_uniform(\"color\", \"4fv\", [data[\"Red\"], data[\"Green\"], data[\"Blue\"], data[\"Opacity\"]]);this.json_viewer_contents = lottie.layers[0].ef[0]; shader.render(); }, {} );","title":"Fill Effect"},{"location":"rendering/#tritone-effect","text":"Bright Red 1 Green 1 Blue 1 Mid Red 0.3 Green 0.8 Blue 0.3 Dark Red 0 Green 0 Blue 0 Show JSON #version 100 uniform highp vec4 bright; uniform highp vec4 mid; uniform highp vec4 dark; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; void main() { highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y); highp vec4 pixel = texture2D(texture_sampler, uv); highp float lightness = sqrt(pixel.r * pixel.r * 0.299 + pixel.g * pixel.g * 0.587 + pixel.b * pixel.b * 0.114); // If you want results more similar to lottie-web use the lightness below // (this shader has a more accurate lightness calculation) // lightness = sqrt((pixel.r * pixel.r + pixel.g * pixel.g + pixel.b * pixel.b) / 3.0); if ( lightness < 0.5 ) { lightness *= 2.0; gl_FragColor = dark * (1.0 - lightness) + mid * lightness; } else { lightness = (lightness - 0.5) * 2.0; gl_FragColor = mid * (1.0 - lightness) + bright * lightness; } gl_FragColor *= pixel.a; } var lottie_shader_43 = new SinglePassShader(document.getElementById('lottie_target_43_canvas')); lottie_shader_43.set_fragment('#version 100\\n\\nuniform highp vec4 bright;\\nuniform highp vec4 mid;\\nuniform highp vec4 dark;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\n\\nvoid main()\\n{\\n highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y);\\n highp vec4 pixel = texture2D(texture_sampler, uv);\\n\\n highp float lightness = sqrt(pixel.r * pixel.r * 0.299 + pixel.g * pixel.g * 0.587 + pixel.b * pixel.b * 0.114);\\n // If you want results more similar to lottie-web use the lightness below\\n // (this shader has a more accurate lightness calculation)\\n // lightness = sqrt((pixel.r * pixel.r + pixel.g * pixel.g + pixel.b * pixel.b) / 3.0);\\n\\n if ( lightness < 0.5 )\\n {\\n lightness *= 2.0;\\n gl_FragColor = dark * (1.0 - lightness) + mid * lightness;\\n }\\n else\\n {\\n lightness = (lightness - 0.5) * 2.0;\\n gl_FragColor = mid * (1.0 - lightness) + bright * lightness;\\n }\\n\\n gl_FragColor *= pixel.a;\\n}') var lottie_player_43 = new PlaygroundPlayer( 43, 'playground_43_10', 'lottie_target_43', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 23, \"ef\": [{\"ty\": 2, \"v\": {\"k\": [1, 1, 1, 1], \"a\": 0}}, {\"ty\": 2, \"v\": {\"k\": [0.3, 0.8, 0.3, 1], \"a\": 0}}, {\"ty\": 2, \"v\": {\"k\": [0, 0, 0, 1], \"a\": 0}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { let shader = lottie_shader_43; lottie.layers[0].ef[0].ef[0].v.k[0] = data[\"r1\"]; lottie.layers[0].ef[0].ef[0].v.k[1] = data[\"g1\"]; lottie.layers[0].ef[0].ef[0].v.k[2] = data[\"b1\"]; lottie.layers[0].ef[0].ef[1].v.k[0] = data[\"r2\"]; lottie.layers[0].ef[0].ef[1].v.k[1] = data[\"g2\"]; lottie.layers[0].ef[0].ef[1].v.k[2] = data[\"b2\"]; lottie.layers[0].ef[0].ef[2].v.k[0] = data[\"r3\"]; lottie.layers[0].ef[0].ef[2].v.k[1] = data[\"g3\"]; lottie.layers[0].ef[0].ef[2].v.k[2] = data[\"b3\"]; shader.set_uniform(\"bright\", \"4fv\", [data[\"r1\"], data[\"g1\"], data[\"b1\"], 1]); shader.set_uniform(\"mid\", \"4fv\", [data[\"r2\"], data[\"g2\"], data[\"b2\"], 1]); shader.set_uniform(\"dark\", \"4fv\", [data[\"r3\"], data[\"g3\"], data[\"b3\"], 1]); this.json_viewer_contents = lottie.layers[0].ef[0]; shader.render(); }, {} );","title":"Tritone Effect"},{"location":"rendering/#gaussian-blur","text":"This is a two-pass shader, the uniform pass is has value 0 on the first pass and value 1 on the second pass. Sigma 25 Direction Both Horizontal Vertical Wrap Show JSON #version 300 es #define PI 3.1415926538 precision highp float; uniform float sigma; uniform int direction; uniform int kernel_size; uniform bool wrap; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; uniform int pass; out vec4 FragColor; vec4 texture_value(vec2 uv) { if ( wrap ) { if ( uv.x < 0. ) uv.x = 1. - uv.x; if ( uv.x > 1. ) uv.x = uv.x - 1.; if ( uv.y < 0. ) uv.y = 1. - uv.y; if ( uv.y > 1. ) uv.y = uv.y - 1.; } else if ( uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1. ) { return vec4(0.0); } return texture(texture_sampler, uv); } vec4 blur_pass(float sigma, int kernel_size, vec2 uv, bool horizontal) { float side = float(kernel_size / 2); vec2 direction_vector = horizontal ? vec2(1.0, 0.0) / canvas_size.x : vec2(0.0, 1.0) / canvas_size.y; vec3 delta_gauss; delta_gauss.x = 1.0 / (sqrt(2.0 * PI) * sigma); delta_gauss.y = exp(-0.5 / (sigma * sigma)); delta_gauss.z = delta_gauss.y * delta_gauss.y; vec4 avg = vec4(0.0, 0.0, 0.0, 0.0); float sum = 0.0; vec4 pixel = texture_value(uv); avg += pixel * delta_gauss.x; sum += delta_gauss.x; delta_gauss.xy *= delta_gauss.yz; for ( float i = 1.0; i <= side; i++) { for ( float s = -1.0; s <= 1.0; s += 2.0 ) { vec2 pos = uv + s * i * direction_vector; pixel = texture_value(pos); avg += pixel * delta_gauss.x; } sum += 2.0 * delta_gauss.x; delta_gauss.xy *= delta_gauss.yz; } avg /= sum; return avg; } void main() { highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y); int actual_kernel_size = kernel_size == 0 ? int(0.5 + 6.0 * sigma) : kernel_size; const float multiplier = 0.25; if ( sigma == 0.0 ) { FragColor = texture(texture_sampler, uv); } else if ( pass == 0 ) { if ( direction != 3 ) FragColor = blur_pass(sigma * multiplier, actual_kernel_size, uv, true); else FragColor = texture(texture_sampler, uv); } else if ( pass == 1 ) { if ( direction != 2 ) FragColor = blur_pass(sigma * multiplier, actual_kernel_size, uv, false); else FragColor = texture(texture_sampler, uv); } } var lottie_shader_44 = new MultiPassShader(document.getElementById('lottie_target_44_canvas')); var program_44_0 = new ShaderProgram(lottie_shader_44.gl); program_44_0.set_fragment('#version 300 es\\n\\n#define PI 3.1415926538\\nprecision highp float;\\n\\nuniform float sigma;\\nuniform int direction;\\nuniform int kernel_size;\\nuniform bool wrap;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\nuniform int pass;\\n\\nout vec4 FragColor;\\n\\n\\nvec4 texture_value(vec2 uv)\\n{\\n if ( wrap )\\n {\\n if ( uv.x < 0. ) uv.x = 1. - uv.x;\\n if ( uv.x > 1. ) uv.x = uv.x - 1.;\\n if ( uv.y < 0. ) uv.y = 1. - uv.y;\\n if ( uv.y > 1. ) uv.y = uv.y - 1.;\\n }\\n else if ( uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1. )\\n {\\n return vec4(0.0);\\n }\\n\\n return texture(texture_sampler, uv);\\n}\\n\\n\\nvec4 blur_pass(float sigma, int kernel_size, vec2 uv, bool horizontal)\\n{\\n float side = float(kernel_size / 2);\\n\\n vec2 direction_vector = horizontal ?\\n vec2(1.0, 0.0) / canvas_size.x :\\n vec2(0.0, 1.0) / canvas_size.y;\\n\\n vec3 delta_gauss;\\n delta_gauss.x = 1.0 / (sqrt(2.0 * PI) * sigma);\\n delta_gauss.y = exp(-0.5 / (sigma * sigma));\\n delta_gauss.z = delta_gauss.y * delta_gauss.y;\\n\\n vec4 avg = vec4(0.0, 0.0, 0.0, 0.0);\\n float sum = 0.0;\\n\\n vec4 pixel = texture_value(uv);\\n avg += pixel * delta_gauss.x;\\n sum += delta_gauss.x;\\n delta_gauss.xy *= delta_gauss.yz;\\n\\n for ( float i = 1.0; i <= side; i++)\\n {\\n for ( float s = -1.0; s <= 1.0; s += 2.0 )\\n {\\n vec2 pos = uv + s * i * direction_vector;\\n pixel = texture_value(pos);\\n avg += pixel * delta_gauss.x;\\n }\\n sum += 2.0 * delta_gauss.x;\\n delta_gauss.xy *= delta_gauss.yz;\\n }\\n\\n avg /= sum;\\n\\n return avg;\\n}\\n\\n\\nvoid main()\\n{\\n highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y);\\n\\n int actual_kernel_size = kernel_size == 0 ? int(0.5 + 6.0 * sigma) : kernel_size;\\n\\n const float multiplier = 0.25;\\n\\n if ( sigma == 0.0 )\\n {\\n FragColor = texture(texture_sampler, uv);\\n }\\n else if ( pass == 0 )\\n {\\n if ( direction != 3 )\\n FragColor = blur_pass(sigma * multiplier, actual_kernel_size, uv, true);\\n else\\n FragColor = texture(texture_sampler, uv);\\n }\\n else if ( pass == 1 )\\n {\\n if ( direction != 2 )\\n FragColor = blur_pass(sigma * multiplier, actual_kernel_size, uv, false);\\n else\\n FragColor = texture(texture_sampler, uv);\\n }\\n}') lottie_shader_44.add_pass(program_44_0, {\"pass\": [\"1i\", 0]}) lottie_shader_44.add_pass(program_44_0, {\"pass\": [\"1i\", 1]}) var lottie_player_44 = new PlaygroundPlayer( 44, 'playground_44_4', 'lottie_target_44', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 29, \"en\": 1, \"ef\": [{\"ty\": 0, \"v\": {\"a\": 0, \"k\": 25}}, {\"ty\": 0, \"v\": {\"k\": 0, \"a\": 0}}, {\"ty\": 4, \"v\": {\"k\": 0, \"a\": 0}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { let shader = lottie_shader_44; lottie.layers[0].ef[0].ef[0].v.k = data[\"Sigma\"]; lottie.layers[0].ef[0].ef[1].v.k = Number(data[\"Direction\"]); lottie.layers[0].ef[0].ef[2].v.k = Number(data[\"Wrap\"]); for ( let pass of [0, 1] ) { shader.set_uniform(pass, \"sigma\", \"1f\", data[\"Sigma\"]); shader.set_uniform(pass, \"direction\", \"1i\", data[\"Direction\"]); shader.set_uniform(pass, \"wrap\", \"1i\", data[\"Wrap\"]); } this.json_viewer_contents = lottie.layers[0].ef[0]; shader.render(); }, {} );","title":"Gaussian Blur"},{"location":"rendering/#drop-shadow-effect","text":"The effect below is split into multiple shaders: First it generates the shadow Then it has a 2 pass gaussian blur (simplified from the example above) Finally, it composites the original image on top of the blurred shadow Red 0 Green 0 Blue 0 Opacity 128 Angle 135 Distance 10 Blur 7 Show JSON #version 300 es #define PI 3.1415926538 uniform highp vec4 color; uniform mediump float angle; uniform mediump float distance; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; out highp vec4 FragColor; void main() { // Base pixel value highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y); highp vec4 pixel = texture(texture_sampler, uv); // Pixel value at the given offset mediump float radians = -angle * PI / 180.0 + PI / 2.0; highp vec2 shadow_uv = vec2( (gl_FragCoord.x - distance * cos(radians)) / canvas_size.x, 1.0 - (gl_FragCoord.y - distance * sin(radians)) / canvas_size.y ); highp vec4 shadow_pixel = texture(texture_sampler, shadow_uv); // Colorize shadow highp vec4 shadow_color; if ( shadow_uv.x >= 0.0 && shadow_uv.x <= 1.0 && shadow_uv.y >= 0.0 && shadow_uv.y <= 1.0 ) { shadow_color = color; shadow_color.a = 1.0; shadow_color *= shadow_pixel.a * color.a / 255.0; } // Apply shadow below the base pixel FragColor = shadow_color; //pixel * pixel.a + shadow_color * (1.0 - pixel.a); } #version 300 es #define PI 3.1415926538 precision highp float; uniform float sigma; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; uniform int pass; out vec4 FragColor; vec4 blur_pass(float sigma, int kernel_size, vec2 uv, bool horizontal) { float side = float(kernel_size / 2); vec2 direction_vector = horizontal ? vec2(1.0, 0.0) / canvas_size.x : vec2(0.0, 1.0) / canvas_size.y; vec3 delta_gauss; delta_gauss.x = 1.0 / (sqrt(2.0 * PI) * sigma); delta_gauss.y = exp(-0.5 / (sigma * sigma)); delta_gauss.z = delta_gauss.y * delta_gauss.y; vec4 avg = vec4(0.0, 0.0, 0.0, 0.0); float sum = 0.0; vec4 pixel = texture(texture_sampler, uv); avg += pixel * delta_gauss.x; sum += delta_gauss.x; delta_gauss.xy *= delta_gauss.yz; for ( float i = 1.0; i <= side; i++) { for ( float s = -1.0; s <= 1.0; s += 2.0 ) { vec2 pos = uv + s * i * direction_vector; pixel = texture(texture_sampler, pos); avg += pixel * delta_gauss.x; } sum += 2.0 * delta_gauss.x; delta_gauss.xy *= delta_gauss.yz; } avg /= sum; return avg; } void main() { highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y); int kernel_size = int(0.5 + 6.0 * sigma); const float multiplier = 0.25; if ( sigma == 0.0 ) FragColor = texture(texture_sampler, uv); else if ( pass == 1 ) FragColor = blur_pass(sigma * multiplier, kernel_size, uv, true); else if ( pass == 2 ) FragColor = blur_pass(sigma * multiplier, kernel_size, uv, false); } #version 300 es precision highp float; uniform sampler2D original; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; out vec4 FragColor; vec4 alpha_blend(vec4 top, vec4 bottom) { float comp_alpha = bottom.a * (1.0 - top.a); vec4 result; result.a = top.a + comp_alpha; result.rgb = (top.rgb * top.a + bottom.rgb * comp_alpha) / result.a; return result; } void main() { highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y); FragColor = alpha_blend( texture(original, uv), texture(texture_sampler, vec2(uv.x, 1.0 - uv.y)) ); } var lottie_shader_45 = new MultiPassShader(document.getElementById('lottie_target_45_canvas')); lottie_shader_45.add_pass_source('#version 300 es\\n#define PI 3.1415926538\\n\\nuniform highp vec4 color;\\nuniform mediump float angle;\\nuniform mediump float distance;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\n\\nout highp vec4 FragColor;\\n\\nvoid main()\\n{\\n // Base pixel value\\n highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y);\\n highp vec4 pixel = texture(texture_sampler, uv);\\n\\n // Pixel value at the given offset\\n mediump float radians = -angle * PI / 180.0 + PI / 2.0;\\n highp vec2 shadow_uv = vec2(\\n (gl_FragCoord.x - distance * cos(radians)) / canvas_size.x,\\n 1.0 - (gl_FragCoord.y - distance * sin(radians)) / canvas_size.y\\n );\\n highp vec4 shadow_pixel = texture(texture_sampler, shadow_uv);\\n\\n // Colorize shadow\\n highp vec4 shadow_color;\\n\\n if ( shadow_uv.x >= 0.0 && shadow_uv.x <= 1.0 && shadow_uv.y >= 0.0 && shadow_uv.y <= 1.0 )\\n {\\n shadow_color = color;\\n shadow_color.a = 1.0;\\n shadow_color *= shadow_pixel.a * color.a / 255.0;\\n }\\n\\n // Apply shadow below the base pixel\\n FragColor = shadow_color; //pixel * pixel.a + shadow_color * (1.0 - pixel.a);\\n}', {\"pass\": [\"1i\", 0]}) var program_45_1 = new ShaderProgram(lottie_shader_45.gl); program_45_1.set_fragment('#version 300 es\\n\\n#define PI 3.1415926538\\nprecision highp float;\\n\\nuniform float sigma;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\nuniform int pass;\\n\\nout vec4 FragColor;\\n\\nvec4 blur_pass(float sigma, int kernel_size, vec2 uv, bool horizontal)\\n{\\n float side = float(kernel_size / 2);\\n\\n vec2 direction_vector = horizontal ?\\n vec2(1.0, 0.0) / canvas_size.x :\\n vec2(0.0, 1.0) / canvas_size.y;\\n\\n vec3 delta_gauss;\\n delta_gauss.x = 1.0 / (sqrt(2.0 * PI) * sigma);\\n delta_gauss.y = exp(-0.5 / (sigma * sigma));\\n delta_gauss.z = delta_gauss.y * delta_gauss.y;\\n\\n vec4 avg = vec4(0.0, 0.0, 0.0, 0.0);\\n float sum = 0.0;\\n\\n vec4 pixel = texture(texture_sampler, uv);\\n avg += pixel * delta_gauss.x;\\n sum += delta_gauss.x;\\n delta_gauss.xy *= delta_gauss.yz;\\n\\n for ( float i = 1.0; i <= side; i++)\\n {\\n for ( float s = -1.0; s <= 1.0; s += 2.0 )\\n {\\n vec2 pos = uv + s * i * direction_vector;\\n pixel = texture(texture_sampler, pos);\\n avg += pixel * delta_gauss.x;\\n }\\n sum += 2.0 * delta_gauss.x;\\n delta_gauss.xy *= delta_gauss.yz;\\n }\\n\\n avg /= sum;\\n\\n return avg;\\n}\\n\\n\\nvoid main()\\n{\\n highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y);\\n\\n int kernel_size = int(0.5 + 6.0 * sigma);\\n\\n const float multiplier = 0.25;\\n\\n if ( sigma == 0.0 )\\n FragColor = texture(texture_sampler, uv);\\n else if ( pass == 1 )\\n FragColor = blur_pass(sigma * multiplier, kernel_size, uv, true);\\n else if ( pass == 2 )\\n FragColor = blur_pass(sigma * multiplier, kernel_size, uv, false);\\n}') lottie_shader_45.add_pass(program_45_1, {\"pass\": [\"1i\", 1]}) lottie_shader_45.add_pass(program_45_1, {\"pass\": [\"1i\", 2]}) lottie_shader_45.add_pass_source('#version 300 es\\n\\nprecision highp float;\\n\\nuniform sampler2D original;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\n\\nout vec4 FragColor;\\n\\nvec4 alpha_blend(vec4 top, vec4 bottom)\\n{\\n float comp_alpha = bottom.a * (1.0 - top.a);\\n vec4 result;\\n result.a = top.a + comp_alpha;\\n result.rgb = (top.rgb * top.a + bottom.rgb * comp_alpha) / result.a;\\n return result;\\n}\\n\\nvoid main()\\n{\\n highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y);\\n\\n FragColor = alpha_blend(\\n texture(original, uv),\\n texture(texture_sampler, vec2(uv.x, 1.0 - uv.y))\\n );\\n}', {\"pass\": [\"1i\", 3]}) var lottie_player_45 = new PlaygroundPlayer( 45, 'playground_45_8', 'lottie_target_45', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 25, \"ef\": [{\"ty\": 2, \"v\": {\"k\": [0, 0, 0, 1], \"a\": 0}}, {\"ty\": 0, \"v\": {\"k\": 128, \"a\": 0}}, {\"ty\": 1, \"v\": {\"k\": 135, \"a\": 0}}, {\"ty\": 0, \"v\": {\"k\": 10, \"a\": 0}}, {\"ty\": 0, \"v\": {\"k\": 7, \"a\": 0}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { let shader = lottie_shader_45; lottie.layers[0].ef[0].ef[0].v.k[0] = data[\"Red\"]; lottie.layers[0].ef[0].ef[0].v.k[1] = data[\"Green\"]; lottie.layers[0].ef[0].ef[0].v.k[2] = data[\"Blue\"]; lottie.layers[0].ef[0].ef[1].v.k = data[\"Opacity\"]; lottie.layers[0].ef[0].ef[2].v.k = data[\"Angle\"]; lottie.layers[0].ef[0].ef[3].v.k = data[\"Distance\"]; lottie.layers[0].ef[0].ef[4].v.k = data[\"Blur\"]; shader.set_uniform(0, \"color\", \"4fv\", [data[\"Red\"], data[\"Green\"], data[\"Blue\"], data[\"Opacity\"]]); shader.set_uniform(0, \"angle\", \"1f\", data[\"Angle\"]); // 0.77 is just to take into account the canvas is 394 instead of 512 shader.set_uniform(0, \"distance\", \"1f\", data[\"Distance\"] * 0.77); shader.set_uniform(1, \"sigma\", \"1f\", data[\"Blur\"]); shader.set_uniform(2, \"sigma\", \"1f\", data[\"Blur\"]); shader.texture(\"/lottie-docs/examples/blep.png\").set_uniform(shader.passes[3].program, \"original\");this.json_viewer_contents = lottie.layers[0].ef[0]; shader.render(); }, {} );","title":"Drop Shadow Effect"},{"location":"rendering/#pro-levels-effect","text":"Composite In Black 0 In White 1 Gamma 1 Out Black 0 Out White 1 Red In Black 0 In White 1 Gamma 1 Out Black 0 Out White 1 Green In Black 0 In White 1 Gamma 1 Out Black 0 Out White 1 Blue In Black 0 In White 1 Gamma 1 Out Black 0 Out White 1 Show JSON #version 100 precision highp float; uniform highp float composite_in_black; uniform highp float composite_in_white; uniform highp float composite_gamma; uniform highp float composite_out_black; uniform highp float composite_out_white; uniform highp float red_in_black; uniform highp float red_in_white; uniform highp float red_gamma; uniform highp float red_out_black; uniform highp float red_out_white; uniform highp float green_in_black; uniform highp float green_in_white; uniform highp float green_gamma; uniform highp float green_out_black; uniform highp float green_out_white; uniform highp float blue_in_black; uniform highp float blue_in_white; uniform highp float blue_gamma; uniform highp float blue_out_black; uniform highp float blue_out_white; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; float adjust_channel(float value, float in_black, float in_white, float gamma, float out_black, float out_white) { float in_delta = in_white - in_black; float out_delta = out_white - out_black; if ( in_delta == 0.0 ) return out_black; // Clamp to input range if ( value <= in_black && value <= in_white ) return out_black; if ( value >= in_black && value >= in_white ) return out_white; // Apply adjustment return out_black + out_delta * pow((value - in_black) / in_delta, 1.0 / gamma); } void main() { // Base pixel value highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y); highp vec4 pixel = texture2D(texture_sampler, uv); // First Pass: composite pixel.rgb = vec3( adjust_channel(pixel.r, composite_in_black, composite_in_white, composite_gamma, composite_out_black, composite_out_white), adjust_channel(pixel.g, composite_in_black, composite_in_white, composite_gamma, composite_out_black, composite_out_white), adjust_channel(pixel.b, composite_in_black, composite_in_white, composite_gamma, composite_out_black, composite_out_white) ); // Second Pass: individual Channels pixel.rgb = vec3( adjust_channel(pixel.r, red_in_black, red_in_white, red_gamma, red_out_black, red_out_white), adjust_channel(pixel.g, green_in_black, green_in_white, green_gamma, green_out_black, green_out_white), adjust_channel(pixel.b, blue_in_black, blue_in_white, blue_gamma, blue_out_black, blue_out_white) ); gl_FragColor.rgb = pixel.rgb * pixel.a; gl_FragColor.a = pixel.a; } var lottie_shader_46 = new SinglePassShader(document.getElementById('lottie_target_46_canvas')); lottie_shader_46.set_fragment('#version 100\\nprecision highp float;\\n\\nuniform highp float composite_in_black;\\nuniform highp float composite_in_white;\\nuniform highp float composite_gamma;\\nuniform highp float composite_out_black;\\nuniform highp float composite_out_white;\\n\\nuniform highp float red_in_black;\\nuniform highp float red_in_white;\\nuniform highp float red_gamma;\\nuniform highp float red_out_black;\\nuniform highp float red_out_white;\\n\\nuniform highp float green_in_black;\\nuniform highp float green_in_white;\\nuniform highp float green_gamma;\\nuniform highp float green_out_black;\\nuniform highp float green_out_white;\\n\\nuniform highp float blue_in_black;\\nuniform highp float blue_in_white;\\nuniform highp float blue_gamma;\\nuniform highp float blue_out_black;\\nuniform highp float blue_out_white;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\n\\n\\nfloat adjust_channel(float value, float in_black, float in_white, float gamma, float out_black, float out_white)\\n{\\n float in_delta = in_white - in_black;\\n float out_delta = out_white - out_black;\\n if ( in_delta == 0.0 )\\n return out_black;\\n\\n // Clamp to input range\\n if ( value <= in_black && value <= in_white )\\n return out_black;\\n\\n if ( value >= in_black && value >= in_white )\\n return out_white;\\n\\n // Apply adjustment\\n return out_black + out_delta * pow((value - in_black) / in_delta, 1.0 / gamma);\\n}\\n\\n\\nvoid main()\\n{\\n // Base pixel value\\n highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y);\\n highp vec4 pixel = texture2D(texture_sampler, uv);\\n\\n // First Pass: composite\\n pixel.rgb = vec3(\\n adjust_channel(pixel.r, composite_in_black, composite_in_white, composite_gamma, composite_out_black, composite_out_white),\\n adjust_channel(pixel.g, composite_in_black, composite_in_white, composite_gamma, composite_out_black, composite_out_white),\\n adjust_channel(pixel.b, composite_in_black, composite_in_white, composite_gamma, composite_out_black, composite_out_white)\\n );\\n\\n // Second Pass: individual Channels\\n pixel.rgb = vec3(\\n adjust_channel(pixel.r, red_in_black, red_in_white, red_gamma, red_out_black, red_out_white),\\n adjust_channel(pixel.g, green_in_black, green_in_white, green_gamma, green_out_black, green_out_white),\\n adjust_channel(pixel.b, blue_in_black, blue_in_white, blue_gamma, blue_out_black, blue_out_white)\\n );\\n\\n gl_FragColor.rgb = pixel.rgb * pixel.a;\\n gl_FragColor.a = pixel.a;\\n}') var lottie_player_46 = new PlaygroundPlayer( 46, 'playground_46_21', 'lottie_target_46', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 24, \"ef\": [{\"ty\": 7, \"v\": {\"nm\": \"00 Dropdown\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"01\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"02\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_outwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"08\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"09 slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"r_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"r_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"r_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"r_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"r_outwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"15 slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"16 slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"g_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"g_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"g_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"g_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"g_outwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"22\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"23\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"b_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"b_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"b_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"b_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"b_outwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"29\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"a_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"a_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"a_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"a_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"a_outwhite slider\", \"a\": 0, \"k\": 1}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { let shader = lottie_shader_46; lottie.layers[0].ef[0].ef[3].v.k = data[\"Composite In Black\"]; lottie.layers[0].ef[0].ef[4].v.k = data[\"Composite In White\"]; lottie.layers[0].ef[0].ef[5].v.k = data[\"Composite Gamma\"]; lottie.layers[0].ef[0].ef[6].v.k = data[\"Composite Out Black\"]; lottie.layers[0].ef[0].ef[7].v.k = data[\"Composite Out White\"]; lottie.layers[0].ef[0].ef[10].v.k = data[\"Red In Black\"]; lottie.layers[0].ef[0].ef[11].v.k = data[\"Red In White\"]; lottie.layers[0].ef[0].ef[12].v.k = data[\"Red Gamma\"]; lottie.layers[0].ef[0].ef[13].v.k = data[\"Red Out Black\"]; lottie.layers[0].ef[0].ef[14].v.k = data[\"Red Out White\"]; lottie.layers[0].ef[0].ef[17].v.k = data[\"Green In Black\"]; lottie.layers[0].ef[0].ef[18].v.k = data[\"Green In White\"]; lottie.layers[0].ef[0].ef[19].v.k = data[\"Green Gamma\"]; lottie.layers[0].ef[0].ef[20].v.k = data[\"Green Out Black\"]; lottie.layers[0].ef[0].ef[21].v.k = data[\"Green Out White\"]; lottie.layers[0].ef[0].ef[24].v.k = data[\"Blue In Black\"]; lottie.layers[0].ef[0].ef[25].v.k = data[\"Blue In White\"]; lottie.layers[0].ef[0].ef[26].v.k = data[\"Blue Gamma\"]; lottie.layers[0].ef[0].ef[27].v.k = data[\"Blue Out Black\"]; lottie.layers[0].ef[0].ef[28].v.k = data[\"Blue Out White\"]; shader.set_uniform(\"composite_in_black\", \"1f\", data[\"Composite In Black\"]); shader.set_uniform(\"composite_in_white\", \"1f\", data[\"Composite In White\"]); shader.set_uniform(\"composite_gamma\", \"1f\", data[\"Composite Gamma\"]); shader.set_uniform(\"composite_out_black\", \"1f\", data[\"Composite Out Black\"]); shader.set_uniform(\"composite_out_white\", \"1f\", data[\"Composite Out White\"]); shader.set_uniform(\"red_in_black\", \"1f\", data[\"Red In Black\"]); shader.set_uniform(\"red_in_white\", \"1f\", data[\"Red In White\"]); shader.set_uniform(\"red_gamma\", \"1f\", data[\"Red Gamma\"]); shader.set_uniform(\"red_out_black\", \"1f\", data[\"Red Out Black\"]); shader.set_uniform(\"red_out_white\", \"1f\", data[\"Red Out White\"]); shader.set_uniform(\"green_in_black\", \"1f\", data[\"Green In Black\"]); shader.set_uniform(\"green_in_white\", \"1f\", data[\"Green In White\"]); shader.set_uniform(\"green_gamma\", \"1f\", data[\"Green Gamma\"]); shader.set_uniform(\"green_out_black\", \"1f\", data[\"Green Out Black\"]); shader.set_uniform(\"green_out_white\", \"1f\", data[\"Green Out White\"]); shader.set_uniform(\"blue_in_black\", \"1f\", data[\"Blue In Black\"]); shader.set_uniform(\"blue_in_white\", \"1f\", data[\"Blue In White\"]); shader.set_uniform(\"blue_gamma\", \"1f\", data[\"Blue Gamma\"]); shader.set_uniform(\"blue_out_black\", \"1f\", data[\"Blue Out Black\"]); shader.set_uniform(\"blue_out_white\", \"1f\", data[\"Blue Out White\"]);this.json_viewer_contents = lottie.layers[0].ef[0]; shader.render(); }, {} );","title":"Pro Levels Effect"},{"location":"rendering/#matte3","text":"Channel Red Green Blue Alpha Luma Hue Lightness Saturation Full Off Invert Stretch To Fit Show Mask Premultiply Mask Show JSON #version 100 precision highp float; uniform int channel; uniform int invert; uniform int premultiply_mask; uniform int show_mask; uniform sampler2D mask_layer; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; highp vec3 hsl(vec4 c) { float maxc = max(c.r, max(c.g, c.b)); float minc = min(c.r, min(c.g, c.b)); float h = 0.0; float s = 0.0; float l = (maxc + minc) / 2.0; if ( maxc != minc) { float d = maxc - minc; s = l > 0.5 ? d / (2.0 - d) : d / (maxc + minc); if ( maxc == c.r ) h = (c.g - c.b) / d + (c.g < c.b ? 6.0 : 0.0); else if ( maxc == c.g ) h = (c.b - c.r) / d + 2.0; else if ( maxc == c.b ) h = (c.r - c.g) / d + 4.0; h /= 6.0; } return vec3(h, s, l); } highp float opacity(vec4 pixel, int channel, int invert, int premultiply) { if ( premultiply == 1 ) pixel *= pixel.a; highp float opacity; if ( channel == 1 ) opacity = pixel.r; else if ( channel == 2 ) opacity = pixel.g; else if ( channel == 3 ) opacity = pixel.b; else if ( channel == 4 ) opacity = pixel.a; else if ( channel == 5 ) opacity = sqrt(pixel.r * pixel.r * 0.299 + pixel.g * pixel.g * 0.587 + pixel.b * pixel.b * 0.114); else if ( channel == 6 ) opacity = hsl(pixel).x; else if ( channel == 7 ) opacity = hsl(pixel).z; else if ( channel == 8 ) opacity = hsl(pixel).y; else if ( channel == 9 ) opacity = 1.0; else if ( channel == 10 ) opacity = 0.0; return invert == 1 ? 1.0 - opacity : opacity; } vec4 alpha_blend(vec4 top, vec4 bottom) { float comp_alpha = bottom.a * (1.0 - top.a); vec4 result; result.a = top.a + comp_alpha; result.rgb = (top.rgb * top.a + bottom.rgb * comp_alpha) / result.a; return result; } void main() { // Base pixel value highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y); highp vec4 pixel = texture2D(texture_sampler, uv); highp vec4 mask = texture2D(mask_layer, uv); gl_FragColor.a = pixel.a * opacity(mask, channel, invert, premultiply_mask); gl_FragColor.rgb = pixel.rgb * gl_FragColor.a; if ( show_mask == 1 ) gl_FragColor = alpha_blend(gl_FragColor, mask); } var lottie_shader_47 = new SinglePassShader(document.getElementById('lottie_target_47_canvas')); lottie_shader_47.set_fragment('#version 100\\nprecision highp float;\\n\\nuniform int channel;\\nuniform int invert;\\nuniform int premultiply_mask;\\nuniform int show_mask;\\nuniform sampler2D mask_layer;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\n\\nhighp vec3 hsl(vec4 c)\\n{\\n float maxc = max(c.r, max(c.g, c.b));\\n float minc = min(c.r, min(c.g, c.b));\\n float h = 0.0;\\n float s = 0.0;\\n float l = (maxc + minc) / 2.0;\\n\\n if ( maxc != minc)\\n {\\n float d = maxc - minc;\\n s = l > 0.5 ? d / (2.0 - d) : d / (maxc + minc);\\n if ( maxc == c.r )\\n h = (c.g - c.b) / d + (c.g < c.b ? 6.0 : 0.0);\\n else if ( maxc == c.g )\\n h = (c.b - c.r) / d + 2.0;\\n else if ( maxc == c.b )\\n h = (c.r - c.g) / d + 4.0;\\n\\n h /= 6.0;\\n }\\n\\n return vec3(h, s, l);\\n}\\n\\nhighp float opacity(vec4 pixel, int channel, int invert, int premultiply)\\n{\\n if ( premultiply == 1 )\\n pixel *= pixel.a;\\n\\n highp float opacity;\\n\\n if ( channel == 1 )\\n opacity = pixel.r;\\n else if ( channel == 2 )\\n opacity = pixel.g;\\n else if ( channel == 3 )\\n opacity = pixel.b;\\n else if ( channel == 4 )\\n opacity = pixel.a;\\n else if ( channel == 5 )\\n opacity = sqrt(pixel.r * pixel.r * 0.299 + pixel.g * pixel.g * 0.587 + pixel.b * pixel.b * 0.114);\\n else if ( channel == 6 )\\n opacity = hsl(pixel).x;\\n else if ( channel == 7 )\\n opacity = hsl(pixel).z;\\n else if ( channel == 8 )\\n opacity = hsl(pixel).y;\\n else if ( channel == 9 )\\n opacity = 1.0;\\n else if ( channel == 10 )\\n opacity = 0.0;\\n\\n\\n return invert == 1 ? 1.0 - opacity : opacity;\\n}\\n\\nvec4 alpha_blend(vec4 top, vec4 bottom)\\n{\\n float comp_alpha = bottom.a * (1.0 - top.a);\\n vec4 result;\\n result.a = top.a + comp_alpha;\\n result.rgb = (top.rgb * top.a + bottom.rgb * comp_alpha) / result.a;\\n return result;\\n}\\n\\nvoid main()\\n{\\n // Base pixel value\\n highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y);\\n highp vec4 pixel = texture2D(texture_sampler, uv);\\n\\n highp vec4 mask = texture2D(mask_layer, uv);\\n\\n\\n gl_FragColor.a = pixel.a * opacity(mask, channel, invert, premultiply_mask);\\n gl_FragColor.rgb = pixel.rgb * gl_FragColor.a;\\n\\n if ( show_mask == 1 )\\n gl_FragColor = alpha_blend(gl_FragColor, mask);\\n}') var lottie_player_47 = new PlaygroundPlayer( 47, 'playground_47_6', 'lottie_target_47', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}, {\"id\": \"thumbs-up\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/thumbs-up.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {}, \"ip\": 0, \"op\": 60, \"st\": 0, \"ind\": 0, \"ef\": [{\"ty\": 28, \"nm\": \"Set Matte\", \"np\": 8, \"mn\": \"ADBE Set Matte3\", \"ix\": 1, \"en\": 1, \"ef\": [{\"ty\": 10, \"nm\": \"Take Matte From Layer\", \"mn\": \"ADBE Set Matte3-0001\", \"ix\": 1, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 1}}, {\"ty\": 7, \"nm\": \"Use For Matte\", \"mn\": \"ADBE Set Matte3-0002\", \"ix\": 2, \"v\": {\"a\": 0, \"k\": 4, \"ix\": 2}}, {\"ty\": 7, \"nm\": \"Invert Matte\", \"mn\": \"ADBE Set Matte3-0003\", \"ix\": 3, \"v\": {\"a\": 0, \"k\": 0, \"ix\": 3}}, {\"ty\": 7, \"nm\": \"If Layer Sizes Differ\", \"mn\": \"ADBE Set Matte3-0004\", \"ix\": 4, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 4}}, {\"ty\": 7, \"nm\": \"Composite Matte with Original\", \"mn\": \"ADBE Set Matte3-0005\", \"ix\": 5, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 5}}, {\"ty\": 7, \"nm\": \"Premultiply Matte Layer\", \"mn\": \"ADBE Set Matte3-0006\", \"ix\": 6, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 6}}]}], \"refId\": \"blep\"}, {\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {}, \"ip\": 0, \"op\": 60, \"st\": 0, \"ind\": 1, \"refId\": \"thumbs-up\"}]}, function (lottie, data) { let shader = lottie_shader_47; lottie.layers[0].ef[0].ef[1].v.k = Number(data[\"Channel\"]); lottie.layers[0].ef[0].ef[2].v.k = Number(data[\"Invert\"]); lottie.layers[0].ef[0].ef[3].v.k = Number(data[\"Stretch To Fit\"]); lottie.layers[0].ef[0].ef[4].v.k = Number(data[\"Show Mask\"]); lottie.layers[0].ef[0].ef[5].v.k = Number(data[\"Premultiply Mask\"]); shader.set_uniform(\"channel\", \"1i\", Number(data[\"Channel\"])); shader.set_uniform(\"invert\", \"1i\", Number(data[\"Invert\"])); shader.set_uniform(\"show_mask\", \"1i\", Number(data[\"Show Mask\"])); shader.set_uniform(\"premultiply_mask\", \"1i\", Number(data[\"Premultiply Mask\"])); shader.texture(\"/lottie-docs/examples/thumbs-up.png\").set_uniform(shader.program, \"mask_layer\"); this.json_viewer_contents = lottie.layers[0].ef[0]; shader.render(); }, {} );","title":"Matte3"},{"location":"rendering/#bulge","text":"Center X 286 Center Y 277 Radius X 197 Radius Y 179 Height 1.9 Show JSON #version 100 precision highp float; uniform vec2 center; uniform vec2 radius; uniform float height; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; vec2 normalize_uv(vec2 coord) { return vec2(coord.x / canvas_size.x, coord.y / canvas_size.y); } vec2 exponential_displacement(vec2 uv, float magnitude) { return uv * pow(dot(uv, uv), magnitude) - uv; } vec2 spherical_displacement(vec2 uv, float magnitude) { float radius = (1.0 + magnitude) / (2.0 * sqrt(magnitude)); float arc_ratio = asin(length(uv) / radius) / asin(1.0 / radius); return normalize(uv) * arc_ratio - uv; } vec2 displace(vec2 owo) { float t = dot(owo, owo); if (t >= 1.0) return owo; float magnitude = abs(height); // We modify the magniture to more closely match AE magnitude = (2.0/(1.0+exp(-3.0*magnitude))-1.0) * (0.23 * magnitude + 0.14); // If the above is too expensive, you can use this instead: // magnitude = magnitude * 0.275; // Both of the above were derived by interpolating sample points float sign = height > 0.0 ? 1.0 : -1.0; vec2 displacement = exponential_displacement(owo, magnitude) + spherical_displacement(owo, magnitude) ; return owo + displacement * magnitude * sign; } void main() { highp vec2 uv = normalize_uv(gl_FragCoord.xy); vec2 norm_center = normalize_uv(center); vec2 norm_radius = normalize_uv(radius); // forward transform uv = (uv - norm_center) / norm_radius; //displace uv = displace(uv); // backward transform uv = uv * norm_radius + norm_center; gl_FragColor = texture2D(texture_sampler, uv); } var lottie_shader_48 = new SinglePassShader(document.getElementById('lottie_target_48_canvas')); lottie_shader_48.set_fragment('#version 100\\n\\nprecision highp float;\\n\\nuniform vec2 center;\\nuniform vec2 radius;\\nuniform float height;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\n\\nvec2 normalize_uv(vec2 coord)\\n{\\n return vec2(coord.x / canvas_size.x, coord.y / canvas_size.y);\\n}\\n\\nvec2 exponential_displacement(vec2 uv, float magnitude)\\n{\\n return uv * pow(dot(uv, uv), magnitude) - uv;\\n}\\n\\n\\nvec2 spherical_displacement(vec2 uv, float magnitude)\\n{\\n float radius = (1.0 + magnitude) / (2.0 * sqrt(magnitude));\\n\\n\\n float arc_ratio = asin(length(uv) / radius) / asin(1.0 / radius);\\n return normalize(uv) * arc_ratio - uv;\\n}\\n\\nvec2 displace(vec2 owo)\\n{\\n float t = dot(owo, owo);\\n if (t >= 1.0)\\n return owo;\\n\\n float magnitude = abs(height);\\n // We modify the magniture to more closely match AE\\n magnitude = (2.0/(1.0+exp(-3.0*magnitude))-1.0) * (0.23 * magnitude + 0.14);\\n // If the above is too expensive, you can use this instead:\\n // magnitude = magnitude * 0.275;\\n // Both of the above were derived by interpolating sample points\\n\\n float sign = height > 0.0 ? 1.0 : -1.0;\\n vec2 displacement =\\n exponential_displacement(owo, magnitude) +\\n spherical_displacement(owo, magnitude)\\n ;\\n return owo + displacement * magnitude * sign;\\n\\n}\\n\\nvoid main()\\n{\\n highp vec2 uv = normalize_uv(gl_FragCoord.xy);\\n vec2 norm_center = normalize_uv(center);\\n vec2 norm_radius = normalize_uv(radius);\\n\\n // forward transform\\n uv = (uv - norm_center) / norm_radius;\\n //displace\\n uv = displace(uv);\\n // backward transform\\n uv = uv * norm_radius + norm_center;\\n\\n gl_FragColor = texture2D(texture_sampler, uv);\\n}') var lottie_player_48 = new PlaygroundPlayer( 48, 'playground_48_6', 'lottie_target_48', {\"v\": \"5.9.0\", \"fr\": 60, \"ip\": 0, \"op\": 1800, \"w\": 512, \"h\": 512, \"nm\": \"Comp 1\", \"ddd\": 0, \"assets\": [{\"id\": \"image_0\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ind\": 1, \"ty\": 2, \"nm\": \"blep.png\", \"cl\": \"png\", \"refId\": \"image_0\", \"sr\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100, \"ix\": 11}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 10}, \"p\": {\"a\": 0, \"k\": [256, 256, 0], \"ix\": 2, \"l\": 2}, \"a\": {\"a\": 0, \"k\": [256, 256, 0], \"ix\": 1, \"l\": 2}, \"s\": {\"a\": 0, \"k\": [100, 100, 100], \"ix\": 6, \"l\": 2}}, \"ao\": 0, \"ef\": [{\"ty\": 5, \"nm\": \"Bulge\", \"np\": 9, \"mn\": \"ADBE Bulge\", \"ix\": 1, \"en\": 1, \"ef\": [{\"ty\": 0, \"nm\": \"Horizontal Radius\", \"mn\": \"ADBE Bulge-0001\", \"ix\": 1, \"v\": {\"a\": 0, \"k\": 197, \"ix\": 1}}, {\"ty\": 0, \"nm\": \"Vertical Radius\", \"mn\": \"ADBE Bulge-0002\", \"ix\": 2, \"v\": {\"a\": 0, \"k\": 179, \"ix\": 2}}, {\"ty\": 3, \"nm\": \"Bulge Center\", \"mn\": \"ADBE Bulge-0003\", \"ix\": 3, \"v\": {\"a\": 0, \"k\": [286, 277], \"ix\": 3}}, {\"ty\": 0, \"nm\": \"Bulge Height\", \"mn\": \"ADBE Bulge-0004\", \"ix\": 4, \"v\": {\"a\": 0, \"k\": 1.85, \"ix\": 4}}, {\"ty\": 0, \"nm\": \"Taper Radius\", \"mn\": \"ADBE Bulge-0005\", \"ix\": 5, \"v\": {\"a\": 0, \"k\": 0, \"ix\": 5}}, {\"ty\": 7, \"nm\": \"Antialiasing (Best Qual Only)\", \"mn\": \"ADBE Bulge-0006\", \"ix\": 6, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 6}}, {\"ty\": 7, \"nm\": \"Pinning\", \"mn\": \"ADBE Bulge-0007\", \"ix\": 7, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 7}}]}], \"ip\": 0, \"op\": 1800, \"st\": 0, \"bm\": 0}], \"markers\": []}, function (lottie, data) { let shader = lottie_shader_48; lottie.layers[0].ef[0].ef[0].v.k = data[\"Radius X\"]; lottie.layers[0].ef[0].ef[1].v.k = data[\"Radius Y\"]; lottie.layers[0].ef[0].ef[2].v.k = [data[\"Center X\"], data[\"Center Y\"]]; lottie.layers[0].ef[0].ef[3].v.k = data[\"Height\"]; shader.set_uniform(\"center\", \"2fv\", [data[\"Center X\"] * 0.77, data[\"Center Y\"] * 0.77]); shader.set_uniform(\"radius\", \"2fv\", [data[\"Radius X\"] * 0.77, data[\"Radius Y\"] * 0.77]); shader.set_uniform(\"height\", \"1f\", data[\"Height\"]); this.json_viewer_contents = lottie.layers[0].ef[0]; shader.render(); }, {} );","title":"Bulge"},{"location":"rendering/#wave-warp","text":"This effect is animated by default, so it has a \"time\" slider (in seconds). Shape Sine Square Triangle Sawtooth Circle Semicircle Uncircle Noise Smooth noise Amplitude 10 Wavelength 40 Direction 90 Phase 0 Speed 1 Time 0 Show JSON #version 100 #define PI 3.1415926538 #define TAU 6.283185307 precision highp float; uniform int shape; uniform float amplitude; uniform float wavelength; uniform float angle; uniform float speed; uniform float phase; uniform float time; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; vec2 normalize_uv(vec2 coord) { return vec2(coord.x / canvas_size.x, coord.y / canvas_size.y); } float clamp_angle(float angle) { return mod(angle, TAU); } vec2 project(vec2 a , vec2 b) { return dot(a, b) / dot(b, b) * b; } float semicircle(float x) { return sqrt(1.0 - pow(clamp_angle(x) / PI - 1.0, 2.0)); } // Adapted from http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/ highp float noise(float x) { highp float a = 12.9898; highp float b = 78.233; highp float c = 43758.5453; highp float dt = x * a; highp float sn = mod(dt, PI); return fract(sin(sn) * c) * 2.0 - 1.0; } // Interpolate between two random points float smooth_noise(float x) { float x_fract = fract(x); float x_int = x - x_fract; float n1 = noise(x_int); float n2 = noise(x_int + 1.0); return (n1 * (1.0 - x_fract) + n2 * x_fract); } vec2 displace(vec2 uv) { float rad = angle / 180.0 * PI; vec2 normal = vec2(cos(rad), sin(rad)); rad -= PI /2.0; vec2 direction = vec2(cos(rad), sin(rad)); float x = length(project(uv, direction)); x = x / wavelength * PI - time * speed * TAU + phase / 180.0 * PI; float y; if ( shape == 1 ) // sine y = sin(x); else if ( shape == 2 ) // square y = clamp_angle(x) < PI ? 1.0 : -1.0; else if ( shape == 3 ) // triangle y = 1.0 - abs(clamp_angle(x) - PI) / PI * 2.0; else if ( shape == 4 ) // sawtooth y = 1.0 - clamp_angle(x) / PI; else if ( shape == 5 ) // circle y = sign(clamp_angle(x) - PI) * semicircle(2.0 * x); else if ( shape == 6 ) // semi circle y = 2.0 * semicircle(x) - 1.0; else if ( shape == 7 ) // uncircle y = sign(clamp_angle(-x) - PI) * (semicircle(2.0 * x) - 1.0); else if ( shape == 8 ) // noise y = noise(x); else if ( shape == 9 ) // smooth noise y = smooth_noise(x * 4.0) ; return uv + y * normal * amplitude; } void main() { vec2 uv = displace(gl_FragCoord.xy); gl_FragColor = texture2D(texture_sampler, normalize_uv(uv)); } var lottie_shader_49 = new SinglePassShader(document.getElementById('lottie_target_49_canvas')); lottie_shader_49.set_fragment('#version 100\\n\\n#define PI 3.1415926538\\n#define TAU 6.283185307\\n\\nprecision highp float;\\n\\nuniform int shape;\\nuniform float amplitude;\\nuniform float wavelength;\\nuniform float angle;\\nuniform float speed;\\nuniform float phase;\\nuniform float time;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\n\\n\\nvec2 normalize_uv(vec2 coord)\\n{\\n return vec2(coord.x / canvas_size.x, coord.y / canvas_size.y);\\n}\\n\\nfloat clamp_angle(float angle)\\n{\\n return mod(angle, TAU);\\n}\\n\\nvec2 project(vec2 a , vec2 b)\\n{\\n return dot(a, b) / dot(b, b) * b;\\n}\\n\\nfloat semicircle(float x)\\n{\\n return sqrt(1.0 - pow(clamp_angle(x) / PI - 1.0, 2.0));\\n}\\n\\n// Adapted from http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\\nhighp float noise(float x)\\n{\\n highp float a = 12.9898;\\n highp float b = 78.233;\\n highp float c = 43758.5453;\\n highp float dt = x * a;\\n highp float sn = mod(dt, PI);\\n return fract(sin(sn) * c) * 2.0 - 1.0;\\n}\\n\\n// Interpolate between two random points\\nfloat smooth_noise(float x)\\n{\\n float x_fract = fract(x);\\n float x_int = x - x_fract;\\n float n1 = noise(x_int);\\n float n2 = noise(x_int + 1.0);\\n return (n1 * (1.0 - x_fract) + n2 * x_fract);\\n}\\n\\nvec2 displace(vec2 uv)\\n{\\n float rad = angle / 180.0 * PI;\\n vec2 normal = vec2(cos(rad), sin(rad));\\n rad -= PI /2.0;\\n vec2 direction = vec2(cos(rad), sin(rad));\\n float x = length(project(uv, direction));\\n\\n x = x / wavelength * PI - time * speed * TAU + phase / 180.0 * PI;\\n\\n\\n float y;\\n\\n if ( shape == 1 ) // sine\\n y = sin(x);\\n else if ( shape == 2 ) // square\\n y = clamp_angle(x) < PI ? 1.0 : -1.0;\\n else if ( shape == 3 ) // triangle\\n y = 1.0 - abs(clamp_angle(x) - PI) / PI * 2.0;\\n else if ( shape == 4 ) // sawtooth\\n y = 1.0 - clamp_angle(x) / PI;\\n else if ( shape == 5 ) // circle\\n y = sign(clamp_angle(x) - PI) * semicircle(2.0 * x);\\n else if ( shape == 6 ) // semi circle\\n y = 2.0 * semicircle(x) - 1.0;\\n else if ( shape == 7 ) // uncircle\\n y = sign(clamp_angle(-x) - PI) * (semicircle(2.0 * x) - 1.0);\\n else if ( shape == 8 ) // noise\\n y = noise(x);\\n else if ( shape == 9 ) // smooth noise\\n y = smooth_noise(x * 4.0) ;\\n\\n return uv + y * normal * amplitude;\\n\\n}\\n\\nvoid main()\\n{\\n vec2 uv = displace(gl_FragCoord.xy);\\n gl_FragColor = texture2D(texture_sampler, normalize_uv(uv));\\n}') var lottie_player_49 = new PlaygroundPlayer( 49, 'playground_49_8', 'lottie_target_49', {\"v\": \"5.9.0\", \"fr\": 60, \"ip\": 0, \"op\": 1800, \"w\": 512, \"h\": 512, \"nm\": \"Comp 1\", \"ddd\": 0, \"assets\": [{\"id\": \"image_0\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ind\": 1, \"ty\": 2, \"nm\": \"blep.png\", \"cl\": \"png\", \"refId\": \"image_0\", \"sr\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100, \"ix\": 11}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 10}, \"p\": {\"a\": 0, \"k\": [256, 256, 0], \"ix\": 2, \"l\": 2}, \"a\": {\"a\": 0, \"k\": [256, 256, 0], \"ix\": 1, \"l\": 2}, \"s\": {\"a\": 0, \"k\": [100, 100, 100], \"ix\": 6, \"l\": 2}}, \"ao\": 0, \"ef\": [{\"ty\": 5, \"nm\": \"Wave Warp\", \"np\": 10, \"mn\": \"ADBE Wave Warp\", \"ix\": 1, \"en\": 1, \"ef\": [{\"ty\": 7, \"nm\": \"Wave Type\", \"mn\": \"ADBE Wave Warp-0001\", \"ix\": 1, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 1}}, {\"ty\": 0, \"nm\": \"Wave Height\", \"mn\": \"ADBE Wave Warp-0002\", \"ix\": 2, \"v\": {\"a\": 0, \"k\": 10, \"ix\": 2}}, {\"ty\": 0, \"nm\": \"Wave Width\", \"mn\": \"ADBE Wave Warp-0003\", \"ix\": 3, \"v\": {\"a\": 0, \"k\": 64, \"ix\": 3}}, {\"ty\": 0, \"nm\": \"Direction\", \"mn\": \"ADBE Wave Warp-0004\", \"ix\": 4, \"v\": {\"a\": 0, \"k\": 90, \"ix\": 4}}, {\"ty\": 7, \"nm\": \"Wave Speed\", \"mn\": \"ADBE Wave Warp-0005\", \"ix\": 5, \"v\": {\"a\": 0, \"k\": 2, \"ix\": 5}}, {\"ty\": 7, \"nm\": \"Pinning\", \"mn\": \"ADBE Wave Warp-0006\", \"ix\": 6, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 6}}, {\"ty\": 0, \"nm\": \"Phase\", \"mn\": \"ADBE Wave Warp-0007\", \"ix\": 7, \"v\": {\"a\": 0, \"k\": 0, \"ix\": 7}}, {\"ty\": 7, \"nm\": \"Antialiasing (Best Quality)\", \"mn\": \"ADBE Wave Warp-0008\", \"ix\": 8, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 8}}]}], \"ip\": 0, \"op\": 1800, \"st\": 0, \"bm\": 0}], \"markers\": []}, function (lottie, data) { let shader = lottie_shader_49; lottie.layers[0].ef[0].ef[0].v.k = Number(data[\"Shape\"]); lottie.layers[0].ef[0].ef[1].v.k = data[\"Amplitude\"]; lottie.layers[0].ef[0].ef[2].v.k = data[\"Wavelength\"]; lottie.layers[0].ef[0].ef[3].v.k = data[\"Direction\"]; lottie.layers[0].ef[0].ef[5].v.k = data[\"Speed\"]; // 5 \"pinning\" not implemented lottie.layers[0].ef[0].ef[6].v.k = data[\"Phase\"]; // & \"antialiasing\" unused shader.set_uniform(\"shape\", \"1i\", Number(data[\"Shape\"])); shader.set_uniform(\"amplitude\", \"1f\", data[\"Amplitude\"]); shader.set_uniform(\"wavelength\", \"1f\", data[\"Wavelength\"]); shader.set_uniform(\"angle\", \"1f\", data[\"Direction\"]); shader.set_uniform(\"phase\", \"1f\", data[\"Phase\"]); shader.set_uniform(\"speed\", \"1f\", data[\"Speed\"]); shader.set_uniform(\"time\", \"1f\", data[\"Time\"]); this.json_viewer_contents = lottie.layers[0].ef[0]; shader.render(); }, {} );","title":"Wave Warp"},{"location":"schema/","text":"JSON Schema This page shows a formatted version of the JSON schema, you can click on highlighted objects to get a link to that section of the schema. You can also click on $ref values to jump to the relevant section. If you want you can also view the raw schema file . { \"$schema\" : \"https://json-schema.org/draft/2020-12/schema\" , \"$id\" : \"https://lottiefiles.github.io/lottie-docs/schema/lottie.schema.json\" , \"type\" : \"object\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/animation/animation\" } ], \"$defs\" : { \"animated-properties\" : { \"value\" : { \"type\" : \"object\" , \"title\" : \"Value\" , \"description\" : \"An animatable property that holds a float\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/animated-properties/animated-property\" }, { \"if\" : { \"properties\" : { \"a\" : { \"const\" : 0 } } }, \"then\" : { \"properties\" : { \"k\" : { \"title\" : \"Static value\" , \"type\" : \"number\" } } } } ] }, \"keyframe-bezier-handle\" : { \"type\" : \"object\" , \"title\" : \"Keyframe Bezier Handle\" , \"description\" : \"Bezier handle for keyframe interpolation\" , \"properties\" : { \"x\" : { \"title\" : \"X\" , \"description\" : \"Time component:\\n0 means start time of the keyframe,\\n1 means time of the next keyframe.\" , \"oneOf\" : [ { \"type\" : \"array\" , \"items\" : { \"type\" : \"number\" , \"default\" : 0 , \"minimum\" : 0 , \"maximum\" : 1 }, \"minItems\" : 1 }, { \"type\" : \"number\" , \"default\" : 0 , \"minimum\" : 0 , \"maximum\" : 1 } ] }, \"y\" : { \"title\" : \"Y\" , \"description\" : \"Value interpolation component:\\n0 means start value of the keyframe,\\n1 means value at the next keyframe.\" , \"oneOf\" : [ { \"type\" : \"array\" , \"items\" : { \"type\" : \"number\" , \"default\" : 0 , \"minimum\" : 0 , \"maximum\" : 1 }, \"minItems\" : 1 }, { \"type\" : \"number\" , \"default\" : 0 , \"minimum\" : 0 , \"maximum\" : 1 } ] } }, \"required\" : [ \"x\" , \"y\" ] }, \"position\" : { \"type\" : \"object\" , \"title\" : \"Position Property\" , \"description\" : \"An animatable property to represent a position in space\" , \"allOf\" : [ { \"properties\" : { \"ix\" : { \"title\" : \"Property Index\" , \"type\" : \"integer\" }, \"a\" : { \"title\" : \"Animated\" , \"description\" : \"Whether the property is animated\" , \"$ref\" : \"#/$defs/helpers/int-boolean\" , \"default\" : 0 }, \"x\" : { \"title\" : \"Expression\" , \"type\" : \"string\" }, \"l\" : { \"title\" : \"Length\" , \"description\" : \"Number of components in the value arrays.\\nIf present values will be truncated or expanded to match this length when accessed from expressions.\" , \"type\" : \"integer\" } } }, { \"if\" : { \"properties\" : { \"a\" : { \"const\" : 1 } } }, \"then\" : { \"properties\" : { \"k\" : { \"type\" : \"array\" , \"title\" : \"Animated Value\" , \"description\" : \"Array of keyframes\" , \"items\" : { \"$ref\" : \"#/$defs/animated-properties/position-keyframe\" } } } }, \"else\" : { \"properties\" : { \"k\" : { \"title\" : \"Static Value\" , \"type\" : \"array\" , \"items\" : { \"type\" : \"number\" } } } } } ], \"required\" : [ \"k\" ] }, \"animated-property\" : { \"type\" : \"object\" , \"title\" : \"Animated Property\" , \"description\" : \"An animatable property that holds an array of numbers\" , \"allOf\" : [ { \"properties\" : { \"ix\" : { \"title\" : \"Property Index\" , \"type\" : \"integer\" }, \"a\" : { \"title\" : \"Animated\" , \"description\" : \"Whether the property is animated\" , \"$ref\" : \"#/$defs/helpers/int-boolean\" , \"default\" : 0 }, \"x\" : { \"title\" : \"Expression\" , \"type\" : \"string\" }, \"sid\" : { \"title\" : \"Slot ID\" , \"description\" : \"One of the ID in the file's slots\" , \"type\" : \"string\" } } }, { \"if\" : { \"properties\" : { \"a\" : { \"const\" : 1 } } }, \"then\" : { \"properties\" : { \"k\" : { \"type\" : \"array\" , \"title\" : \"Animated Value\" , \"description\" : \"Array of keyframes\" , \"items\" : { \"$ref\" : \"#/$defs/animated-properties/keyframe\" } } } } } ], \"required\" : [ \"k\" ] }, \"shape-keyframe\" : { \"type\" : \"object\" , \"title\" : \"Shape Keyframe\" , \"description\" : \"Keyframe holding Bezier objects\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/animated-properties/keyframe-base\" }, { \"type\" : \"object\" , \"properties\" : { \"s\" : { \"title\" : \"Start\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/helpers/bezier\" } } } } ] }, \"position-keyframe\" : { \"type\" : \"object\" , \"title\" : \"Position Keyframe\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/animated-properties/keyframe\" }, { \"properties\" : { \"ti\" : { \"title\" : \"Value In Tangent\" , \"description\" : \"Tangent for values (eg: moving position around a curved path)\" , \"type\" : \"array\" , \"items\" : { \"type\" : \"number\" } }, \"to\" : { \"title\" : \"Value Out Tangent\" , \"description\" : \"Tangent for values (eg: moving position around a curved path)\" , \"type\" : \"array\" , \"items\" : { \"type\" : \"number\" } } } } ] }, \"multi-dimensional\" : { \"type\" : \"object\" , \"title\" : \"Multi Dimensional\" , \"description\" : \"An animatable property that holds an array of numbers\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/animated-properties/animated-property\" }, { \"if\" : { \"properties\" : { \"a\" : { \"const\" : 0 } } }, \"then\" : { \"properties\" : { \"k\" : { \"title\" : \"Static value\" , \"type\" : \"array\" , \"items\" : { \"type\" : \"number\" } } } }, \"properties\" : { \"l\" : { \"title\" : \"Length\" , \"description\" : \"Number of components in the value arrays.\\nIf present values will be truncated or expanded to match this length when accessed from expressions.\" , \"type\" : \"integer\" } } } ] }, \"keyframe-base\" : { \"type\" : \"object\" , \"title\" : \"Base Keyframe\" , \"description\" : \"A Keyframes specifies the value at a specific time and the interpolation function to reach the next keyframe.\" , \"allOf\" : [ { \"properties\" : { \"t\" : { \"title\" : \"Time\" , \"type\" : \"number\" , \"default\" : 0 }, \"h\" : { \"title\" : \"Hold\" , \"$ref\" : \"#/$defs/helpers/int-boolean\" , \"default\" : 0 } } }, { \"if\" : { \"oneOf\" : [ { \"properties\" : { \"h\" : { \"const\" : 0 } } }, { \"not\" : { \"required\" : [ \"h\" ] } } ] }, \"then\" : { \"properties\" : { \"i\" : { \"title\" : \"In Tangent\" , \"description\" : \"Easing tangent going into the next keyframe\" , \"$ref\" : \"#/$defs/animated-properties/keyframe-bezier-handle\" }, \"o\" : { \"title\" : \"Out Tangent\" , \"description\" : \"Easing tangent leaving the current keyframe\" , \"$ref\" : \"#/$defs/animated-properties/keyframe-bezier-handle\" } } } } ], \"required\" : [ \"t\" , \"s\" ] }, \"shape-property\" : { \"type\" : \"object\" , \"title\" : \"Shape Property\" , \"description\" : \"An animatable property that holds a Bezier\" , \"allOf\" : [ { \"properties\" : { \"ix\" : { \"title\" : \"Property Index\" , \"type\" : \"integer\" }, \"a\" : { \"title\" : \"Animated\" , \"description\" : \"Whether the property is animated\" , \"$ref\" : \"#/$defs/helpers/int-boolean\" , \"default\" : 0 }, \"x\" : { \"title\" : \"Expression\" , \"type\" : \"string\" } } }, { \"if\" : { \"properties\" : { \"a\" : { \"const\" : 1 } } }, \"then\" : { \"properties\" : { \"k\" : { \"type\" : \"array\" , \"title\" : \"Animated Value\" , \"description\" : \"Array of keyframes\" , \"items\" : { \"$ref\" : \"#/$defs/animated-properties/shape-keyframe\" } } } }, \"else\" : { \"properties\" : { \"k\" : { \"$ref\" : \"#/$defs/helpers/bezier\" , \"title\" : \"Static Value\" } } } } ], \"required\" : [ \"k\" ] }, \"gradient-colors\" : { \"type\" : \"object\" , \"title\" : \"Gradient Colors\" , \"description\" : \"Represents colors and offsets in a gradient\\n\\nColors are represented as a flat list interleaving offsets and color components in weird ways\\nThere are two possible layouts:\\n\\nWithout alpha, the colors are a sequence of offset, r, g, b\\n\\nWith alpha, same as above but at the end of the list there is a sequence of offset, alpha\" , \"properties\" : { \"k\" : { \"title\" : \"Colors\" , \"$ref\" : \"#/$defs/animated-properties/multi-dimensional\" }, \"p\" : { \"title\" : \"Count\" , \"description\" : \"Number of colors in k \" , \"type\" : \"integer\" , \"default\" : 0 } }, \"required\" : [ \"p\" , \"k\" ] }, \"keyframe\" : { \"type\" : \"object\" , \"title\" : \"Keyframe\" , \"description\" : \"A Keyframes specifies the value at a specific time and the interpolation function to reach the next keyframe.\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/animated-properties/keyframe-base\" }, { \"properties\" : { \"s\" : { \"title\" : \"Value\" , \"description\" : \"Value at this keyframe. Note the if the property is a scalar, keyframe values are still represented as arrays\" , \"type\" : \"array\" , \"items\" : { \"type\" : \"number\" } }, \"e\" : { \"title\" : \"End value\" , \"description\" : \"Value at the end of the keyframe, note that this is deprecated and you should use s from the next keyframe to get this value\" , \"deprecated\" : true , \"type\" : \"array\" , \"items\" : { \"type\" : \"number\" } } } }, { \"if\" : { \"oneOf\" : [ { \"properties\" : { \"h\" : { \"const\" : 0 } } }, { \"not\" : { \"required\" : [ \"h\" ] } } ] }, \"then\" : { \"properties\" : { \"i\" : { \"title\" : \"In Tangent\" , \"description\" : \"Easing tangent going into the next keyframe\" , \"$ref\" : \"#/$defs/animated-properties/keyframe-bezier-handle\" }, \"o\" : { \"title\" : \"Out Tangent\" , \"description\" : \"Easing tangent leaving the current keyframe\" , \"$ref\" : \"#/$defs/animated-properties/keyframe-bezier-handle\" } } } } ], \"required\" : [ \"t\" , \"s\" ] }, \"split-vector\" : { \"type\" : \"object\" , \"title\" : \"Split Vector\" , \"description\" : \"An animatable property that is split into individually anaimated components\" , \"properties\" : { \"s\" : { \"title\" : \"Split\" , \"type\" : \"boolean\" , \"const\" : true }, \"x\" : { \"title\" : \"X\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"y\" : { \"title\" : \"Y\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"z\" : { \"title\" : \"Z\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"s\" , \"x\" , \"y\" ] }, \"color-value\" : { \"type\" : \"object\" , \"title\" : \"Color Value\" , \"description\" : \"An animatable property that holds a Color\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/animated-properties/animated-property\" }, { \"if\" : { \"properties\" : { \"a\" : { \"const\" : 0 } } }, \"then\" : { \"properties\" : { \"k\" : { \"title\" : \"Static value\" , \"$ref\" : \"#/$defs/helpers/color\" } } } } ] } }, \"animation\" : { \"composition\" : { \"type\" : \"object\" , \"title\" : \"Composition\" , \"description\" : \"Base class for layer holders\" , \"properties\" : { \"layers\" : { \"title\" : \"Layers\" , \"type\" : \"array\" , \"items\" : { \"oneOf\" : [ { \"$ref\" : \"#/$defs/layers/precomposition-layer\" }, { \"$ref\" : \"#/$defs/layers/solid-color-layer\" }, { \"$ref\" : \"#/$defs/layers/image-layer\" }, { \"$ref\" : \"#/$defs/layers/null-layer\" }, { \"$ref\" : \"#/$defs/layers/shape-layer\" }, { \"$ref\" : \"#/$defs/layers/text-layer\" }, { \"$ref\" : \"#/$defs/layers/audio-layer\" }, { \"$ref\" : \"#/$defs/layers/camera-layer\" }, { \"$ref\" : \"#/$defs/layers/data-layer\" } ] } } }, \"required\" : [ \"layers\" ] }, \"animation\" : { \"type\" : \"object\" , \"title\" : \"Animation\" , \"description\" : \"Top level object, describing the animation\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/visual-object\" }, { \"type\" : \"object\" , \"properties\" : { \"v\" : { \"title\" : \"Version\" , \"type\" : \"string\" , \"default\" : \"5.5.2\" }, \"fr\" : { \"title\" : \"Framerate\" , \"description\" : \"Framerate in frames per second\" , \"type\" : \"number\" , \"default\" : 60 }, \"ip\" : { \"title\" : \"In Point\" , \"description\" : \"\\\"In Point\\\", which frame the animation starts at (usually 0)\" , \"type\" : \"number\" , \"default\" : 0 }, \"op\" : { \"title\" : \"Out Point\" , \"description\" : \"\\\"Out Point\\\", which frame the animation stops/loops at, which makes this the duration in frames when ip is 0\" , \"type\" : \"number\" , \"default\" : 60 }, \"w\" : { \"title\" : \"Width\" , \"description\" : \"Width of the animation\" , \"type\" : \"integer\" , \"default\" : 512 }, \"h\" : { \"title\" : \"Height\" , \"description\" : \"Height of the animation\" , \"type\" : \"integer\" , \"default\" : 512 }, \"ddd\" : { \"title\" : \"Threedimensional\" , \"$ref\" : \"#/$defs/helpers/int-boolean\" , \"default\" : 0 , \"description\" : \"Whether the animation has 3D layers\" }, \"assets\" : { \"title\" : \"Assets\" , \"type\" : \"array\" , \"description\" : \"List of assets that can be referenced by layers\" , \"items\" : { \"oneOf\" : [ { \"$ref\" : \"#/$defs/assets/image\" }, { \"$ref\" : \"#/$defs/assets/precomposition\" }, { \"$ref\" : \"#/$defs/assets/sound\" }, { \"$ref\" : \"#/$defs/assets/data-source\" } ] } }, \"comps\" : { \"title\" : \"Extra Compositions\" , \"type\" : \"array\" , \"description\" : \"List of Extra compositions not referenced by anything\" , \"items\" : { \"$ref\" : \"#/$defs/assets/precomposition\" } }, \"fonts\" : { \"title\" : \"Fonts\" , \"$ref\" : \"#/$defs/text/font-list\" }, \"chars\" : { \"title\" : \"Characters\" , \"description\" : \"Data defining text characters as lottie shapes. If present a player might only render characters defined here and nothing else.\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/text/character-data\" } }, \"meta\" : { \"title\" : \"Metadata\" , \"description\" : \"Document metadata\" , \"$ref\" : \"#/$defs/animation/metadata\" }, \"metadata\" : { \"title\" : \"User Metadata\" , \"$ref\" : \"#/$defs/animation/user-metadata\" }, \"markers\" : { \"title\" : \"Markers\" , \"description\" : \"Markers defining named sections of the composition.\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/helpers/marker\" } }, \"mb\" : { \"title\" : \"Motion Blur\" , \"$ref\" : \"#/$defs/animation/motion-blur\" }, \"slots\" : { \"title\" : \"Slots\" , \"description\" : \"Available property overrides\" , \"type\" : \"object\" , \"patternProperties\" : { \".*\" : { \"p\" : { \"anyOf\" : [ { \"$ref\" : \"#/$defs/animated-properties/multi-dimensional\" }, { \"$ref\" : \"#/$defs/animated-properties/color-value\" }, { \"$ref\" : \"#/$defs/animated-properties/position\" }, { \"$ref\" : \"#/$defs/animated-properties/shape-property\" }, { \"$ref\" : \"#/$defs/animated-properties/value\" }, { \"$ref\" : \"#/$defs/assets/image\" }, { \"$ref\" : \"#/$defs/text/animated-text-document\" } ] }, \"required\" : [ \"p\" ] } } } }, \"required\" : [ \"w\" , \"h\" , \"fr\" , \"layers\" , \"op\" , \"ip\" ] }, { \"$ref\" : \"#/$defs/animation/composition\" } ] }, \"motion-blur\" : { \"type\" : \"object\" , \"title\" : \"Motion Blur\" , \"description\" : \"Motion blur settings\" , \"properties\" : { \"sa\" : { \"title\" : \"Shutter Angle\" , \"description\" : \"Angle in degrees\" , \"type\" : \"number\" }, \"sp\" : { \"title\" : \"Shutter Phase\" , \"description\" : \"Angle in degrees\" , \"type\" : \"number\" }, \"spf\" : { \"title\" : \"Samples per Frame\" , \"type\" : \"number\" }, \"asl\" : { \"title\" : \"Adaptive Sample Limit\" , \"type\" : \"number\" } } }, \"metadata\" : { \"type\" : \"object\" , \"title\" : \"Metadata\" , \"description\" : \"Document metadata\" , \"properties\" : { \"a\" : { \"title\" : \"Author\" , \"type\" : \"string\" }, \"d\" : { \"title\" : \"Description\" , \"type\" : \"string\" }, \"tc\" : { \"title\" : \"Theme Color\" , \"type\" : \"string\" }, \"g\" : { \"title\" : \"Generator\" , \"description\" : \"Software used to generate the file\" , \"type\" : \"string\" } }, \"anyOf\" : [ { \"properties\" : { \"k\" : { \"title\" : \"Keywords\" , \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" } } } }, { \"properties\" : { \"k\" : { \"title\" : \"Keywords\" , \"type\" : \"string\" } } } ] }, \"user-metadata\" : { \"type\" : \"object\" , \"title\" : \"User Metadata\" , \"description\" : \"User-defined metadata\" , \"properties\" : { \"filename\" : { \"title\" : \"Filename\" , \"type\" : \"string\" }, \"customProps\" : { \"title\" : \"Custom Properties\" , \"type\" : \"object\" } } } }, \"assets\" : { \"image\" : { \"type\" : \"object\" , \"title\" : \"Image\" , \"description\" : \"External image\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/assets/file-asset\" }, { \"type\" : \"object\" , \"properties\" : { \"w\" : { \"title\" : \"Width\" , \"description\" : \"Width of the image\" , \"type\" : \"number\" , \"default\" : 0 }, \"h\" : { \"title\" : \"Height\" , \"description\" : \"Height of the image\" , \"type\" : \"number\" , \"default\" : 0 }, \"t\" : { \"title\" : \"Type\" , \"description\" : \"Marks as part of an image sequence if present\" , \"type\" : \"string\" , \"const\" : \"seq\" }, \"sid\" : { \"title\" : \"Slot ID\" , \"description\" : \"One of the ID in the file's slots\" , \"type\" : \"string\" } }, \"required\" : [ \"p\" ] } ] }, \"data-source\" : { \"type\" : \"object\" , \"title\" : \"Data source\" , \"description\" : \"External data source, usually a JSON file\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/assets/file-asset\" }, { \"type\" : \"object\" , \"properties\" : { \"t\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 3 } }, \"required\" : [ \"t\" ] } ] }, \"asset\" : { \"type\" : \"object\" , \"title\" : \"Asset\" , \"description\" : \"\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"id\" : { \"title\" : \"ID\" , \"description\" : \"Unique identifier used by layers when referencing this asset\" , \"type\" : \"string\" , \"default\" : \"\" }, \"nm\" : { \"title\" : \"Name\" , \"description\" : \"Human readable name\" , \"type\" : \"string\" } }, \"required\" : [ \"id\" ] } ] }, \"file-asset\" : { \"type\" : \"object\" , \"title\" : \"File Asset\" , \"description\" : \"Asset referencing a file\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/assets/asset\" }, { \"type\" : \"object\" , \"properties\" : { \"u\" : { \"title\" : \"Path\" , \"description\" : \"Path to the directory containing a file\" , \"type\" : \"string\" , \"default\" : \"\" }, \"p\" : { \"title\" : \"File name\" , \"description\" : \"Filename or data url\" , \"type\" : \"string\" , \"default\" : \"\" }, \"e\" : { \"title\" : \"Embedded\" , \"description\" : \"Whether the file is embedded\" , \"$ref\" : \"#/$defs/helpers/int-boolean\" , \"default\" : 0 } }, \"required\" : [ \"p\" ] } ] }, \"precomposition\" : { \"type\" : \"object\" , \"title\" : \"Precomposition\" , \"description\" : \"Asset containing an animation that can be referenced by layers.\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/assets/asset\" }, { \"$ref\" : \"#/$defs/animation/composition\" }, { \"type\" : \"object\" , \"properties\" : { \"fr\" : { \"title\" : \"Framerate\" , \"description\" : \"Framerate in frames per second\" , \"type\" : \"number\" }, \"xt\" : { \"title\" : \"Extra\" , \"description\" : \"Extra composition\" , \"$ref\" : \"#/$defs/helpers/int-boolean\" , \"default\" : 0 } } } ] }, \"sound\" : { \"type\" : \"object\" , \"title\" : \"Sound\" , \"description\" : \"External sound\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/assets/file-asset\" } ] } }, \"constants\" : { \"fill-rule\" : { \"type\" : \"integer\" , \"title\" : \"Fill Rule\" , \"description\" : \"Rule used to handle multiple shapes rendered with the same fill object\" , \"oneOf\" : [ { \"title\" : \"Non Zero\" , \"description\" : \"Everything is colored (You can think of this as an OR)\" , \"const\" : 1 }, { \"title\" : \"Even Odd\" , \"description\" : \"Colored based on intersections and path direction, can be used to create \\\"holes\\\"\" , \"const\" : 2 } ] }, \"blend-mode\" : { \"type\" : \"integer\" , \"title\" : \"Blend Mode\" , \"description\" : \"Layer and shape blend mode\" , \"caniuse\" : \"blend-mode\" , \"oneOf\" : [ { \"title\" : \"Normal\" , \"const\" : 0 }, { \"title\" : \"Multiply\" , \"const\" : 1 }, { \"title\" : \"Screen\" , \"const\" : 2 }, { \"title\" : \"Overlay\" , \"const\" : 3 }, { \"title\" : \"Darken\" , \"const\" : 4 }, { \"title\" : \"Lighten\" , \"const\" : 5 }, { \"title\" : \"Color Dodge\" , \"const\" : 6 }, { \"title\" : \"Color Burn\" , \"const\" : 7 }, { \"title\" : \"Hard Light\" , \"const\" : 8 }, { \"title\" : \"Soft Light\" , \"const\" : 9 }, { \"title\" : \"Difference\" , \"const\" : 10 }, { \"title\" : \"Exclusion\" , \"const\" : 11 }, { \"title\" : \"Hue\" , \"const\" : 12 }, { \"title\" : \"Saturation\" , \"const\" : 13 }, { \"title\" : \"Color\" , \"const\" : 14 }, { \"title\" : \"Luminosity\" , \"const\" : 15 }, { \"title\" : \"Add\" , \"const\" : 16 }, { \"title\" : \"Hard Mix\" , \"const\" : 17 } ] }, \"text-grouping\" : { \"type\" : \"integer\" , \"title\" : \"Text Grouping\" , \"description\" : \"\" , \"oneOf\" : [ { \"title\" : \"Characters\" , \"const\" : 1 }, { \"title\" : \"Word\" , \"const\" : 2 }, { \"title\" : \"Line\" , \"const\" : 3 }, { \"title\" : \"All\" , \"const\" : 4 } ] }, \"trim-multiple-shapes\" : { \"type\" : \"integer\" , \"title\" : \"Trim Multiple Shapes\" , \"description\" : \"How to handle multiple shapes in trim path\" , \"oneOf\" : [ { \"title\" : \"Simultaneously\" , \"const\" : 1 }, { \"title\" : \"Individually\" , \"const\" : 2 } ] }, \"composite\" : { \"type\" : \"integer\" , \"title\" : \"Composite\" , \"description\" : \"How to stack copies in a repeater\" , \"oneOf\" : [ { \"title\" : \"Above\" , \"const\" : 1 }, { \"title\" : \"Below\" , \"const\" : 2 } ] }, \"stroke-dash-type\" : { \"type\" : \"string\" , \"title\" : \"Stroke Dash Type\" , \"description\" : \"Type of a dash item in a stroked line\" , \"oneOf\" : [ { \"title\" : \"Dash\" , \"const\" : \"d\" }, { \"title\" : \"Gap\" , \"const\" : \"g\" }, { \"title\" : \"Offset\" , \"const\" : \"o\" } ] }, \"text-range-units\" : { \"type\" : \"integer\" , \"title\" : \"Text Range Units\" , \"description\" : \"Unit type for a text selector\" , \"oneOf\" : [ { \"title\" : \"Percent\" , \"const\" : 1 }, { \"title\" : \"Index\" , \"const\" : 2 } ] }, \"line-cap\" : { \"type\" : \"integer\" , \"title\" : \"Line Cap\" , \"description\" : \"Style at the end of a stoked line\" , \"oneOf\" : [ { \"title\" : \"Butt\" , \"const\" : 1 }, { \"title\" : \"Round\" , \"const\" : 2 }, { \"title\" : \"Square\" , \"const\" : 3 } ] }, \"mask-mode\" : { \"type\" : \"string\" , \"title\" : \"Mask Mode\" , \"description\" : \"How masks interact with each other. See https://helpx.adobe.com/after-effects/using/alpha-channels-masks-mattes.html\" , \"oneOf\" : [ { \"title\" : \"None\" , \"const\" : \"n\" }, { \"title\" : \"Add\" , \"const\" : \"a\" }, { \"title\" : \"Subtract\" , \"const\" : \"s\" }, { \"title\" : \"Intersect\" , \"const\" : \"i\" }, { \"title\" : \"Lighten\" , \"const\" : \"l\" }, { \"title\" : \"Darken\" , \"const\" : \"d\" }, { \"title\" : \"Difference\" , \"const\" : \"f\" } ] }, \"gradient-type\" : { \"type\" : \"integer\" , \"title\" : \"Gradient Type\" , \"description\" : \"Type of a gradient\" , \"oneOf\" : [ { \"title\" : \"Linear\" , \"type\" : \"integer\" , \"const\" : 1 }, { \"title\" : \"Radial\" , \"type\" : \"integer\" , \"const\" : 2 } ] }, \"text-caps\" : { \"type\" : \"integer\" , \"title\" : \"Text Caps\" , \"oneOf\" : [ { \"title\" : \"Regular\" , \"const\" : 0 }, { \"title\" : \"All Caps\" , \"const\" : 1 }, { \"title\" : \"Small Caps\" , \"const\" : 2 } ], \"default\" : 0 }, \"text-justify\" : { \"type\" : \"integer\" , \"title\" : \"Text Justify\" , \"description\" : \"Text alignment / justification\" , \"oneOf\" : [ { \"title\" : \"Left\" , \"const\" : 0 }, { \"title\" : \"Right\" , \"const\" : 1 }, { \"title\" : \"Center\" , \"const\" : 2 }, { \"title\" : \"Justify with Last Line Left\" , \"const\" : 3 }, { \"title\" : \"Justify with Last Line Right\" , \"const\" : 4 }, { \"title\" : \"Justify with Last Line Center\" , \"const\" : 5 }, { \"title\" : \"Justify with Last Line Full\" , \"const\" : 6 } ] }, \"shape-direction\" : { \"type\" : \"integer\" , \"title\" : \"Shape Direction\" , \"description\" : \"Drawing direction of the shape curve, useful for trim path\" , \"oneOf\" : [ { \"title\" : \"Normal\" , \"description\" : \"Usually clockwise\" , \"const\" : 1 }, { \"title\" : \"Reversed\" , \"description\" : \"Usually counter clockwise\" , \"const\" : 3 } ] }, \"line-join\" : { \"type\" : \"integer\" , \"title\" : \"Line Join\" , \"description\" : \"Style at a sharp corner of a stoked line\" , \"oneOf\" : [ { \"title\" : \"Miter\" , \"const\" : 1 }, { \"title\" : \"Round\" , \"const\" : 2 }, { \"title\" : \"Bevel\" , \"const\" : 3 } ] }, \"matte-mode\" : { \"type\" : \"integer\" , \"title\" : \"Matte Mode\" , \"description\" : \"How a layer should mask another layer\" , \"oneOf\" : [ { \"title\" : \"Normal\" , \"const\" : 0 }, { \"title\" : \"Alpha\" , \"const\" : 1 }, { \"title\" : \"Inverted Alpha\" , \"const\" : 2 }, { \"title\" : \"Luma\" , \"const\" : 3 }, { \"title\" : \"Inverted Luma\" , \"const\" : 4 } ] }, \"text-based\" : { \"type\" : \"integer\" , \"title\" : \"Text Based\" , \"description\" : \"\" , \"oneOf\" : [ { \"title\" : \"Characters\" , \"const\" : 1 }, { \"title\" : \"Character Excluding Spaces\" , \"const\" : 2 }, { \"title\" : \"Words\" , \"const\" : 3 }, { \"title\" : \"Lines\" , \"const\" : 4 } ] }, \"font-path-origin\" : { \"type\" : \"integer\" , \"title\" : \"Font Path Origin\" , \"description\" : \"\" , \"oneOf\" : [ { \"title\" : \"Local\" , \"const\" : 0 }, { \"title\" : \"Css Url\" , \"const\" : 1 }, { \"title\" : \"Script Url\" , \"const\" : 2 }, { \"title\" : \"Font Url\" , \"const\" : 3 } ] }, \"text-shape\" : { \"type\" : \"integer\" , \"title\" : \"Text Shape\" , \"description\" : \"Defines the function used to determine the interpolating factor on a text range selector.\" , \"oneOf\" : [ { \"title\" : \"Square\" , \"const\" : 1 }, { \"title\" : \"Ramp Up\" , \"const\" : 2 }, { \"title\" : \"Ramp Down\" , \"const\" : 3 }, { \"title\" : \"Triangle\" , \"const\" : 4 }, { \"title\" : \"Round\" , \"const\" : 5 }, { \"title\" : \"Smooth\" , \"const\" : 6 } ] }, \"merge-mode\" : { \"type\" : \"integer\" , \"title\" : \"Merge Mode\" , \"description\" : \"Boolean operation on shapes\" , \"oneOf\" : [ { \"title\" : \"Normal\" , \"const\" : 1 }, { \"title\" : \"Add\" , \"const\" : 2 }, { \"title\" : \"Subtract\" , \"const\" : 3 }, { \"title\" : \"Intersect\" , \"const\" : 4 }, { \"title\" : \"Exclude Intersections\" , \"const\" : 5 } ] }, \"star-type\" : { \"type\" : \"integer\" , \"title\" : \"Star Type\" , \"description\" : \"Star or Polygon\" , \"oneOf\" : [ { \"title\" : \"Star\" , \"const\" : 1 }, { \"title\" : \"Polygon\" , \"const\" : 2 } ] } }, \"effect-values\" : { \"angle\" : { \"type\" : \"object\" , \"title\" : \"Effect Value Angle\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effect-values/effect-value\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 1 }, \"v\" : { \"title\" : \"Value\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" ] } ] }, \"ignored\" : { \"type\" : \"object\" , \"title\" : \"Ignored Value\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effect-values/effect-value\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 6 }, \"v\" : { \"title\" : \"Value\" , \"type\" : \"number\" , \"default\" : 0 } }, \"required\" : [ \"ty\" ] } ] }, \"drop-down\" : { \"type\" : \"object\" , \"title\" : \"Effect Value Drop Down\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effect-values/effect-value\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 7 }, \"v\" : { \"title\" : \"Value\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" ] } ] }, \"checkbox\" : { \"type\" : \"object\" , \"title\" : \"Effect Value Checkbox\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effect-values/effect-value\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 4 }, \"v\" : { \"title\" : \"Value\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" ] } ] }, \"no-value\" : { \"type\" : \"object\" , \"title\" : \"Effect No Value\" , \"description\" : \"\" }, \"slider\" : { \"type\" : \"object\" , \"title\" : \"Effect Value Slider\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effect-values/effect-value\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 0 }, \"v\" : { \"title\" : \"Value\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" ] } ] }, \"effect-value\" : { \"type\" : \"object\" , \"title\" : \"Effect Value\" , \"description\" : \"Value for an effect\" , \"caniuse\" : \"effects\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/visual-object\" }, { \"type\" : \"object\" , \"properties\" : { \"ix\" : { \"title\" : \"Effect Index\" , \"type\" : \"integer\" }, \"mn\" : { \"title\" : \"Match Name\" , \"type\" : \"string\" }, \"nm\" : { \"title\" : \"Name\" , \"type\" : \"string\" }, \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" } }, \"required\" : [] } ] }, \"point\" : { \"type\" : \"object\" , \"title\" : \"Effect Value Point\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effect-values/effect-value\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 3 }, \"v\" : { \"title\" : \"Value\" , \"$ref\" : \"#/$defs/animated-properties/multi-dimensional\" } }, \"required\" : [ \"ty\" ] } ] }, \"color\" : { \"type\" : \"object\" , \"title\" : \"Effect Value Color\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effect-values/effect-value\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 2 }, \"v\" : { \"title\" : \"Value\" , \"$ref\" : \"#/$defs/animated-properties/color-value\" } }, \"required\" : [ \"ty\" ] } ] }, \"layer\" : { \"type\" : \"object\" , \"title\" : \"Effect Value Layer\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effect-values/effect-value\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 10 }, \"v\" : { \"title\" : \"Value\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" ] } ] } }, \"effects\" : { \"radial-wipe-effect\" : { \"type\" : \"object\" , \"title\" : \"Radial Wipe\" , \"caniuse\" : \"effect-radial-wipe\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 26 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"Completion\" , \"description\" : \"Between 0 and 100\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Start Angle\" , \"$ref\" : \"#/$defs/effect-values/angle\" }, { \"title\" : \"Wipe Center\" , \"$ref\" : \"#/$defs/effect-values/point\" }, { \"title\" : \"Wipe\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Feather\" , \"$ref\" : \"#/$defs/effect-values/slider\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"puppet-effect\" : { \"type\" : \"object\" , \"title\" : \"Puppet Effect\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 34 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"Puppet Engine\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Mesh Rotation Refinement\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"On Transparent\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"03\" , \"$ref\" : \"#/$defs/effect-values/no-value\" } ] } }, \"required\" : [ \"ty\" , \"ef\" ] } ] }, \"fill-effect\" : { \"type\" : \"object\" , \"title\" : \"Fill Effect\" , \"description\" : \"Replaces the whole layer with the given color\" , \"caniuse\" : \"effect-fill\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 21 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"00\" , \"$ref\" : \"#/$defs/effect-values/point\" }, { \"title\" : \"01\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"color\" , \"$ref\" : \"#/$defs/effect-values/color\" }, { \"title\" : \"03\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"04\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"05\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"opacity\" , \"description\" : \"Opacity in [0, 1]\" , \"$ref\" : \"#/$defs/effect-values/slider\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"effect\" : { \"type\" : \"object\" , \"title\" : \"Effect\" , \"description\" : \"Layer effect\" , \"caniuse\" : \"effects\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/visual-object\" }, { \"type\" : \"object\" , \"properties\" : { \"ef\" : { \"title\" : \"Effect Values\" , \"type\" : \"array\" , \"items\" : { \"oneOf\" : [ { \"$ref\" : \"#/$defs/effect-values/no-value\" }, { \"$ref\" : \"#/$defs/effect-values/angle\" }, { \"$ref\" : \"#/$defs/effect-values/checkbox\" }, { \"$ref\" : \"#/$defs/effect-values/color\" }, { \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"$ref\" : \"#/$defs/effect-values/ignored\" }, { \"$ref\" : \"#/$defs/effect-values/layer\" }, { \"$ref\" : \"#/$defs/effect-values/point\" }, { \"$ref\" : \"#/$defs/effect-values/slider\" } ] } }, \"np\" : { \"title\" : \"Property Count\" , \"description\" : \"Number of values in ef \" , \"type\" : \"integer\" }, \"ix\" : { \"title\" : \"Effect Index\" , \"type\" : \"integer\" }, \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Effect type\" , \"type\" : \"integer\" }, \"en\" : { \"title\" : \"Enabled\" , \"$ref\" : \"#/$defs/helpers/int-boolean\" , \"default\" : 1 } }, \"required\" : [ \"ty\" , \"ef\" ] } ] }, \"pro-levels-effect\" : { \"type\" : \"object\" , \"title\" : \"Pro Levels Effect\" , \"description\" : \"\" , \"caniuse\" : \"effect-color-levels-individual-controls\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 24 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"00\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"01\" , \"$ref\" : \"#/$defs/effect-values/no-value\" }, { \"title\" : \"02\" , \"$ref\" : \"#/$defs/effect-values/no-value\" }, { \"title\" : \"comp_inblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"comp_inwhite\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"comp_gamma\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"comp_outblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"comp_outwhite\" , \"$ref\" : \"#/$defs/effect-values/no-value\" }, { \"title\" : \"08\" , \"$ref\" : \"#/$defs/effect-values/no-value\" }, { \"title\" : \"09\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"r_inblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"r_inwhite\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"r_gamma\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"r_outblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"r_outwhite\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"15\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"16\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"g_inblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"g_inwhite\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"g_gamma\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"g_outblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"g_outwhite\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"22\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"23\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"b_inblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"b_inwhite\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"b_gamma\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"b_outblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"b_outwhite\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"29\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"a_inblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"a_inwhite\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"a_gamma\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"a_outblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"a_outwhite\" , \"$ref\" : \"#/$defs/effect-values/no-value\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"tritone-effect\" : { \"type\" : \"object\" , \"title\" : \"Tritone Effect\" , \"description\" : \"Maps layers colors based on bright/mid/dark colors\" , \"caniuse\" : \"effect-tritone\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 23 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"bright\" , \"$ref\" : \"#/$defs/effect-values/color\" }, { \"title\" : \"mid\" , \"$ref\" : \"#/$defs/effect-values/color\" }, { \"title\" : \"dark\" , \"$ref\" : \"#/$defs/effect-values/color\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"stroke-effect\" : { \"type\" : \"object\" , \"title\" : \"Stroke Effect\" , \"description\" : \"\" , \"caniuse\" : \"effect-stroke\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 22 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"00\" , \"$ref\" : \"#/$defs/effect-values/color\" }, { \"title\" : \"01\" , \"$ref\" : \"#/$defs/effect-values/checkbox\" }, { \"title\" : \"02\" , \"$ref\" : \"#/$defs/effect-values/checkbox\" }, { \"title\" : \"color\" , \"$ref\" : \"#/$defs/effect-values/color\" }, { \"title\" : \"04\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"05\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"06\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"07\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"08\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"09\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"type\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"custom-effect\" : { \"type\" : \"object\" , \"title\" : \"Custom Effect\" , \"description\" : \"Some lottie files use ty = 5 for many different effects\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 5 } }, \"required\" : [ \"ty\" ] } ] }, \"mesh-warp-effect\" : { \"type\" : \"object\" , \"title\" : \"Mesh Warp Effect\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 31 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"Rows\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Columns\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Quality\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"03\" , \"$ref\" : \"#/$defs/effect-values/no-value\" } ] } }, \"required\" : [ \"ty\" , \"ef\" ] } ] }, \"spherize-effect\" : { \"type\" : \"object\" , \"title\" : \"Spherize Effect\" , \"description\" : \"\" , \"caniuse\" : \"effect-cc-sphere\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 33 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"radius\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"center\" , \"$ref\" : \"#/$defs/effect-values/point\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"drop-shadow-effect\" : { \"type\" : \"object\" , \"title\" : \"Drop Shadow Effect\" , \"description\" : \"Adds a shadow to the layer\" , \"caniuse\" : \"effect-drop-shadow\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 25 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"color\" , \"$ref\" : \"#/$defs/effect-values/color\" }, { \"title\" : \"opacity\" , \"description\" : \"Opacity between 0 and 255\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"angle\" , \"$ref\" : \"#/$defs/effect-values/angle\" }, { \"title\" : \"distance\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"blur\" , \"$ref\" : \"#/$defs/effect-values/slider\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"tint-effect\" : { \"type\" : \"object\" , \"title\" : \"Tint Effect\" , \"description\" : \"Colorizes the layer\" , \"caniuse\" : \"effect-tint\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 20 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"Black Color\" , \"description\" : \"Tint of the darker parts of the layer\" , \"$ref\" : \"#/$defs/effect-values/color\" }, { \"title\" : \"White Color\" , \"description\" : \"Tint of the lighter parts of the layer\" , \"$ref\" : \"#/$defs/effect-values/color\" }, { \"title\" : \"Intensity\" , \"description\" : \"Intensity of the effect, 0 means the layer is unchanged. 100 means full effect\" , \"$ref\" : \"#/$defs/effect-values/slider\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"displacement-map-effect\" : { \"type\" : \"object\" , \"title\" : \"Displacement Map Effect\" , \"description\" : \"\" , \"caniuse\" : \"effect-displacement-map\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 27 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"Displacement Map Layer\" , \"$ref\" : \"#/$defs/effect-values/layer\" }, { \"title\" : \"Use For Horizontal Displacement\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Max Horizontal Displacement\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Use For Vertical Displacement\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Max Vertical Displacement\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Displacement Map Behavior\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Edge Behavior\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Expand Output\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" } ] } }, \"required\" : [ \"ty\" , \"ef\" ] } ] }, \"matte3-effect\" : { \"type\" : \"object\" , \"title\" : \"Set Matte Effect\" , \"description\" : \"Uses a layer as a mask\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 28 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"Layer\" , \"description\" : \"Use this layer as a mask\" , \"$ref\" : \"#/$defs/effect-values/layer\" }, { \"title\" : \"Channel\" , \"description\" : \"Channel to use as a mask:\\n1 - Red\\n2 - Green\\n3 - Blue\\n4 - Alpha\\n5 - Luminance\\n6 - Hue\\n7 - Lightness\\n8 - Saturation\\n9 - Full\\n10 - Off\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Invert\" , \"description\" : \"Use 0 as opaque value when true\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Stretch To Fit\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Show Mask\" , \"description\" : \"If false, the mask layer won't be shown\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Premultiply Mask\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"wavy-effect\" : { \"type\" : \"object\" , \"title\" : \"Wavy Effect\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 32 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"Radius\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Center\" , \"$ref\" : \"#/$defs/effect-values/point\" }, { \"title\" : \"Conversion type\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Speed\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Width\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Height\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Phase\" , \"$ref\" : \"#/$defs/effect-values/slider\" } ] } }, \"required\" : [ \"ty\" , \"ef\" ] } ] }, \"twirl-effect\" : { \"type\" : \"object\" , \"title\" : \"Twirl Effect\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 30 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"Angle\" , \"$ref\" : \"#/$defs/effect-values/angle\" }, { \"title\" : \"Radius\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Center\" , \"$ref\" : \"#/$defs/effect-values/point\" } ] } }, \"required\" : [ \"ty\" , \"ef\" ] } ] }, \"gaussian-blur-effect\" : { \"type\" : \"object\" , \"title\" : \"Gaussian Blur Effect\" , \"description\" : \"Gaussian blur\" , \"caniuse\" : \"effect-gaussian-blur\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 29 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"sigma\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"direction\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"wrap\" , \"$ref\" : \"#/$defs/effect-values/checkbox\" } ] } }, \"required\" : [ \"ty\" ] } ] } }, \"helpers\" : { \"mask\" : { \"type\" : \"object\" , \"title\" : \"Mask\" , \"caniuse\" : \"mask\" , \"description\" : \"Bezier shape used to mask/clip a layer\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/visual-object\" }, { \"type\" : \"object\" , \"properties\" : { \"inv\" : { \"title\" : \"Inverted\" , \"caniuse\" : \"mask-inverted\" , \"type\" : \"boolean\" , \"default\" : false }, \"pt\" : { \"title\" : \"Shape\" , \"$ref\" : \"#/$defs/animated-properties/shape-property\" }, \"o\" : { \"title\" : \"Opacity\" , \"caniuse\" : \"mask-opacity\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"mode\" : { \"title\" : \"Mode\" , \"caniuse\" : \"mask-modes\" , \"$ref\" : \"#/$defs/constants/mask-mode\" , \"default\" : \"i\" }, \"x\" : { \"title\" : \"Expand\" , \"caniuse\" : \"mask-expansion\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [] } ] }, \"marker\" : { \"type\" : \"object\" , \"title\" : \"Marker\" , \"description\" : \"Defines named portions of the composition.\" , \"properties\" : { \"cm\" : { \"title\" : \"Comment\" , \"type\" : \"string\" }, \"tm\" : { \"title\" : \"Time\" , \"type\" : \"number\" }, \"dr\" : { \"title\" : \"Duration\" , \"type\" : \"number\" } } }, \"bezier\" : { \"type\" : \"object\" , \"title\" : \"Bezier\" , \"description\" : \"Single bezier curve\" , \"properties\" : { \"c\" : { \"title\" : \"Closed\" , \"type\" : \"boolean\" , \"default\" : false }, \"i\" : { \"title\" : \"In Tangents\" , \"type\" : \"array\" , \"description\" : \"Array of points, each point is an array of coordinates.\\nThese points are along the in tangents relative to the corresponding v .\" , \"items\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"number\" , \"default\" : [] } } }, \"o\" : { \"title\" : \"Out Tangents\" , \"type\" : \"array\" , \"description\" : \"Array of points, each point is an array of coordinates.\\nThese points are along the out tangents relative to the corresponding v .\" , \"items\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"number\" , \"default\" : [] } } }, \"v\" : { \"title\" : \"Vertices\" , \"description\" : \"Array of points, each point is an array of coordinates.\\nThese points are along the bezier path\" , \"type\" : \"array\" , \"items\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"number\" , \"default\" : [] } } } }, \"required\" : [ \"i\" , \"v\" , \"o\" ] }, \"visual-object\" : { \"type\" : \"object\" , \"title\" : \"Visual Object\" , \"description\" : \"\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"nm\" : { \"title\" : \"Name\" , \"description\" : \"Name, as seen from editors and the like\" , \"type\" : \"string\" }, \"mn\" : { \"title\" : \"Match Name\" , \"description\" : \"Match name, used in expressions\" , \"type\" : \"string\" } }, \"required\" : [] } ] }, \"transform\" : { \"type\" : \"object\" , \"title\" : \"Transform\" , \"description\" : \"Layer transform\" , \"allOf\" : [ { \"properties\" : { \"a\" : { \"title\" : \"Anchor Point\" , \"caniuse\" : \"transform-anchor-point\" , \"description\" : \"Anchor point: a position (relative to its parent) around which transformations are applied (ie: center for rotation / scale)\" , \"$ref\" : \"#/$defs/animated-properties/position\" }, \"s\" : { \"title\" : \"Scale\" , \"caniuse\" : \"transform-scale\" , \"description\" : \"Scale factor, [100, 100] for no scaling\" , \"$ref\" : \"#/$defs/animated-properties/multi-dimensional\" }, \"o\" : { \"title\" : \"Opacity\" , \"caniuse\" : \"transform-opacity\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"sk\" : { \"title\" : \"Skew\" , \"caniuse\" : \"transform-skew\" , \"description\" : \"Skew amount as an angle in degrees\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"sa\" : { \"title\" : \"Skew Axis\" , \"caniuse\" : \"transform-skew\" , \"description\" : \"Direction along which skew is applied, in degrees ( 0 skews along the X axis, 90 along the Y axis)\" , \"$ref\" : \"#/$defs/animated-properties/value\" } } }, { \"anyOf\" : [ { \"oneOf\" : [ { \"properties\" : { \"p\" : { \"title\" : \"Position\" , \"caniuse\" : \"transform-position\" , \"description\" : \"Position / Translation\" , \"$ref\" : \"#/$defs/animated-properties/position\" } } }, { \"properties\" : { \"p\" : { \"title\" : \"Position\" , \"description\" : \"Position / Translation with split components\" , \"$ref\" : \"#/$defs/animated-properties/split-vector\" } } } ] }, { \"oneOf\" : [ { \"properties\" : { \"r\" : { \"title\" : \"Rotation\" , \"caniuse\" : \"transform-rotation\" , \"description\" : \"Rotation in degrees, clockwise\" , \"$ref\" : \"#/$defs/animated-properties/value\" } } }, { \"properties\" : { \"rx\" : { \"title\" : \"X Rotation\" , \"description\" : \"Split rotation component\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"ry\" : { \"title\" : \"Y Rotation\" , \"description\" : \"Split rotation component\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"rz\" : { \"title\" : \"Z Rotation\" , \"description\" : \"Split rotation component, equivalent to r when not split\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"or\" : { \"title\" : \"Orientation\" , \"$ref\" : \"#/$defs/animated-properties/multi-dimensional\" } } } ] } ] } ] }, \"int-boolean\" : { \"type\" : \"integer\" , \"title\" : \"Integer Boolean\" , \"description\" : \"Represents boolean values as an integer. 0 is false, 1 is true.\" , \"default\" : 0 , \"examples\" : [ 0 ], \"enum\" : [ 0 , 1 ], \"oneOf\" : [ { \"title\" : \"True\" , \"const\" : 1 }, { \"title\" : \"False\" , \"const\" : 0 } ] }, \"color\" : { \"type\" : \"array\" , \"title\" : \"Color\" , \"description\" : \"Color as a [r, g, b] array with values in [0, 1]\" , \"items\" : { \"type\" : \"number\" , \"minimum\" : 0 , \"maximum\" : 1 }, \"minItems\" : 3 , \"maxItems\" : 4 } }, \"layers\" : { \"precomposition-layer\" : { \"type\" : \"object\" , \"title\" : \"Precomposition Layer\" , \"description\" : \"Layer that renders a Precomposition asset\" , \"caniuse\" : \"layer-precomp\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/visual-layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer type\" , \"type\" : \"integer\" , \"const\" : 0 }, \"refId\" : { \"title\" : \"Reference Id\" , \"description\" : \"ID of the precomp as specified in the assets\" , \"type\" : \"string\" }, \"w\" : { \"title\" : \"Width\" , \"description\" : \"Width of the clipping rect\" , \"type\" : \"integer\" }, \"h\" : { \"title\" : \"Height\" , \"description\" : \"Height of the clipping rect\" , \"type\" : \"integer\" }, \"tm\" : { \"title\" : \"Time Remapping\" , \"caniuse\" : \"property-timeremap\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" , \"refId\" , \"w\" , \"h\" ] } ] }, \"null-layer\" : { \"type\" : \"object\" , \"title\" : \"Null Layer\" , \"description\" : \"Layer with no data, useful to group layers together\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/visual-layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer type\" , \"type\" : \"integer\" , \"const\" : 3 } }, \"required\" : [ \"ty\" ] } ] }, \"visual-layer\" : { \"type\" : \"object\" , \"title\" : \"Visual Layer\" , \"description\" : \"Layer used to affect visual elements\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ks\" : { \"title\" : \"Transform\" , \"caniuse\" : \"transform\" , \"description\" : \"Layer transform\" , \"$ref\" : \"#/$defs/helpers/transform\" }, \"ao\" : { \"title\" : \"Auto Orient\" , \"$ref\" : \"#/$defs/helpers/int-boolean\" , \"default\" : 0 , \"description\" : \"If 1, The layer will rotate itself to match its animated position path\" }, \"tt\" : { \"title\" : \"Matte Mode\" , \"caniuse\" : \"property-matte-mask\" , \"$ref\" : \"#/$defs/constants/matte-mode\" , \"description\" : \"Defines the track matte mode for the layer\" }, \"tp\" : { \"title\" : \"Matte Parent\" , \"type\" : \"integer\" , \"description\" : \"Index of the layer used as matte, if omitted assume the layer above the current one\" }, \"td\" : { \"title\" : \"Matte Target\" , \"caniuse\" : \"property-matte-mask\" , \"$ref\" : \"#/$defs/helpers/int-boolean\" , \"description\" : \"If set to 1, it means a layer is using this layer as a track matte\" }, \"hasMask\" : { \"title\" : \"Has Masks\" , \"caniuse\" : \"mask\" , \"description\" : \"Whether the layer has masks applied\" , \"type\" : \"boolean\" }, \"masksProperties\" : { \"title\" : \"Masks\" , \"caniuse\" : \"mask\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/helpers/mask\" } }, \"ef\" : { \"title\" : \"Effects\" , \"description\" : \"List of layer effects\" , \"caniuse\" : \"effects\" , \"type\" : \"array\" , \"items\" : { \"oneOf\" : [ { \"$ref\" : \"#/$defs/effects/custom-effect\" }, { \"$ref\" : \"#/$defs/effects/drop-shadow-effect\" }, { \"$ref\" : \"#/$defs/effects/fill-effect\" }, { \"$ref\" : \"#/$defs/effects/gaussian-blur-effect\" }, { \"$ref\" : \"#/$defs/effects/matte3-effect\" }, { \"$ref\" : \"#/$defs/effects/pro-levels-effect\" }, { \"$ref\" : \"#/$defs/effects/stroke-effect\" }, { \"$ref\" : \"#/$defs/effects/tint-effect\" }, { \"$ref\" : \"#/$defs/effects/tritone-effect\" }, { \"$ref\" : \"#/$defs/effects/radial-wipe-effect\" }, { \"$ref\" : \"#/$defs/effects/wavy-effect\" }, { \"$ref\" : \"#/$defs/effects/puppet-effect\" }, { \"$ref\" : \"#/$defs/effects/spherize-effect\" }, { \"$ref\" : \"#/$defs/effects/mesh-warp-effect\" }, { \"$ref\" : \"#/$defs/effects/displacement-map-effect\" }, { \"$ref\" : \"#/$defs/effects/twirl-effect\" } ] } }, \"mb\" : { \"title\" : \"Motion Blur\" , \"description\" : \"Whether motion blur is enabled for the layer\" , \"type\" : \"boolean\" }, \"sy\" : { \"title\" : \"Layer style\" , \"caniuse\" : \"styles\" , \"description\" : \"Styling effects for this layer\" , \"type\" : \"array\" , \"items\" : { \"oneOf\" : [ { \"$ref\" : \"#/$defs/styles/stroke-style\" }, { \"$ref\" : \"#/$defs/styles/drop-shadow-style\" }, { \"$ref\" : \"#/$defs/styles/inner-shadow-style\" }, { \"$ref\" : \"#/$defs/styles/outer-glow-style\" }, { \"$ref\" : \"#/$defs/styles/inner-glow-style\" }, { \"$ref\" : \"#/$defs/styles/bevel-emboss-style\" }, { \"$ref\" : \"#/$defs/styles/satin-style\" }, { \"$ref\" : \"#/$defs/styles/color-overlay-style\" }, { \"$ref\" : \"#/$defs/styles/gradient-overlay-style\" } ] } }, \"bm\" : { \"title\" : \"Blend Mode\" , \"$ref\" : \"#/$defs/constants/blend-mode\" , \"default\" : 0 }, \"cl\" : { \"title\" : \"CSS Class\" , \"description\" : \"CSS class used by the SVG renderer\" , \"type\" : \"string\" }, \"ln\" : { \"title\" : \"Layer XML ID\" , \"description\" : \" id attribute used by the SVG renderer\" , \"type\" : \"string\" }, \"tg\" : { \"title\" : \"Layer XML tag name\" , \"description\" : \"tag name used by the SVG renderer\" , \"type\" : \"string\" }, \"cp\" : { \"deprecated\" : true , \"title\" : \"Collapse Transform\" , \"description\" : \"This is deprecated in favour of ct \" , \"type\" : \"boolean\" }, \"ct\" : { \"title\" : \"Collapse Transform\" , \"description\" : \"Marks that transforms should be applied before masks\" , \"$ref\" : \"#/$defs/helpers/int-boolean\" , \"default\" : 0 } }, \"required\" : [ \"ks\" ] } ] }, \"camera-layer\" : { \"type\" : \"object\" , \"title\" : \"Camera Layer\" , \"description\" : \"3D Camera\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer type\" , \"type\" : \"integer\" , \"const\" : 13 }, \"ks\" : { \"title\" : \"Transform\" , \"description\" : \"Layer transform\" , \"$ref\" : \"#/$defs/helpers/transform\" }, \"pe\" : { \"title\" : \"Perspective\" , \"description\" : \"Distance from the Z=0 plane.\\nSmall values yield a higher perspective effect.\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" , \"ks\" , \"pe\" ] } ] }, \"solid-color-layer\" : { \"type\" : \"object\" , \"title\" : \"Solid Color Layer\" , \"description\" : \"Layer with a solid color rectangle\" , \"caniuse\" : \"layer-solid\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/visual-layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer type\" , \"type\" : \"integer\" , \"const\" : 1 }, \"sc\" : { \"title\" : \"Color\" , \"description\" : \"Color of the layer, unlike most other places, the color is a #rrggbb hex string\" , \"type\" : \"string\" , \"default\" : \"\" }, \"sh\" : { \"title\" : \"Height\" , \"type\" : \"number\" }, \"sw\" : { \"title\" : \"Width\" , \"type\" : \"number\" } }, \"required\" : [ \"ty\" , \"sc\" , \"sw\" , \"sh\" ] } ] }, \"audio-layer\" : { \"type\" : \"object\" , \"title\" : \"Audio Layer\" , \"description\" : \"A layer playing sounds\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer type\" , \"type\" : \"integer\" , \"const\" : 6 }, \"au\" : { \"title\" : \"Audio Settings\" , \"$ref\" : \"#/$defs/layers/audio-settings\" }, \"refId\" : { \"title\" : \"Sound Id\" , \"description\" : \"ID of the sound as specified in the assets\" , \"type\" : \"string\" } }, \"required\" : [ \"ty\" , \"au\" ] } ] }, \"data-layer\" : { \"type\" : \"object\" , \"title\" : \"Data Layer\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer type\" , \"type\" : \"integer\" , \"const\" : 15 }, \"refId\" : { \"title\" : \"Data source Id\" , \"description\" : \"ID of the data source in assets\" , \"type\" : \"string\" } }, \"required\" : [ \"ty\" ] } ] }, \"audio-settings\" : { \"type\" : \"object\" , \"title\" : \"Audio Settings\" , \"description\" : \"\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"lv\" : { \"title\" : \"Level\" , \"$ref\" : \"#/$defs/animated-properties/multi-dimensional\" } }, \"required\" : [ \"lv\" ] } ] }, \"shape-layer\" : { \"type\" : \"object\" , \"title\" : \"Shape Layer\" , \"description\" : \"Layer containing Shapes\" , \"caniuse\" : \"layer-shape\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/visual-layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer type\" , \"type\" : \"integer\" , \"const\" : 4 }, \"shapes\" : { \"title\" : \"Shapes\" , \"$ref\" : \"#/$defs/shapes/shape-list\" } }, \"required\" : [ \"ty\" , \"shapes\" ] } ] }, \"image-layer\" : { \"type\" : \"object\" , \"title\" : \"Image Layer\" , \"description\" : \"Layer that shows an image asset\" , \"caniuse\" : \"layer-image\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/visual-layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer type\" , \"type\" : \"integer\" , \"const\" : 2 }, \"refId\" : { \"title\" : \"Image Id\" , \"description\" : \"ID of the image as specified in the assets\" , \"type\" : \"string\" , \"default\" : \"\" } }, \"required\" : [ \"ty\" , \"refId\" ] } ] }, \"layer\" : { \"type\" : \"object\" , \"title\" : \"Layer\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/visual-object\" }, { \"type\" : \"object\" , \"properties\" : { \"ddd\" : { \"title\" : \"Threedimensional\" , \"description\" : \"Whether the layer is threedimensional\" , \"$ref\" : \"#/$defs/helpers/int-boolean\" , \"default\" : 0 }, \"hd\" : { \"title\" : \"Hidden\" , \"description\" : \"Whether the layer is hidden\" , \"type\" : \"boolean\" }, \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"oneOf\" : [ { \"const\" : 0 , \"title\" : \"Precomposition layer\" }, { \"const\" : 1 , \"title\" : \"Solid color layer\" }, { \"const\" : 2 , \"title\" : \"Image layer\" }, { \"const\" : 3 , \"title\" : \"Null layer\" }, { \"const\" : 4 , \"title\" : \"Shape layer\" }, { \"const\" : 5 , \"title\" : \"Text layer\" }, { \"const\" : 6 , \"title\" : \"Audio layer\" }, { \"const\" : 7 , \"title\" : \"Video placeholder\" }, { \"const\" : 8 , \"title\" : \"Image sequence\" }, { \"const\" : 9 , \"title\" : \"Video layer\" }, { \"const\" : 10 , \"title\" : \"Image placeholder\" }, { \"const\" : 11 , \"title\" : \"Guide layer\" }, { \"const\" : 12 , \"title\" : \"Adjustment layer\" }, { \"const\" : 13 , \"title\" : \"Camera\" }, { \"const\" : 14 , \"title\" : \"Light layer\" }, { \"const\" : 15 , \"title\" : \"Data layer\" } ] }, \"ind\" : { \"title\" : \"Index\" , \"type\" : \"integer\" , \"description\" : \"Index that can be used for parenting and referenced in expressions\" }, \"parent\" : { \"title\" : \"Parent Index\" , \"description\" : \"Must be the ind property of another layer\" , \"type\" : \"integer\" }, \"sr\" : { \"title\" : \"Time Stretch\" , \"caniuse\" : \"property-time-stretch\" , \"type\" : \"number\" , \"default\" : 1 }, \"ip\" : { \"title\" : \"In Point\" , \"description\" : \"Frame when the layer becomes visible\" , \"type\" : \"number\" }, \"op\" : { \"title\" : \"Out Point\" , \"description\" : \"Frame when the layer becomes invisible\" , \"type\" : \"number\" }, \"st\" : { \"title\" : \"Start Time\" , \"type\" : \"number\" , \"default\" : 0 } }, \"required\" : [ \"ty\" , \"st\" , \"ip\" , \"op\" ] } ] }, \"text-layer\" : { \"type\" : \"object\" , \"title\" : \"Text Layer\" , \"description\" : \"Layer with some text\" , \"caniuse\" : \"layer-text\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/visual-layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer type\" , \"type\" : \"integer\" , \"const\" : 5 }, \"t\" : { \"title\" : \"Data\" , \"$ref\" : \"#/$defs/text/text-data\" } }, \"required\" : [ \"ty\" , \"t\" ] } ] } }, \"shapes\" : { \"modifier\" : { \"type\" : \"object\" , \"title\" : \"Modifier\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-element\" } ] }, \"ellipse\" : { \"type\" : \"object\" , \"title\" : \"Ellipse\" , \"description\" : \"Ellipse shape\" , \"caniuse\" : \"shape-ellipse\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"el\" }, \"p\" : { \"title\" : \"Position\" , \"$ref\" : \"#/$defs/animated-properties/position\" }, \"s\" : { \"title\" : \"Size\" , \"$ref\" : \"#/$defs/animated-properties/multi-dimensional\" } }, \"required\" : [ \"ty\" , \"s\" , \"p\" ] } ] }, \"shape-list\" : { \"title\" : \"Shape List\" , \"description\" : \"List of valid shapes\" , \"type\" : \"array\" , \"items\" : { \"oneOf\" : [ { \"$ref\" : \"#/$defs/shapes/ellipse\" }, { \"$ref\" : \"#/$defs/shapes/fill\" }, { \"$ref\" : \"#/$defs/shapes/gradient-fill\" }, { \"$ref\" : \"#/$defs/shapes/gradient-stroke\" }, { \"$ref\" : \"#/$defs/shapes/group\" }, { \"$ref\" : \"#/$defs/shapes/path\" }, { \"$ref\" : \"#/$defs/shapes/polystar\" }, { \"$ref\" : \"#/$defs/shapes/pucker-bloat\" }, { \"$ref\" : \"#/$defs/shapes/rectangle\" }, { \"$ref\" : \"#/$defs/shapes/repeater\" }, { \"$ref\" : \"#/$defs/shapes/rounded-corners\" }, { \"$ref\" : \"#/$defs/shapes/stroke\" }, { \"$ref\" : \"#/$defs/shapes/transform\" }, { \"$ref\" : \"#/$defs/shapes/trim\" }, { \"$ref\" : \"#/$defs/shapes/twist\" }, { \"$ref\" : \"#/$defs/shapes/merge\" }, { \"$ref\" : \"#/$defs/shapes/offset-path\" }, { \"$ref\" : \"#/$defs/shapes/zig-zag\" }, { \"$ref\" : \"#/$defs/shapes/no-style\" } ] } }, \"stroke-dash\" : { \"type\" : \"object\" , \"title\" : \"Stroke Dash\" , \"description\" : \"An item used to described the dashe pattern in a stroked path\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/visual-object\" }, { \"type\" : \"object\" , \"properties\" : { \"n\" : { \"title\" : \"Dash Type\" , \"$ref\" : \"#/$defs/constants/stroke-dash-type\" , \"default\" : \"d\" }, \"v\" : { \"title\" : \"Length\" , \"description\" : \"Length of the dash\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [] } ] }, \"repeater-transform\" : { \"type\" : \"object\" , \"title\" : \"Repeater Transform\" , \"description\" : \"Transform used by a repeater, the transform is applied to each subsequent repeated object.\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/transform\" }, { \"type\" : \"object\" , \"properties\" : { \"so\" : { \"title\" : \"Start Opacity\" , \"description\" : \"Opacity of the first repeated object.\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"eo\" : { \"title\" : \"End Opacity\" , \"description\" : \"Opacity of the last repeated object.\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [] } ] }, \"twist\" : { \"type\" : \"object\" , \"title\" : \"Twist\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-element\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"tw\" }, \"a\" : { \"title\" : \"Angle\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"c\" : { \"title\" : \"Center\" , \"$ref\" : \"#/$defs/animated-properties/multi-dimensional\" } }, \"required\" : [ \"ty\" ] } ] }, \"offset-path\" : { \"type\" : \"object\" , \"title\" : \"Offset Path\" , \"caniuse\" : \"shape-offset-path\" , \"description\" : \"Interpolates the shape with its center point and bezier tangents with the opposite direction\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-element\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"op\" }, \"a\" : { \"title\" : \"Amount\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"lj\" : { \"title\" : \"Line Join\" , \"$ref\" : \"#/$defs/constants/line-join\" , \"default\" : 2 }, \"ml\" : { \"title\" : \"Miter Limit\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" ] } ] }, \"gradient\" : { \"type\" : \"object\" , \"title\" : \"Gradient\" , \"description\" : \"\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"s\" : { \"title\" : \"Start Point\" , \"description\" : \"Starting point for the gradient\" , \"$ref\" : \"#/$defs/animated-properties/multi-dimensional\" }, \"e\" : { \"title\" : \"End Point\" , \"description\" : \"End point for the gradient\" , \"$ref\" : \"#/$defs/animated-properties/multi-dimensional\" }, \"t\" : { \"title\" : \"Gradient Type\" , \"description\" : \"Type of the gradient\" , \"$ref\" : \"#/$defs/constants/gradient-type\" , \"default\" : 1 }, \"h\" : { \"title\" : \"Highlight Length\" , \"description\" : \"Highlight Length, as a percentage between s and e \" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"a\" : { \"title\" : \"Highlight Angle\" , \"description\" : \"Highlight Angle, relative to the direction from s to e \" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"g\" : { \"title\" : \"Colors\" , \"description\" : \"Gradient colors\" , \"$ref\" : \"#/$defs/animated-properties/gradient-colors\" } }, \"required\" : [ \"s\" , \"e\" , \"g\" ] } ] }, \"gradient-stroke\" : { \"type\" : \"object\" , \"title\" : \"Gradient Stroke\" , \"description\" : \"Gradient stroke\" , \"caniuse\" : \"shape-stroke-gradient\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-element\" }, { \"$ref\" : \"#/$defs/shapes/base-stroke\" }, { \"$ref\" : \"#/$defs/shapes/gradient\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"gs\" } }, \"required\" : [ \"ty\" ] } ] }, \"polystar\" : { \"type\" : \"object\" , \"title\" : \"PolyStar\" , \"description\" : \"Star or regular polygon\" , \"caniuse\" : \"shape-polystar\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"sr\" }, \"p\" : { \"title\" : \"Position\" , \"$ref\" : \"#/$defs/animated-properties/position\" }, \"or\" : { \"title\" : \"Outer Radius\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"os\" : { \"title\" : \"Outer Roundness\" , \"description\" : \"Outer Roundness as a percentage\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"r\" : { \"title\" : \"Rotation\" , \"description\" : \"Rotation, clockwise in degrees\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"pt\" : { \"title\" : \"Points\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"sy\" : { \"title\" : \"Star Type\" , \"description\" : \"Star type, 1 for Star, 2 for Polygon\" , \"$ref\" : \"#/$defs/constants/star-type\" , \"default\" : 1 } }, \"required\" : [ \"ty\" , \"or\" , \"os\" , \"pt\" , \"p\" , \"r\" ] }, { \"if\" : { \"properties\" : { \"sy\" : { \"const\" : 1 } } }, \"then\" : { \"properties\" : { \"ir\" : { \"title\" : \"Inner Radius\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"is\" : { \"title\" : \"Inner Roundness\" , \"description\" : \"Inner Roundness as a percentage\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ir\" , \"is\" ] } } ] }, \"shape-element\" : { \"type\" : \"object\" , \"title\" : \"Shape Element\" , \"description\" : \"Base class for all elements of ShapeLayer and Group\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/visual-object\" }, { \"type\" : \"object\" , \"properties\" : { \"hd\" : { \"title\" : \"Hidden\" , \"description\" : \"Whether the shape is hidden\" , \"type\" : \"boolean\" }, \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"oneOf\" : [ { \"const\" : \"rc\" , \"title\" : \"Rectangle\" }, { \"const\" : \"el\" , \"title\" : \"Ellipse\" }, { \"const\" : \"sr\" , \"title\" : \"Polygon / Star\" }, { \"const\" : \"sh\" , \"title\" : \"Path\" }, { \"const\" : \"fl\" , \"title\" : \"Fill\" }, { \"const\" : \"st\" , \"title\" : \"Stroke\" }, { \"const\" : \"gf\" , \"title\" : \"Gradient fill\" }, { \"const\" : \"gs\" , \"title\" : \"Gradient stroke\" }, { \"const\" : \"no\" , \"title\" : \"No Style\" }, { \"const\" : \"gr\" , \"title\" : \"Group\" }, { \"const\" : \"tr\" , \"title\" : \"Transform\" }, { \"const\" : \"rd\" , \"title\" : \"Rounded corners\" }, { \"const\" : \"pb\" , \"title\" : \"Pucker / bloat\" }, { \"const\" : \"mm\" , \"title\" : \"Merge\" }, { \"const\" : \"tw\" , \"title\" : \"Twist\" }, { \"const\" : \"op\" , \"title\" : \"Offset path\" }, { \"const\" : \"zz\" , \"title\" : \"Zig zag\" }, { \"const\" : \"rp\" , \"title\" : \"Repeater\" }, { \"const\" : \"tm\" , \"title\" : \"Trim\" } ] }, \"bm\" : { \"title\" : \"Blend Mode\" , \"$ref\" : \"#/$defs/constants/blend-mode\" }, \"ix\" : { \"title\" : \"Property index\" , \"description\" : \"Index used in expressions\" , \"type\" : \"integer\" }, \"cl\" : { \"title\" : \"CSS Class\" , \"description\" : \"CSS class used by the SVG renderer\" , \"type\" : \"string\" }, \"ln\" : { \"title\" : \"Layer XML ID\" , \"description\" : \" id attribute used by the SVG renderer\" , \"type\" : \"string\" } }, \"required\" : [ \"ty\" ] } ] }, \"group\" : { \"type\" : \"object\" , \"title\" : \"Group\" , \"description\" : \"Shape Element that can contain other shapes\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-element\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"gr\" }, \"np\" : { \"title\" : \"Number Of Properties\" , \"type\" : \"number\" }, \"it\" : { \"title\" : \"Shapes\" , \"$ref\" : \"#/$defs/shapes/shape-list\" }, \"cix\" : { \"title\" : \"Property index\" , \"description\" : \"Index used in expressions\" , \"type\" : \"integer\" } }, \"required\" : [ \"ty\" ] } ] }, \"fill\" : { \"type\" : \"object\" , \"title\" : \"Fill\" , \"description\" : \"Solid fill color\" , \"caniuse\" : \"shape-fill\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-element\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"fl\" }, \"o\" : { \"title\" : \"Opacity\" , \"description\" : \"Opacity, 100 means fully opaque\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"c\" : { \"title\" : \"Color\" , \"$ref\" : \"#/$defs/animated-properties/color-value\" }, \"r\" : { \"title\" : \"Fill Rule\" , \"$ref\" : \"#/$defs/constants/fill-rule\" } }, \"required\" : [ \"ty\" , \"c\" , \"o\" ] } ] }, \"gradient-fill\" : { \"type\" : \"object\" , \"title\" : \"Gradient Fill\" , \"description\" : \"Gradient fill\" , \"caniuse\" : \"shape-fill-gradient\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-element\" }, { \"$ref\" : \"#/$defs/shapes/gradient\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"gf\" }, \"o\" : { \"title\" : \"Opacity\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"r\" : { \"title\" : \"Fill Rule\" , \"$ref\" : \"#/$defs/constants/fill-rule\" } }, \"required\" : [ \"ty\" , \"o\" ] } ] }, \"path\" : { \"type\" : \"object\" , \"title\" : \"Path\" , \"description\" : \"Animatable Bezier curve\" , \"caniuse\" : \"shape-path\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"sh\" }, \"ks\" : { \"title\" : \"Shape\" , \"description\" : \"Bezier path\" , \"$ref\" : \"#/$defs/animated-properties/shape-property\" } }, \"required\" : [ \"ty\" , \"ks\" ] } ] }, \"merge\" : { \"type\" : \"object\" , \"title\" : \"Merge\" , \"caniuse\" : \"shape-merge-path\" , \"description\" : \"Boolean operator on shapes\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-element\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"mm\" }, \"mm\" : { \"title\" : \"Merge Mode\" , \"$ref\" : \"#/$defs/constants/merge-mode\" , \"default\" : 1 } }, \"required\" : [ \"ty\" ] } ] }, \"repeater\" : { \"type\" : \"object\" , \"title\" : \"Repeater\" , \"description\" : \"Duplicates previous shapes in a group\" , \"caniuse\" : \"shape-repeater\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/modifier\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"rp\" }, \"c\" : { \"title\" : \"Copies\" , \"description\" : \"Number of copies\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"o\" : { \"title\" : \"Offset\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"m\" : { \"title\" : \"Composite\" , \"description\" : \"Stacking order\" , \"$ref\" : \"#/$defs/constants/composite\" , \"default\" : 1 }, \"tr\" : { \"title\" : \"Transform\" , \"description\" : \"Transform applied to each copy\" , \"$ref\" : \"#/$defs/shapes/repeater-transform\" } }, \"required\" : [ \"ty\" , \"c\" , \"tr\" ] } ] }, \"shape\" : { \"type\" : \"object\" , \"title\" : \"Shape\" , \"description\" : \"Drawable shape\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-element\" }, { \"type\" : \"object\" , \"properties\" : { \"d\" : { \"title\" : \"Direction\" , \"description\" : \"Direction the shape is drawn as, mostly relevant when using trim path\" , \"$ref\" : \"#/$defs/constants/shape-direction\" } } } ] }, \"pucker-bloat\" : { \"type\" : \"object\" , \"title\" : \"Pucker Bloat\" , \"description\" : \"Interpolates the shape with its center point and bezier tangents with the opposite direction\" , \"caniuse\" : \"shape-pucker-and-bloat\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-element\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"pb\" }, \"a\" : { \"title\" : \"Amount\" , \"description\" : \"Amount as a percentage\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" ] } ] }, \"rounded-corners\" : { \"type\" : \"object\" , \"title\" : \"Rounded Corners\" , \"description\" : \"Rounds corners of other shapes\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/modifier\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"rd\" }, \"r\" : { \"title\" : \"Radius\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" , \"r\" ] } ] }, \"zig-zag\" : { \"type\" : \"object\" , \"title\" : \"Zig Zag\" , \"description\" : \"Changes the edges of affected shapes into a series of peaks and valleys of uniform size\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-element\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"zz\" }, \"r\" : { \"title\" : \"Frequency\" , \"description\" : \"Number of ridges per segment\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"s\" : { \"title\" : \"Amplitude\" , \"description\" : \"Distance between peaks and troughs\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"pt\" : { \"title\" : \"Point Type\" , \"description\" : \"Point type (1 = corner, 2 = smooth)\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" ] } ] }, \"transform\" : { \"type\" : \"object\" , \"title\" : \"Transform Shape\" , \"description\" : \"Group transform\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-element\" }, { \"$ref\" : \"#/$defs/helpers/transform\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"tr\" } }, \"required\" : [ \"ty\" ] } ] }, \"no-style\" : { \"type\" : \"object\" , \"title\" : \"No Style\" , \"description\" : \"Represents a style for shapes without fill or stroke\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-element\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"no\" } }, \"required\" : [ \"ty\" ] } ] }, \"stroke\" : { \"type\" : \"object\" , \"title\" : \"Stroke\" , \"description\" : \"Solid stroke\" , \"caniuse\" : \"shape-stroke\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-element\" }, { \"$ref\" : \"#/$defs/shapes/base-stroke\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"st\" }, \"c\" : { \"title\" : \"Color\" , \"description\" : \"Stroke color\" , \"$ref\" : \"#/$defs/animated-properties/color-value\" } }, \"required\" : [ \"ty\" , \"c\" ] } ] }, \"trim\" : { \"type\" : \"object\" , \"title\" : \"Trim\" , \"description\" : \"Trims shapes into a segment\" , \"caniuse\" : \"shape-trim-path\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/modifier\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"tm\" }, \"s\" : { \"title\" : \"Start\" , \"description\" : \"Segment start\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"e\" : { \"title\" : \"End\" , \"description\" : \"Segment end\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"o\" : { \"title\" : \"Offset\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"m\" : { \"title\" : \"Multiple\" , \"description\" : \"How to treat multiple copies\" , \"$ref\" : \"#/$defs/constants/trim-multiple-shapes\" } }, \"required\" : [ \"ty\" , \"o\" , \"s\" , \"e\" ] } ] }, \"rectangle\" : { \"type\" : \"object\" , \"title\" : \"Rectangle\" , \"description\" : \"A simple rectangle shape\" , \"caniuse\" : \"shape-rectangle\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"rc\" }, \"p\" : { \"title\" : \"Position\" , \"description\" : \"Center of the rectangle\" , \"$ref\" : \"#/$defs/animated-properties/position\" }, \"s\" : { \"title\" : \"Size\" , \"$ref\" : \"#/$defs/animated-properties/multi-dimensional\" }, \"r\" : { \"title\" : \"Rounded\" , \"description\" : \"Rounded corners radius\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" , \"s\" , \"p\" , \"r\" ] } ] }, \"base-stroke\" : { \"type\" : \"object\" , \"title\" : \"Base Stroke\" , \"description\" : \"\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"lc\" : { \"title\" : \"Line Cap\" , \"$ref\" : \"#/$defs/constants/line-cap\" , \"default\" : 2 }, \"lj\" : { \"title\" : \"Line Join\" , \"$ref\" : \"#/$defs/constants/line-join\" , \"default\" : 2 }, \"ml\" : { \"title\" : \"Miter Limit\" , \"type\" : \"number\" , \"default\" : 0 }, \"ml2\" : { \"title\" : \"Miter Limit\" , \"description\" : \"Animatable alternative to ml\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"o\" : { \"title\" : \"Opacity\" , \"description\" : \"Opacity, 100 means fully opaque\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"w\" : { \"title\" : \"Width\" , \"description\" : \"Stroke width\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"d\" : { \"title\" : \"Dashes\" , \"description\" : \"Dashed line definition\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/shapes/stroke-dash\" } } }, \"required\" : [ \"o\" , \"w\" ] } ] } }, \"styles\" : { \"drop-shadow-style\" : { \"type\" : \"object\" , \"title\" : \"Drop Shadow\" , \"caniuse\" : \"style-drop-shadow\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/styles/layer-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"const\" : 1 }, \"c\" : { \"title\" : \"Color\" , \"$ref\" : \"#/$defs/animated-properties/color-value\" }, \"o\" : { \"title\" : \"Opacity\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"a\" : { \"title\" : \"Angle\" , \"description\" : \"Local light angle\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"s\" : { \"title\" : \"Size\" , \"description\" : \"Blur size\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"d\" : { \"title\" : \"Distance\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"ch\" : { \"title\" : \"Choke Spread\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"bm\" : { \"title\" : \"Blend Mode\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"no\" : { \"title\" : \"Noise\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"lc\" : { \"title\" : \"Layer Conceal\" , \"description\" : \"Layer knowck out drop shadow\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" ] } ] }, \"inner-shadow-style\" : { \"type\" : \"object\" , \"title\" : \"Inner Shadow\" , \"caniuse\" : \"style-inner-shadow\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/styles/layer-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"const\" : 2 }, \"c\" : { \"title\" : \"Color\" , \"$ref\" : \"#/$defs/animated-properties/color-value\" }, \"o\" : { \"title\" : \"Opacity\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"a\" : { \"title\" : \"Angle\" , \"description\" : \"Local light angle\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"s\" : { \"title\" : \"Size\" , \"description\" : \"Blur size\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"d\" : { \"title\" : \"Distance\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"ch\" : { \"title\" : \"Choke Spread\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"bm\" : { \"title\" : \"Blend Mode\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"no\" : { \"title\" : \"Noise\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" ] } ] }, \"layer-style\" : { \"type\" : \"object\" , \"title\" : \"Layer Style\" , \"description\" : \"Style applied to a layer\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/visual-object\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Style Type\" , \"type\" : \"integer\" } }, \"required\" : [ \"ty\" ] } ] }, \"bevel-emboss-style\" : { \"type\" : \"object\" , \"title\" : \"Bevel Emboss\" , \"caniuse\" : \"style-bevel-and-emboss\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/styles/layer-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"const\" : 5 }, \"bs\" : { \"title\" : \"Bevel Style\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"bt\" : { \"title\" : \"Technique\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"sr\" : { \"title\" : \"Strength\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"s\" : { \"title\" : \"Size\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"sf\" : { \"title\" : \"Soften\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"ga\" : { \"title\" : \"Global Angle\" , \"description\" : \"Use global light\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"a\" : { \"title\" : \"Angle\" , \"description\" : \"Local lighting angle\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"ll\" : { \"title\" : \"Altitude\" , \"description\" : \"Local lighting altitude\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"hm\" : { \"title\" : \"Highlight Mode\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"hc\" : { \"title\" : \"Highlight Color\" , \"$ref\" : \"#/$defs/animated-properties/color-value\" }, \"ho\" : { \"title\" : \"Highlight Opacity\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"sm\" : { \"title\" : \"Shadow Mode\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"sc\" : { \"title\" : \"Shadow Color\" , \"$ref\" : \"#/$defs/animated-properties/color-value\" }, \"so\" : { \"title\" : \"Shadow Opacity\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" ] } ] }, \"outer-glow-style\" : { \"type\" : \"object\" , \"title\" : \"Outer Glow\" , \"caniuse\" : \"style-outer-glow\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/styles/layer-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"const\" : 3 }, \"c\" : { \"title\" : \"Color\" , \"$ref\" : \"#/$defs/animated-properties/color-value\" }, \"o\" : { \"title\" : \"Opacity\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"r\" : { \"title\" : \"Range\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"ch\" : { \"title\" : \"Choke Spread\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"bm\" : { \"title\" : \"Blend Mode\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"no\" : { \"title\" : \"Noise\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"j\" : { \"title\" : \"Jitter\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" ] } ] }, \"gradient-overlay-style\" : { \"type\" : \"object\" , \"title\" : \"Gradient Overlay\" , \"caniuse\" : \"style-gradient-overlay\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/styles/layer-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"const\" : 8 }, \"bm\" : { \"title\" : \"Blend Mode\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"o\" : { \"title\" : \"Opacity\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"gf\" : { \"title\" : \"Gradient\" , \"$ref\" : \"#/$defs/animated-properties/gradient-colors\" }, \"gs\" : { \"title\" : \"Smoothness\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"a\" : { \"title\" : \"Angle\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"gt\" : { \"title\" : \"Gradient Type\" , \"$ref\" : \"#/$defs/constants/gradient-type\" }, \"re\" : { \"title\" : \"Reverse\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"al\" : { \"title\" : \"Align\" , \"description\" : \"Align with layer\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"s\" : { \"title\" : \"Scale\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"of\" : { \"title\" : \"Offset\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" ] } ] }, \"satin-style\" : { \"type\" : \"object\" , \"title\" : \"Satin\" , \"caniuse\" : \"style-satin\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/styles/layer-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"const\" : 6 }, \"bm\" : { \"title\" : \"Blend Mode\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"c\" : { \"title\" : \"Color\" , \"$ref\" : \"#/$defs/animated-properties/color-value\" }, \"o\" : { \"title\" : \"Opacity\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"a\" : { \"title\" : \"Angle\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"d\" : { \"title\" : \"Distance\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"s\" : { \"title\" : \"Size\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"in\" : { \"title\" : \"Invert\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" ] } ] }, \"stroke-style\" : { \"type\" : \"object\" , \"title\" : \"Layer Stroke\" , \"caniuse\" : \"style-stroke\" , \"description\" : \"Stroke / frame\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/styles/layer-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"const\" : 0 }, \"s\" : { \"title\" : \"Size\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"c\" : { \"title\" : \"Color\" , \"$ref\" : \"#/$defs/animated-properties/color-value\" } }, \"required\" : [ \"ty\" ] } ] }, \"color-overlay-style\" : { \"type\" : \"object\" , \"title\" : \"Color Overlay\" , \"caniuse\" : \"style-color-overlay\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/styles/layer-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"const\" : 7 }, \"bm\" : { \"title\" : \"Blend Mode\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"c\" : { \"title\" : \"Color\" , \"$ref\" : \"#/$defs/animated-properties/color-value\" }, \"so\" : { \"title\" : \"Opacity\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" ] } ] }, \"inner-glow-style\" : { \"type\" : \"object\" , \"title\" : \"Inner Glow\" , \"caniuse\" : \"style-inner-glow\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/styles/layer-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"const\" : 4 }, \"c\" : { \"title\" : \"Color\" , \"$ref\" : \"#/$defs/animated-properties/color-value\" }, \"o\" : { \"title\" : \"Opacity\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"r\" : { \"title\" : \"Range\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"sr\" : { \"title\" : \"Source\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"ch\" : { \"title\" : \"Choke Spread\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"bm\" : { \"title\" : \"Blend Mode\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"no\" : { \"title\" : \"Noise\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"j\" : { \"title\" : \"Jitter\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" ] } ] } }, \"text\" : { \"text-data\" : { \"type\" : \"object\" , \"title\" : \"Text Data\" , \"description\" : \"Contains all the text data and animation\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"a\" : { \"title\" : \"Ranges\" , \"caniuse\" : \"text-animators\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/text/text-range\" } }, \"d\" : { \"title\" : \"Document\" , \"$ref\" : \"#/$defs/text/animated-text-document\" }, \"m\" : { \"title\" : \"Alignment\" , \"$ref\" : \"#/$defs/text/text-alignment-options\" }, \"p\" : { \"title\" : \"Follow Path\" , \"$ref\" : \"#/$defs/text/text-follow-path\" } }, \"required\" : [ \"a\" , \"d\" , \"m\" , \"p\" ] } ] }, \"text-follow-path\" : { \"type\" : \"object\" , \"title\" : \"Text Follow Path\" , \"caniuse\" : \"text-path\" , \"description\" : \"Uses the path described by a layer mask to put the text on said path.\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"m\" : { \"title\" : \"Mask\" , \"type\" : \"integer\" , \"description\" : \"Index of the mask to use\" }, \"f\" : { \"title\" : \"First Margin\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"l\" : { \"title\" : \"Last Margin\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"r\" : { \"title\" : \"Reverse Path\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"a\" : { \"title\" : \"Force Alignment\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"p\" : { \"title\" : \"Perpendicular To Path\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [] } ] }, \"text-document\" : { \"type\" : \"object\" , \"title\" : \"Text Document\" , \"description\" : \"\" , \"properties\" : { \"f\" : { \"title\" : \"Font Family\" , \"type\" : \"string\" , \"default\" : \"\" }, \"fc\" : { \"title\" : \"Fill Color\" , \"$ref\" : \"#/$defs/helpers/color\" , \"default\" : [ 0 , 0 , 0 ] }, \"sc\" : { \"title\" : \"Stroke Color\" , \"$ref\" : \"#/$defs/helpers/color\" }, \"sw\" : { \"title\" : \"Stroke Width\" , \"type\" : \"number\" , \"default\" : 0 }, \"of\" : { \"title\" : \"Stroke Over Fill\" , \"description\" : \"Render stroke above the fill\" , \"type\" : \"boolean\" }, \"s\" : { \"title\" : \"Font Size\" , \"type\" : \"number\" , \"default\" : 10 }, \"lh\" : { \"title\" : \"Line Height\" , \"description\" : \"Distance between lines on multiline or wrapped text\" , \"type\" : \"number\" }, \"sz\" : { \"title\" : \"Wrap Size\" , \"description\" : \"Size of the box containing the text\" , \"type\" : \"array\" , \"minItems\" : 2 , \"maxItems\" : 2 , \"items\" : { \"type\" : \"number\" } }, \"ps\" : { \"title\" : \"Wrap Position\" , \"description\" : \"Position of the box containing the text\" , \"type\" : \"array\" , \"minItems\" : 2 , \"maxItems\" : 2 , \"items\" : { \"type\" : \"number\" } }, \"t\" : { \"title\" : \"Text\" , \"type\" : \"string\" , \"description\" : \"Text, note that newlines are encoded with \\r\" , \"default\" : \"\" }, \"j\" : { \"title\" : \"Justify\" , \"$ref\" : \"#/$defs/constants/text-justify\" , \"default\" : 0 }, \"ca\" : { \"title\" : \"Text Caps\" , \"$ref\" : \"#/$defs/constants/text-caps\" }, \"tr\" : { \"title\" : \"Tracking\" , \"description\" : \"Text Tracking\" , \"type\" : \"number\" }, \"ls\" : { \"title\" : \"Baseline Shift\" , \"type\" : \"number\" } }, \"required\" : [ \"f\" , \"fc\" , \"s\" , \"t\" ] }, \"character-precomp\" : { \"type\" : \"object\" , \"title\" : \"Character Precomp\" , \"description\" : \"Defines a character as a precomp layer\" , \"properties\" : { \"refId\" : { \"title\" : \"Reference Id\" , \"description\" : \"ID of the precomp as specified in the assets\" , \"type\" : \"string\" }, \"ks\" : { \"title\" : \"Transform\" , \"description\" : \"Layer transform\" , \"$ref\" : \"#/$defs/helpers/transform\" }, \"ip\" : { \"title\" : \"In Point\" , \"description\" : \"Frame when the layer becomes visible\" , \"type\" : \"number\" , \"default\" : 0 }, \"op\" : { \"title\" : \"Out Point\" , \"description\" : \"Frame when the layer becomes invisible\" , \"type\" : \"number\" , \"default\" : 99999 }, \"sr\" : { \"title\" : \"Time Stretch\" , \"type\" : \"number\" , \"default\" : 1 }, \"st\" : { \"title\" : \"Start Time\" , \"type\" : \"number\" , \"default\" : 0 } }, \"required\" : [ \"refId\" ] }, \"text-range-selector\" : { \"type\" : \"object\" , \"title\" : \"Text Range Selector\" , \"caniuse\" : \"animators-range-selectors\" , \"properties\" : { \"t\" : { \"title\" : \"Expressible\" , \"$ref\" : \"#/$defs/helpers/int-boolean\" }, \"xe\" : { \"title\" : \"Max Ease\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"ne\" : { \"title\" : \"Min Ease\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"a\" : { \"title\" : \"Max Amount\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"b\" : { \"title\" : \"Based On\" , \"$ref\" : \"#/$defs/constants/text-based\" }, \"rn\" : { \"title\" : \"Randomize\" , \"$ref\" : \"#/$defs/helpers/int-boolean\" }, \"sh\" : { \"title\" : \"Shape\" , \"$ref\" : \"#/$defs/constants/text-shape\" }, \"o\" : { \"title\" : \"Offset\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"r\" : { \"title\" : \"Range Units\" , \"caniuse\" : \"range-selectors-units\" , \"$ref\" : \"#/$defs/constants/text-range-units\" }, \"sm\" : { \"title\" : \"Selector Smoothness\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"s\" : { \"title\" : \"Start\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"e\" : { \"title\" : \"End\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"t\" , \"a\" , \"b\" , \"sh\" ] }, \"font-list\" : { \"type\" : \"object\" , \"title\" : \"Font List\" , \"description\" : \"List of fonts\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"list\" : { \"title\" : \"List\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/text/font\" } } }, \"required\" : [] } ] }, \"character-shapes\" : { \"type\" : \"object\" , \"title\" : \"Character Shape\" , \"description\" : \"Defines a character as shapes\" , \"properties\" : { \"shapes\" : { \"title\" : \"Shapes\" , \"description\" : \"Shapes forming the character\" , \"$ref\" : \"#/$defs/shapes/shape-list\" } }, \"required\" : [ \"shapes\" ] }, \"animated-text-document\" : { \"type\" : \"object\" , \"title\" : \"Animated Text Document\" , \"description\" : \"Animated property representing the text contents\" , \"properties\" : { \"k\" : { \"title\" : \"Keyframes\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/text/text-document-keyframe\" } }, \"x\" : { \"title\" : \"Expression\" , \"type\" : \"string\" }, \"sid\" : { \"title\" : \"Slot ID\" , \"description\" : \"One of the ID in the file's slots\" , \"type\" : \"string\" } }, \"required\" : [ \"k\" ] }, \"text-range\" : { \"type\" : \"object\" , \"title\" : \"Text Range\" , \"description\" : \"Range of text with custom animations and style\" , \"caniuse\" : \"animators-range-selectors\" , \"properties\" : { \"nm\" : { \"title\" : \"Name\" , \"type\" : \"string\" }, \"s\" : { \"title\" : \"Selector\" , \"$ref\" : \"#/$defs/text/text-range-selector\" }, \"a\" : { \"title\" : \"Style\" , \"$ref\" : \"#/$defs/text/text-style\" } } }, \"text-style\" : { \"type\" : \"object\" , \"title\" : \"Text Style\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/transform\" }, { \"type\" : \"object\" , \"properties\" : { \"sw\" : { \"title\" : \"Stroke Width\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"sc\" : { \"title\" : \"Stroke Color\" , \"$ref\" : \"#/$defs/animated-properties/color-value\" }, \"sh\" : { \"title\" : \"Stroke Hue\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"ss\" : { \"title\" : \"Stroke Saturation\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"sb\" : { \"title\" : \"Stroke Brightness\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"so\" : { \"title\" : \"Stroke Opacity\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"fc\" : { \"title\" : \"Fill Color\" , \"$ref\" : \"#/$defs/animated-properties/color-value\" }, \"fh\" : { \"title\" : \"Fill Hue\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"fs\" : { \"title\" : \"Fill Saturation\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"fb\" : { \"title\" : \"Fill Brightness\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"fo\" : { \"title\" : \"Fill Opacity\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"t\" : { \"title\" : \"Letter Spacing\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"bl\" : { \"title\" : \"Blur\" , \"caniuse\" : \"text-animators-blur\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"ls\" : { \"title\" : \"Line Spacing\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [] } ] }, \"character-data\" : { \"type\" : \"object\" , \"title\" : \"Character Data\" , \"description\" : \"Defines character shapes\" , \"properties\" : { \"ch\" : { \"title\" : \"Character\" , \"type\" : \"string\" , \"default\" : \"\" }, \"fFamily\" : { \"title\" : \"Font Family\" , \"type\" : \"string\" , \"default\" : \"\" }, \"size\" : { \"title\" : \"Font Size\" , \"type\" : \"number\" , \"default\" : 0 }, \"style\" : { \"title\" : \"Font Style\" , \"type\" : \"string\" , \"default\" : \"\" }, \"w\" : { \"title\" : \"Width\" , \"type\" : \"number\" , \"default\" : 0 }, \"data\" : { \"title\" : \"Data\" , \"oneOf\" : [ { \"$ref\" : \"#/$defs/text/character-shapes\" }, { \"$ref\" : \"#/$defs/text/character-precomp\" } ] } }, \"required\" : [ \"data\" , \"ch\" , \"fFamily\" , \"size\" , \"style\" , \"w\" ] }, \"text-alignment-options\" : { \"type\" : \"object\" , \"title\" : \"Text Alignment Options\" , \"description\" : \"\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"a\" : { \"title\" : \"Alignment\" , \"description\" : \"Group alignment\" , \"caniuse\" : \"animators-grouping-alignment\" , \"$ref\" : \"#/$defs/animated-properties/multi-dimensional\" }, \"g\" : { \"title\" : \"Grouping\" , \"description\" : \"Anchor point grouping\" , \"caniuse\" : \"animators-anchor-point-grouping\" , \"$ref\" : \"#/$defs/constants/text-grouping\" } }, \"required\" : [] } ] }, \"text-document-keyframe\" : { \"type\" : \"object\" , \"title\" : \"Text Document Keyframe\" , \"description\" : \"A keyframe containing a text document\" , \"properties\" : { \"s\" : { \"title\" : \"Start\" , \"$ref\" : \"#/$defs/text/text-document\" }, \"t\" : { \"title\" : \"Time\" , \"type\" : \"number\" , \"default\" : 0 } }, \"required\" : [ \"s\" , \"t\" ] }, \"font\" : { \"type\" : \"object\" , \"title\" : \"Font\" , \"description\" : \"Describes how a font with given settings should be loaded\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"ascent\" : { \"title\" : \"Ascent\" , \"type\" : \"number\" , \"description\" : \"Text will be moved down based on this value\" }, \"fFamily\" : { \"title\" : \"Font Family\" , \"type\" : \"string\" , \"default\" : \"sans\" }, \"fName\" : { \"title\" : \"Name\" , \"description\" : \"Name used by text documents to reference this font, usually it's fFamily followed by fStyle \" , \"type\" : \"string\" , \"default\" : \"sans-Regular\" }, \"fStyle\" : { \"title\" : \"Font Style\" , \"examples\" : [ \"Regular\" , \"Bold\" , \"Bold Italic\" ], \"type\" : \"string\" , \"default\" : \"Regular\" }, \"fPath\" : { \"title\" : \"Path\" , \"type\" : \"string\" }, \"fWeight\" : { \"title\" : \"Weight\" , \"type\" : \"string\" }, \"origin\" : { \"title\" : \"Origin\" , \"$ref\" : \"#/$defs/constants/font-path-origin\" }, \"fClass\" : { \"type\" : \"string\" , \"title\" : \"CSS Class\" , \"description\" : \"CSS Class applied to text objects using this font\" } }, \"required\" : [ \"fFamily\" , \"fName\" , \"fStyle\" ] } ] } } } }","title":"JSON Schema"},{"location":"schema/#json-schema","text":"This page shows a formatted version of the JSON schema, you can click on highlighted objects to get a link to that section of the schema. You can also click on $ref values to jump to the relevant section. If you want you can also view the raw schema file . { \"$schema\" : \"https://json-schema.org/draft/2020-12/schema\" , \"$id\" : \"https://lottiefiles.github.io/lottie-docs/schema/lottie.schema.json\" , \"type\" : \"object\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/animation/animation\" } ], \"$defs\" : { \"animated-properties\" : { \"value\" : { \"type\" : \"object\" , \"title\" : \"Value\" , \"description\" : \"An animatable property that holds a float\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/animated-properties/animated-property\" }, { \"if\" : { \"properties\" : { \"a\" : { \"const\" : 0 } } }, \"then\" : { \"properties\" : { \"k\" : { \"title\" : \"Static value\" , \"type\" : \"number\" } } } } ] }, \"keyframe-bezier-handle\" : { \"type\" : \"object\" , \"title\" : \"Keyframe Bezier Handle\" , \"description\" : \"Bezier handle for keyframe interpolation\" , \"properties\" : { \"x\" : { \"title\" : \"X\" , \"description\" : \"Time component:\\n0 means start time of the keyframe,\\n1 means time of the next keyframe.\" , \"oneOf\" : [ { \"type\" : \"array\" , \"items\" : { \"type\" : \"number\" , \"default\" : 0 , \"minimum\" : 0 , \"maximum\" : 1 }, \"minItems\" : 1 }, { \"type\" : \"number\" , \"default\" : 0 , \"minimum\" : 0 , \"maximum\" : 1 } ] }, \"y\" : { \"title\" : \"Y\" , \"description\" : \"Value interpolation component:\\n0 means start value of the keyframe,\\n1 means value at the next keyframe.\" , \"oneOf\" : [ { \"type\" : \"array\" , \"items\" : { \"type\" : \"number\" , \"default\" : 0 , \"minimum\" : 0 , \"maximum\" : 1 }, \"minItems\" : 1 }, { \"type\" : \"number\" , \"default\" : 0 , \"minimum\" : 0 , \"maximum\" : 1 } ] } }, \"required\" : [ \"x\" , \"y\" ] }, \"position\" : { \"type\" : \"object\" , \"title\" : \"Position Property\" , \"description\" : \"An animatable property to represent a position in space\" , \"allOf\" : [ { \"properties\" : { \"ix\" : { \"title\" : \"Property Index\" , \"type\" : \"integer\" }, \"a\" : { \"title\" : \"Animated\" , \"description\" : \"Whether the property is animated\" , \"$ref\" : \"#/$defs/helpers/int-boolean\" , \"default\" : 0 }, \"x\" : { \"title\" : \"Expression\" , \"type\" : \"string\" }, \"l\" : { \"title\" : \"Length\" , \"description\" : \"Number of components in the value arrays.\\nIf present values will be truncated or expanded to match this length when accessed from expressions.\" , \"type\" : \"integer\" } } }, { \"if\" : { \"properties\" : { \"a\" : { \"const\" : 1 } } }, \"then\" : { \"properties\" : { \"k\" : { \"type\" : \"array\" , \"title\" : \"Animated Value\" , \"description\" : \"Array of keyframes\" , \"items\" : { \"$ref\" : \"#/$defs/animated-properties/position-keyframe\" } } } }, \"else\" : { \"properties\" : { \"k\" : { \"title\" : \"Static Value\" , \"type\" : \"array\" , \"items\" : { \"type\" : \"number\" } } } } } ], \"required\" : [ \"k\" ] }, \"animated-property\" : { \"type\" : \"object\" , \"title\" : \"Animated Property\" , \"description\" : \"An animatable property that holds an array of numbers\" , \"allOf\" : [ { \"properties\" : { \"ix\" : { \"title\" : \"Property Index\" , \"type\" : \"integer\" }, \"a\" : { \"title\" : \"Animated\" , \"description\" : \"Whether the property is animated\" , \"$ref\" : \"#/$defs/helpers/int-boolean\" , \"default\" : 0 }, \"x\" : { \"title\" : \"Expression\" , \"type\" : \"string\" }, \"sid\" : { \"title\" : \"Slot ID\" , \"description\" : \"One of the ID in the file's slots\" , \"type\" : \"string\" } } }, { \"if\" : { \"properties\" : { \"a\" : { \"const\" : 1 } } }, \"then\" : { \"properties\" : { \"k\" : { \"type\" : \"array\" , \"title\" : \"Animated Value\" , \"description\" : \"Array of keyframes\" , \"items\" : { \"$ref\" : \"#/$defs/animated-properties/keyframe\" } } } } } ], \"required\" : [ \"k\" ] }, \"shape-keyframe\" : { \"type\" : \"object\" , \"title\" : \"Shape Keyframe\" , \"description\" : \"Keyframe holding Bezier objects\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/animated-properties/keyframe-base\" }, { \"type\" : \"object\" , \"properties\" : { \"s\" : { \"title\" : \"Start\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/helpers/bezier\" } } } } ] }, \"position-keyframe\" : { \"type\" : \"object\" , \"title\" : \"Position Keyframe\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/animated-properties/keyframe\" }, { \"properties\" : { \"ti\" : { \"title\" : \"Value In Tangent\" , \"description\" : \"Tangent for values (eg: moving position around a curved path)\" , \"type\" : \"array\" , \"items\" : { \"type\" : \"number\" } }, \"to\" : { \"title\" : \"Value Out Tangent\" , \"description\" : \"Tangent for values (eg: moving position around a curved path)\" , \"type\" : \"array\" , \"items\" : { \"type\" : \"number\" } } } } ] }, \"multi-dimensional\" : { \"type\" : \"object\" , \"title\" : \"Multi Dimensional\" , \"description\" : \"An animatable property that holds an array of numbers\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/animated-properties/animated-property\" }, { \"if\" : { \"properties\" : { \"a\" : { \"const\" : 0 } } }, \"then\" : { \"properties\" : { \"k\" : { \"title\" : \"Static value\" , \"type\" : \"array\" , \"items\" : { \"type\" : \"number\" } } } }, \"properties\" : { \"l\" : { \"title\" : \"Length\" , \"description\" : \"Number of components in the value arrays.\\nIf present values will be truncated or expanded to match this length when accessed from expressions.\" , \"type\" : \"integer\" } } } ] }, \"keyframe-base\" : { \"type\" : \"object\" , \"title\" : \"Base Keyframe\" , \"description\" : \"A Keyframes specifies the value at a specific time and the interpolation function to reach the next keyframe.\" , \"allOf\" : [ { \"properties\" : { \"t\" : { \"title\" : \"Time\" , \"type\" : \"number\" , \"default\" : 0 }, \"h\" : { \"title\" : \"Hold\" , \"$ref\" : \"#/$defs/helpers/int-boolean\" , \"default\" : 0 } } }, { \"if\" : { \"oneOf\" : [ { \"properties\" : { \"h\" : { \"const\" : 0 } } }, { \"not\" : { \"required\" : [ \"h\" ] } } ] }, \"then\" : { \"properties\" : { \"i\" : { \"title\" : \"In Tangent\" , \"description\" : \"Easing tangent going into the next keyframe\" , \"$ref\" : \"#/$defs/animated-properties/keyframe-bezier-handle\" }, \"o\" : { \"title\" : \"Out Tangent\" , \"description\" : \"Easing tangent leaving the current keyframe\" , \"$ref\" : \"#/$defs/animated-properties/keyframe-bezier-handle\" } } } } ], \"required\" : [ \"t\" , \"s\" ] }, \"shape-property\" : { \"type\" : \"object\" , \"title\" : \"Shape Property\" , \"description\" : \"An animatable property that holds a Bezier\" , \"allOf\" : [ { \"properties\" : { \"ix\" : { \"title\" : \"Property Index\" , \"type\" : \"integer\" }, \"a\" : { \"title\" : \"Animated\" , \"description\" : \"Whether the property is animated\" , \"$ref\" : \"#/$defs/helpers/int-boolean\" , \"default\" : 0 }, \"x\" : { \"title\" : \"Expression\" , \"type\" : \"string\" } } }, { \"if\" : { \"properties\" : { \"a\" : { \"const\" : 1 } } }, \"then\" : { \"properties\" : { \"k\" : { \"type\" : \"array\" , \"title\" : \"Animated Value\" , \"description\" : \"Array of keyframes\" , \"items\" : { \"$ref\" : \"#/$defs/animated-properties/shape-keyframe\" } } } }, \"else\" : { \"properties\" : { \"k\" : { \"$ref\" : \"#/$defs/helpers/bezier\" , \"title\" : \"Static Value\" } } } } ], \"required\" : [ \"k\" ] }, \"gradient-colors\" : { \"type\" : \"object\" , \"title\" : \"Gradient Colors\" , \"description\" : \"Represents colors and offsets in a gradient\\n\\nColors are represented as a flat list interleaving offsets and color components in weird ways\\nThere are two possible layouts:\\n\\nWithout alpha, the colors are a sequence of offset, r, g, b\\n\\nWith alpha, same as above but at the end of the list there is a sequence of offset, alpha\" , \"properties\" : { \"k\" : { \"title\" : \"Colors\" , \"$ref\" : \"#/$defs/animated-properties/multi-dimensional\" }, \"p\" : { \"title\" : \"Count\" , \"description\" : \"Number of colors in k \" , \"type\" : \"integer\" , \"default\" : 0 } }, \"required\" : [ \"p\" , \"k\" ] }, \"keyframe\" : { \"type\" : \"object\" , \"title\" : \"Keyframe\" , \"description\" : \"A Keyframes specifies the value at a specific time and the interpolation function to reach the next keyframe.\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/animated-properties/keyframe-base\" }, { \"properties\" : { \"s\" : { \"title\" : \"Value\" , \"description\" : \"Value at this keyframe. Note the if the property is a scalar, keyframe values are still represented as arrays\" , \"type\" : \"array\" , \"items\" : { \"type\" : \"number\" } }, \"e\" : { \"title\" : \"End value\" , \"description\" : \"Value at the end of the keyframe, note that this is deprecated and you should use s from the next keyframe to get this value\" , \"deprecated\" : true , \"type\" : \"array\" , \"items\" : { \"type\" : \"number\" } } } }, { \"if\" : { \"oneOf\" : [ { \"properties\" : { \"h\" : { \"const\" : 0 } } }, { \"not\" : { \"required\" : [ \"h\" ] } } ] }, \"then\" : { \"properties\" : { \"i\" : { \"title\" : \"In Tangent\" , \"description\" : \"Easing tangent going into the next keyframe\" , \"$ref\" : \"#/$defs/animated-properties/keyframe-bezier-handle\" }, \"o\" : { \"title\" : \"Out Tangent\" , \"description\" : \"Easing tangent leaving the current keyframe\" , \"$ref\" : \"#/$defs/animated-properties/keyframe-bezier-handle\" } } } } ], \"required\" : [ \"t\" , \"s\" ] }, \"split-vector\" : { \"type\" : \"object\" , \"title\" : \"Split Vector\" , \"description\" : \"An animatable property that is split into individually anaimated components\" , \"properties\" : { \"s\" : { \"title\" : \"Split\" , \"type\" : \"boolean\" , \"const\" : true }, \"x\" : { \"title\" : \"X\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"y\" : { \"title\" : \"Y\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"z\" : { \"title\" : \"Z\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"s\" , \"x\" , \"y\" ] }, \"color-value\" : { \"type\" : \"object\" , \"title\" : \"Color Value\" , \"description\" : \"An animatable property that holds a Color\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/animated-properties/animated-property\" }, { \"if\" : { \"properties\" : { \"a\" : { \"const\" : 0 } } }, \"then\" : { \"properties\" : { \"k\" : { \"title\" : \"Static value\" , \"$ref\" : \"#/$defs/helpers/color\" } } } } ] } }, \"animation\" : { \"composition\" : { \"type\" : \"object\" , \"title\" : \"Composition\" , \"description\" : \"Base class for layer holders\" , \"properties\" : { \"layers\" : { \"title\" : \"Layers\" , \"type\" : \"array\" , \"items\" : { \"oneOf\" : [ { \"$ref\" : \"#/$defs/layers/precomposition-layer\" }, { \"$ref\" : \"#/$defs/layers/solid-color-layer\" }, { \"$ref\" : \"#/$defs/layers/image-layer\" }, { \"$ref\" : \"#/$defs/layers/null-layer\" }, { \"$ref\" : \"#/$defs/layers/shape-layer\" }, { \"$ref\" : \"#/$defs/layers/text-layer\" }, { \"$ref\" : \"#/$defs/layers/audio-layer\" }, { \"$ref\" : \"#/$defs/layers/camera-layer\" }, { \"$ref\" : \"#/$defs/layers/data-layer\" } ] } } }, \"required\" : [ \"layers\" ] }, \"animation\" : { \"type\" : \"object\" , \"title\" : \"Animation\" , \"description\" : \"Top level object, describing the animation\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/visual-object\" }, { \"type\" : \"object\" , \"properties\" : { \"v\" : { \"title\" : \"Version\" , \"type\" : \"string\" , \"default\" : \"5.5.2\" }, \"fr\" : { \"title\" : \"Framerate\" , \"description\" : \"Framerate in frames per second\" , \"type\" : \"number\" , \"default\" : 60 }, \"ip\" : { \"title\" : \"In Point\" , \"description\" : \"\\\"In Point\\\", which frame the animation starts at (usually 0)\" , \"type\" : \"number\" , \"default\" : 0 }, \"op\" : { \"title\" : \"Out Point\" , \"description\" : \"\\\"Out Point\\\", which frame the animation stops/loops at, which makes this the duration in frames when ip is 0\" , \"type\" : \"number\" , \"default\" : 60 }, \"w\" : { \"title\" : \"Width\" , \"description\" : \"Width of the animation\" , \"type\" : \"integer\" , \"default\" : 512 }, \"h\" : { \"title\" : \"Height\" , \"description\" : \"Height of the animation\" , \"type\" : \"integer\" , \"default\" : 512 }, \"ddd\" : { \"title\" : \"Threedimensional\" , \"$ref\" : \"#/$defs/helpers/int-boolean\" , \"default\" : 0 , \"description\" : \"Whether the animation has 3D layers\" }, \"assets\" : { \"title\" : \"Assets\" , \"type\" : \"array\" , \"description\" : \"List of assets that can be referenced by layers\" , \"items\" : { \"oneOf\" : [ { \"$ref\" : \"#/$defs/assets/image\" }, { \"$ref\" : \"#/$defs/assets/precomposition\" }, { \"$ref\" : \"#/$defs/assets/sound\" }, { \"$ref\" : \"#/$defs/assets/data-source\" } ] } }, \"comps\" : { \"title\" : \"Extra Compositions\" , \"type\" : \"array\" , \"description\" : \"List of Extra compositions not referenced by anything\" , \"items\" : { \"$ref\" : \"#/$defs/assets/precomposition\" } }, \"fonts\" : { \"title\" : \"Fonts\" , \"$ref\" : \"#/$defs/text/font-list\" }, \"chars\" : { \"title\" : \"Characters\" , \"description\" : \"Data defining text characters as lottie shapes. If present a player might only render characters defined here and nothing else.\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/text/character-data\" } }, \"meta\" : { \"title\" : \"Metadata\" , \"description\" : \"Document metadata\" , \"$ref\" : \"#/$defs/animation/metadata\" }, \"metadata\" : { \"title\" : \"User Metadata\" , \"$ref\" : \"#/$defs/animation/user-metadata\" }, \"markers\" : { \"title\" : \"Markers\" , \"description\" : \"Markers defining named sections of the composition.\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/helpers/marker\" } }, \"mb\" : { \"title\" : \"Motion Blur\" , \"$ref\" : \"#/$defs/animation/motion-blur\" }, \"slots\" : { \"title\" : \"Slots\" , \"description\" : \"Available property overrides\" , \"type\" : \"object\" , \"patternProperties\" : { \".*\" : { \"p\" : { \"anyOf\" : [ { \"$ref\" : \"#/$defs/animated-properties/multi-dimensional\" }, { \"$ref\" : \"#/$defs/animated-properties/color-value\" }, { \"$ref\" : \"#/$defs/animated-properties/position\" }, { \"$ref\" : \"#/$defs/animated-properties/shape-property\" }, { \"$ref\" : \"#/$defs/animated-properties/value\" }, { \"$ref\" : \"#/$defs/assets/image\" }, { \"$ref\" : \"#/$defs/text/animated-text-document\" } ] }, \"required\" : [ \"p\" ] } } } }, \"required\" : [ \"w\" , \"h\" , \"fr\" , \"layers\" , \"op\" , \"ip\" ] }, { \"$ref\" : \"#/$defs/animation/composition\" } ] }, \"motion-blur\" : { \"type\" : \"object\" , \"title\" : \"Motion Blur\" , \"description\" : \"Motion blur settings\" , \"properties\" : { \"sa\" : { \"title\" : \"Shutter Angle\" , \"description\" : \"Angle in degrees\" , \"type\" : \"number\" }, \"sp\" : { \"title\" : \"Shutter Phase\" , \"description\" : \"Angle in degrees\" , \"type\" : \"number\" }, \"spf\" : { \"title\" : \"Samples per Frame\" , \"type\" : \"number\" }, \"asl\" : { \"title\" : \"Adaptive Sample Limit\" , \"type\" : \"number\" } } }, \"metadata\" : { \"type\" : \"object\" , \"title\" : \"Metadata\" , \"description\" : \"Document metadata\" , \"properties\" : { \"a\" : { \"title\" : \"Author\" , \"type\" : \"string\" }, \"d\" : { \"title\" : \"Description\" , \"type\" : \"string\" }, \"tc\" : { \"title\" : \"Theme Color\" , \"type\" : \"string\" }, \"g\" : { \"title\" : \"Generator\" , \"description\" : \"Software used to generate the file\" , \"type\" : \"string\" } }, \"anyOf\" : [ { \"properties\" : { \"k\" : { \"title\" : \"Keywords\" , \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" } } } }, { \"properties\" : { \"k\" : { \"title\" : \"Keywords\" , \"type\" : \"string\" } } } ] }, \"user-metadata\" : { \"type\" : \"object\" , \"title\" : \"User Metadata\" , \"description\" : \"User-defined metadata\" , \"properties\" : { \"filename\" : { \"title\" : \"Filename\" , \"type\" : \"string\" }, \"customProps\" : { \"title\" : \"Custom Properties\" , \"type\" : \"object\" } } } }, \"assets\" : { \"image\" : { \"type\" : \"object\" , \"title\" : \"Image\" , \"description\" : \"External image\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/assets/file-asset\" }, { \"type\" : \"object\" , \"properties\" : { \"w\" : { \"title\" : \"Width\" , \"description\" : \"Width of the image\" , \"type\" : \"number\" , \"default\" : 0 }, \"h\" : { \"title\" : \"Height\" , \"description\" : \"Height of the image\" , \"type\" : \"number\" , \"default\" : 0 }, \"t\" : { \"title\" : \"Type\" , \"description\" : \"Marks as part of an image sequence if present\" , \"type\" : \"string\" , \"const\" : \"seq\" }, \"sid\" : { \"title\" : \"Slot ID\" , \"description\" : \"One of the ID in the file's slots\" , \"type\" : \"string\" } }, \"required\" : [ \"p\" ] } ] }, \"data-source\" : { \"type\" : \"object\" , \"title\" : \"Data source\" , \"description\" : \"External data source, usually a JSON file\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/assets/file-asset\" }, { \"type\" : \"object\" , \"properties\" : { \"t\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 3 } }, \"required\" : [ \"t\" ] } ] }, \"asset\" : { \"type\" : \"object\" , \"title\" : \"Asset\" , \"description\" : \"\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"id\" : { \"title\" : \"ID\" , \"description\" : \"Unique identifier used by layers when referencing this asset\" , \"type\" : \"string\" , \"default\" : \"\" }, \"nm\" : { \"title\" : \"Name\" , \"description\" : \"Human readable name\" , \"type\" : \"string\" } }, \"required\" : [ \"id\" ] } ] }, \"file-asset\" : { \"type\" : \"object\" , \"title\" : \"File Asset\" , \"description\" : \"Asset referencing a file\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/assets/asset\" }, { \"type\" : \"object\" , \"properties\" : { \"u\" : { \"title\" : \"Path\" , \"description\" : \"Path to the directory containing a file\" , \"type\" : \"string\" , \"default\" : \"\" }, \"p\" : { \"title\" : \"File name\" , \"description\" : \"Filename or data url\" , \"type\" : \"string\" , \"default\" : \"\" }, \"e\" : { \"title\" : \"Embedded\" , \"description\" : \"Whether the file is embedded\" , \"$ref\" : \"#/$defs/helpers/int-boolean\" , \"default\" : 0 } }, \"required\" : [ \"p\" ] } ] }, \"precomposition\" : { \"type\" : \"object\" , \"title\" : \"Precomposition\" , \"description\" : \"Asset containing an animation that can be referenced by layers.\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/assets/asset\" }, { \"$ref\" : \"#/$defs/animation/composition\" }, { \"type\" : \"object\" , \"properties\" : { \"fr\" : { \"title\" : \"Framerate\" , \"description\" : \"Framerate in frames per second\" , \"type\" : \"number\" }, \"xt\" : { \"title\" : \"Extra\" , \"description\" : \"Extra composition\" , \"$ref\" : \"#/$defs/helpers/int-boolean\" , \"default\" : 0 } } } ] }, \"sound\" : { \"type\" : \"object\" , \"title\" : \"Sound\" , \"description\" : \"External sound\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/assets/file-asset\" } ] } }, \"constants\" : { \"fill-rule\" : { \"type\" : \"integer\" , \"title\" : \"Fill Rule\" , \"description\" : \"Rule used to handle multiple shapes rendered with the same fill object\" , \"oneOf\" : [ { \"title\" : \"Non Zero\" , \"description\" : \"Everything is colored (You can think of this as an OR)\" , \"const\" : 1 }, { \"title\" : \"Even Odd\" , \"description\" : \"Colored based on intersections and path direction, can be used to create \\\"holes\\\"\" , \"const\" : 2 } ] }, \"blend-mode\" : { \"type\" : \"integer\" , \"title\" : \"Blend Mode\" , \"description\" : \"Layer and shape blend mode\" , \"caniuse\" : \"blend-mode\" , \"oneOf\" : [ { \"title\" : \"Normal\" , \"const\" : 0 }, { \"title\" : \"Multiply\" , \"const\" : 1 }, { \"title\" : \"Screen\" , \"const\" : 2 }, { \"title\" : \"Overlay\" , \"const\" : 3 }, { \"title\" : \"Darken\" , \"const\" : 4 }, { \"title\" : \"Lighten\" , \"const\" : 5 }, { \"title\" : \"Color Dodge\" , \"const\" : 6 }, { \"title\" : \"Color Burn\" , \"const\" : 7 }, { \"title\" : \"Hard Light\" , \"const\" : 8 }, { \"title\" : \"Soft Light\" , \"const\" : 9 }, { \"title\" : \"Difference\" , \"const\" : 10 }, { \"title\" : \"Exclusion\" , \"const\" : 11 }, { \"title\" : \"Hue\" , \"const\" : 12 }, { \"title\" : \"Saturation\" , \"const\" : 13 }, { \"title\" : \"Color\" , \"const\" : 14 }, { \"title\" : \"Luminosity\" , \"const\" : 15 }, { \"title\" : \"Add\" , \"const\" : 16 }, { \"title\" : \"Hard Mix\" , \"const\" : 17 } ] }, \"text-grouping\" : { \"type\" : \"integer\" , \"title\" : \"Text Grouping\" , \"description\" : \"\" , \"oneOf\" : [ { \"title\" : \"Characters\" , \"const\" : 1 }, { \"title\" : \"Word\" , \"const\" : 2 }, { \"title\" : \"Line\" , \"const\" : 3 }, { \"title\" : \"All\" , \"const\" : 4 } ] }, \"trim-multiple-shapes\" : { \"type\" : \"integer\" , \"title\" : \"Trim Multiple Shapes\" , \"description\" : \"How to handle multiple shapes in trim path\" , \"oneOf\" : [ { \"title\" : \"Simultaneously\" , \"const\" : 1 }, { \"title\" : \"Individually\" , \"const\" : 2 } ] }, \"composite\" : { \"type\" : \"integer\" , \"title\" : \"Composite\" , \"description\" : \"How to stack copies in a repeater\" , \"oneOf\" : [ { \"title\" : \"Above\" , \"const\" : 1 }, { \"title\" : \"Below\" , \"const\" : 2 } ] }, \"stroke-dash-type\" : { \"type\" : \"string\" , \"title\" : \"Stroke Dash Type\" , \"description\" : \"Type of a dash item in a stroked line\" , \"oneOf\" : [ { \"title\" : \"Dash\" , \"const\" : \"d\" }, { \"title\" : \"Gap\" , \"const\" : \"g\" }, { \"title\" : \"Offset\" , \"const\" : \"o\" } ] }, \"text-range-units\" : { \"type\" : \"integer\" , \"title\" : \"Text Range Units\" , \"description\" : \"Unit type for a text selector\" , \"oneOf\" : [ { \"title\" : \"Percent\" , \"const\" : 1 }, { \"title\" : \"Index\" , \"const\" : 2 } ] }, \"line-cap\" : { \"type\" : \"integer\" , \"title\" : \"Line Cap\" , \"description\" : \"Style at the end of a stoked line\" , \"oneOf\" : [ { \"title\" : \"Butt\" , \"const\" : 1 }, { \"title\" : \"Round\" , \"const\" : 2 }, { \"title\" : \"Square\" , \"const\" : 3 } ] }, \"mask-mode\" : { \"type\" : \"string\" , \"title\" : \"Mask Mode\" , \"description\" : \"How masks interact with each other. See https://helpx.adobe.com/after-effects/using/alpha-channels-masks-mattes.html\" , \"oneOf\" : [ { \"title\" : \"None\" , \"const\" : \"n\" }, { \"title\" : \"Add\" , \"const\" : \"a\" }, { \"title\" : \"Subtract\" , \"const\" : \"s\" }, { \"title\" : \"Intersect\" , \"const\" : \"i\" }, { \"title\" : \"Lighten\" , \"const\" : \"l\" }, { \"title\" : \"Darken\" , \"const\" : \"d\" }, { \"title\" : \"Difference\" , \"const\" : \"f\" } ] }, \"gradient-type\" : { \"type\" : \"integer\" , \"title\" : \"Gradient Type\" , \"description\" : \"Type of a gradient\" , \"oneOf\" : [ { \"title\" : \"Linear\" , \"type\" : \"integer\" , \"const\" : 1 }, { \"title\" : \"Radial\" , \"type\" : \"integer\" , \"const\" : 2 } ] }, \"text-caps\" : { \"type\" : \"integer\" , \"title\" : \"Text Caps\" , \"oneOf\" : [ { \"title\" : \"Regular\" , \"const\" : 0 }, { \"title\" : \"All Caps\" , \"const\" : 1 }, { \"title\" : \"Small Caps\" , \"const\" : 2 } ], \"default\" : 0 }, \"text-justify\" : { \"type\" : \"integer\" , \"title\" : \"Text Justify\" , \"description\" : \"Text alignment / justification\" , \"oneOf\" : [ { \"title\" : \"Left\" , \"const\" : 0 }, { \"title\" : \"Right\" , \"const\" : 1 }, { \"title\" : \"Center\" , \"const\" : 2 }, { \"title\" : \"Justify with Last Line Left\" , \"const\" : 3 }, { \"title\" : \"Justify with Last Line Right\" , \"const\" : 4 }, { \"title\" : \"Justify with Last Line Center\" , \"const\" : 5 }, { \"title\" : \"Justify with Last Line Full\" , \"const\" : 6 } ] }, \"shape-direction\" : { \"type\" : \"integer\" , \"title\" : \"Shape Direction\" , \"description\" : \"Drawing direction of the shape curve, useful for trim path\" , \"oneOf\" : [ { \"title\" : \"Normal\" , \"description\" : \"Usually clockwise\" , \"const\" : 1 }, { \"title\" : \"Reversed\" , \"description\" : \"Usually counter clockwise\" , \"const\" : 3 } ] }, \"line-join\" : { \"type\" : \"integer\" , \"title\" : \"Line Join\" , \"description\" : \"Style at a sharp corner of a stoked line\" , \"oneOf\" : [ { \"title\" : \"Miter\" , \"const\" : 1 }, { \"title\" : \"Round\" , \"const\" : 2 }, { \"title\" : \"Bevel\" , \"const\" : 3 } ] }, \"matte-mode\" : { \"type\" : \"integer\" , \"title\" : \"Matte Mode\" , \"description\" : \"How a layer should mask another layer\" , \"oneOf\" : [ { \"title\" : \"Normal\" , \"const\" : 0 }, { \"title\" : \"Alpha\" , \"const\" : 1 }, { \"title\" : \"Inverted Alpha\" , \"const\" : 2 }, { \"title\" : \"Luma\" , \"const\" : 3 }, { \"title\" : \"Inverted Luma\" , \"const\" : 4 } ] }, \"text-based\" : { \"type\" : \"integer\" , \"title\" : \"Text Based\" , \"description\" : \"\" , \"oneOf\" : [ { \"title\" : \"Characters\" , \"const\" : 1 }, { \"title\" : \"Character Excluding Spaces\" , \"const\" : 2 }, { \"title\" : \"Words\" , \"const\" : 3 }, { \"title\" : \"Lines\" , \"const\" : 4 } ] }, \"font-path-origin\" : { \"type\" : \"integer\" , \"title\" : \"Font Path Origin\" , \"description\" : \"\" , \"oneOf\" : [ { \"title\" : \"Local\" , \"const\" : 0 }, { \"title\" : \"Css Url\" , \"const\" : 1 }, { \"title\" : \"Script Url\" , \"const\" : 2 }, { \"title\" : \"Font Url\" , \"const\" : 3 } ] }, \"text-shape\" : { \"type\" : \"integer\" , \"title\" : \"Text Shape\" , \"description\" : \"Defines the function used to determine the interpolating factor on a text range selector.\" , \"oneOf\" : [ { \"title\" : \"Square\" , \"const\" : 1 }, { \"title\" : \"Ramp Up\" , \"const\" : 2 }, { \"title\" : \"Ramp Down\" , \"const\" : 3 }, { \"title\" : \"Triangle\" , \"const\" : 4 }, { \"title\" : \"Round\" , \"const\" : 5 }, { \"title\" : \"Smooth\" , \"const\" : 6 } ] }, \"merge-mode\" : { \"type\" : \"integer\" , \"title\" : \"Merge Mode\" , \"description\" : \"Boolean operation on shapes\" , \"oneOf\" : [ { \"title\" : \"Normal\" , \"const\" : 1 }, { \"title\" : \"Add\" , \"const\" : 2 }, { \"title\" : \"Subtract\" , \"const\" : 3 }, { \"title\" : \"Intersect\" , \"const\" : 4 }, { \"title\" : \"Exclude Intersections\" , \"const\" : 5 } ] }, \"star-type\" : { \"type\" : \"integer\" , \"title\" : \"Star Type\" , \"description\" : \"Star or Polygon\" , \"oneOf\" : [ { \"title\" : \"Star\" , \"const\" : 1 }, { \"title\" : \"Polygon\" , \"const\" : 2 } ] } }, \"effect-values\" : { \"angle\" : { \"type\" : \"object\" , \"title\" : \"Effect Value Angle\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effect-values/effect-value\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 1 }, \"v\" : { \"title\" : \"Value\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" ] } ] }, \"ignored\" : { \"type\" : \"object\" , \"title\" : \"Ignored Value\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effect-values/effect-value\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 6 }, \"v\" : { \"title\" : \"Value\" , \"type\" : \"number\" , \"default\" : 0 } }, \"required\" : [ \"ty\" ] } ] }, \"drop-down\" : { \"type\" : \"object\" , \"title\" : \"Effect Value Drop Down\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effect-values/effect-value\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 7 }, \"v\" : { \"title\" : \"Value\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" ] } ] }, \"checkbox\" : { \"type\" : \"object\" , \"title\" : \"Effect Value Checkbox\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effect-values/effect-value\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 4 }, \"v\" : { \"title\" : \"Value\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" ] } ] }, \"no-value\" : { \"type\" : \"object\" , \"title\" : \"Effect No Value\" , \"description\" : \"\" }, \"slider\" : { \"type\" : \"object\" , \"title\" : \"Effect Value Slider\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effect-values/effect-value\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 0 }, \"v\" : { \"title\" : \"Value\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" ] } ] }, \"effect-value\" : { \"type\" : \"object\" , \"title\" : \"Effect Value\" , \"description\" : \"Value for an effect\" , \"caniuse\" : \"effects\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/visual-object\" }, { \"type\" : \"object\" , \"properties\" : { \"ix\" : { \"title\" : \"Effect Index\" , \"type\" : \"integer\" }, \"mn\" : { \"title\" : \"Match Name\" , \"type\" : \"string\" }, \"nm\" : { \"title\" : \"Name\" , \"type\" : \"string\" }, \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" } }, \"required\" : [] } ] }, \"point\" : { \"type\" : \"object\" , \"title\" : \"Effect Value Point\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effect-values/effect-value\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 3 }, \"v\" : { \"title\" : \"Value\" , \"$ref\" : \"#/$defs/animated-properties/multi-dimensional\" } }, \"required\" : [ \"ty\" ] } ] }, \"color\" : { \"type\" : \"object\" , \"title\" : \"Effect Value Color\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effect-values/effect-value\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 2 }, \"v\" : { \"title\" : \"Value\" , \"$ref\" : \"#/$defs/animated-properties/color-value\" } }, \"required\" : [ \"ty\" ] } ] }, \"layer\" : { \"type\" : \"object\" , \"title\" : \"Effect Value Layer\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effect-values/effect-value\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 10 }, \"v\" : { \"title\" : \"Value\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" ] } ] } }, \"effects\" : { \"radial-wipe-effect\" : { \"type\" : \"object\" , \"title\" : \"Radial Wipe\" , \"caniuse\" : \"effect-radial-wipe\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 26 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"Completion\" , \"description\" : \"Between 0 and 100\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Start Angle\" , \"$ref\" : \"#/$defs/effect-values/angle\" }, { \"title\" : \"Wipe Center\" , \"$ref\" : \"#/$defs/effect-values/point\" }, { \"title\" : \"Wipe\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Feather\" , \"$ref\" : \"#/$defs/effect-values/slider\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"puppet-effect\" : { \"type\" : \"object\" , \"title\" : \"Puppet Effect\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 34 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"Puppet Engine\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Mesh Rotation Refinement\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"On Transparent\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"03\" , \"$ref\" : \"#/$defs/effect-values/no-value\" } ] } }, \"required\" : [ \"ty\" , \"ef\" ] } ] }, \"fill-effect\" : { \"type\" : \"object\" , \"title\" : \"Fill Effect\" , \"description\" : \"Replaces the whole layer with the given color\" , \"caniuse\" : \"effect-fill\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 21 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"00\" , \"$ref\" : \"#/$defs/effect-values/point\" }, { \"title\" : \"01\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"color\" , \"$ref\" : \"#/$defs/effect-values/color\" }, { \"title\" : \"03\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"04\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"05\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"opacity\" , \"description\" : \"Opacity in [0, 1]\" , \"$ref\" : \"#/$defs/effect-values/slider\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"effect\" : { \"type\" : \"object\" , \"title\" : \"Effect\" , \"description\" : \"Layer effect\" , \"caniuse\" : \"effects\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/visual-object\" }, { \"type\" : \"object\" , \"properties\" : { \"ef\" : { \"title\" : \"Effect Values\" , \"type\" : \"array\" , \"items\" : { \"oneOf\" : [ { \"$ref\" : \"#/$defs/effect-values/no-value\" }, { \"$ref\" : \"#/$defs/effect-values/angle\" }, { \"$ref\" : \"#/$defs/effect-values/checkbox\" }, { \"$ref\" : \"#/$defs/effect-values/color\" }, { \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"$ref\" : \"#/$defs/effect-values/ignored\" }, { \"$ref\" : \"#/$defs/effect-values/layer\" }, { \"$ref\" : \"#/$defs/effect-values/point\" }, { \"$ref\" : \"#/$defs/effect-values/slider\" } ] } }, \"np\" : { \"title\" : \"Property Count\" , \"description\" : \"Number of values in ef \" , \"type\" : \"integer\" }, \"ix\" : { \"title\" : \"Effect Index\" , \"type\" : \"integer\" }, \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Effect type\" , \"type\" : \"integer\" }, \"en\" : { \"title\" : \"Enabled\" , \"$ref\" : \"#/$defs/helpers/int-boolean\" , \"default\" : 1 } }, \"required\" : [ \"ty\" , \"ef\" ] } ] }, \"pro-levels-effect\" : { \"type\" : \"object\" , \"title\" : \"Pro Levels Effect\" , \"description\" : \"\" , \"caniuse\" : \"effect-color-levels-individual-controls\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 24 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"00\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"01\" , \"$ref\" : \"#/$defs/effect-values/no-value\" }, { \"title\" : \"02\" , \"$ref\" : \"#/$defs/effect-values/no-value\" }, { \"title\" : \"comp_inblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"comp_inwhite\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"comp_gamma\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"comp_outblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"comp_outwhite\" , \"$ref\" : \"#/$defs/effect-values/no-value\" }, { \"title\" : \"08\" , \"$ref\" : \"#/$defs/effect-values/no-value\" }, { \"title\" : \"09\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"r_inblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"r_inwhite\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"r_gamma\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"r_outblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"r_outwhite\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"15\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"16\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"g_inblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"g_inwhite\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"g_gamma\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"g_outblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"g_outwhite\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"22\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"23\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"b_inblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"b_inwhite\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"b_gamma\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"b_outblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"b_outwhite\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"29\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"a_inblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"a_inwhite\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"a_gamma\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"a_outblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"a_outwhite\" , \"$ref\" : \"#/$defs/effect-values/no-value\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"tritone-effect\" : { \"type\" : \"object\" , \"title\" : \"Tritone Effect\" , \"description\" : \"Maps layers colors based on bright/mid/dark colors\" , \"caniuse\" : \"effect-tritone\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 23 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"bright\" , \"$ref\" : \"#/$defs/effect-values/color\" }, { \"title\" : \"mid\" , \"$ref\" : \"#/$defs/effect-values/color\" }, { \"title\" : \"dark\" , \"$ref\" : \"#/$defs/effect-values/color\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"stroke-effect\" : { \"type\" : \"object\" , \"title\" : \"Stroke Effect\" , \"description\" : \"\" , \"caniuse\" : \"effect-stroke\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 22 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"00\" , \"$ref\" : \"#/$defs/effect-values/color\" }, { \"title\" : \"01\" , \"$ref\" : \"#/$defs/effect-values/checkbox\" }, { \"title\" : \"02\" , \"$ref\" : \"#/$defs/effect-values/checkbox\" }, { \"title\" : \"color\" , \"$ref\" : \"#/$defs/effect-values/color\" }, { \"title\" : \"04\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"05\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"06\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"07\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"08\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"09\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"type\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"custom-effect\" : { \"type\" : \"object\" , \"title\" : \"Custom Effect\" , \"description\" : \"Some lottie files use ty = 5 for many different effects\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 5 } }, \"required\" : [ \"ty\" ] } ] }, \"mesh-warp-effect\" : { \"type\" : \"object\" , \"title\" : \"Mesh Warp Effect\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 31 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"Rows\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Columns\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Quality\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"03\" , \"$ref\" : \"#/$defs/effect-values/no-value\" } ] } }, \"required\" : [ \"ty\" , \"ef\" ] } ] }, \"spherize-effect\" : { \"type\" : \"object\" , \"title\" : \"Spherize Effect\" , \"description\" : \"\" , \"caniuse\" : \"effect-cc-sphere\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 33 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"radius\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"center\" , \"$ref\" : \"#/$defs/effect-values/point\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"drop-shadow-effect\" : { \"type\" : \"object\" , \"title\" : \"Drop Shadow Effect\" , \"description\" : \"Adds a shadow to the layer\" , \"caniuse\" : \"effect-drop-shadow\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 25 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"color\" , \"$ref\" : \"#/$defs/effect-values/color\" }, { \"title\" : \"opacity\" , \"description\" : \"Opacity between 0 and 255\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"angle\" , \"$ref\" : \"#/$defs/effect-values/angle\" }, { \"title\" : \"distance\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"blur\" , \"$ref\" : \"#/$defs/effect-values/slider\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"tint-effect\" : { \"type\" : \"object\" , \"title\" : \"Tint Effect\" , \"description\" : \"Colorizes the layer\" , \"caniuse\" : \"effect-tint\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 20 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"Black Color\" , \"description\" : \"Tint of the darker parts of the layer\" , \"$ref\" : \"#/$defs/effect-values/color\" }, { \"title\" : \"White Color\" , \"description\" : \"Tint of the lighter parts of the layer\" , \"$ref\" : \"#/$defs/effect-values/color\" }, { \"title\" : \"Intensity\" , \"description\" : \"Intensity of the effect, 0 means the layer is unchanged. 100 means full effect\" , \"$ref\" : \"#/$defs/effect-values/slider\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"displacement-map-effect\" : { \"type\" : \"object\" , \"title\" : \"Displacement Map Effect\" , \"description\" : \"\" , \"caniuse\" : \"effect-displacement-map\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 27 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"Displacement Map Layer\" , \"$ref\" : \"#/$defs/effect-values/layer\" }, { \"title\" : \"Use For Horizontal Displacement\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Max Horizontal Displacement\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Use For Vertical Displacement\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Max Vertical Displacement\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Displacement Map Behavior\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Edge Behavior\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Expand Output\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" } ] } }, \"required\" : [ \"ty\" , \"ef\" ] } ] }, \"matte3-effect\" : { \"type\" : \"object\" , \"title\" : \"Set Matte Effect\" , \"description\" : \"Uses a layer as a mask\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 28 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"Layer\" , \"description\" : \"Use this layer as a mask\" , \"$ref\" : \"#/$defs/effect-values/layer\" }, { \"title\" : \"Channel\" , \"description\" : \"Channel to use as a mask:\\n1 - Red\\n2 - Green\\n3 - Blue\\n4 - Alpha\\n5 - Luminance\\n6 - Hue\\n7 - Lightness\\n8 - Saturation\\n9 - Full\\n10 - Off\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Invert\" , \"description\" : \"Use 0 as opaque value when true\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Stretch To Fit\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Show Mask\" , \"description\" : \"If false, the mask layer won't be shown\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Premultiply Mask\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"wavy-effect\" : { \"type\" : \"object\" , \"title\" : \"Wavy Effect\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 32 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"Radius\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Center\" , \"$ref\" : \"#/$defs/effect-values/point\" }, { \"title\" : \"Conversion type\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Speed\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Width\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Height\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Phase\" , \"$ref\" : \"#/$defs/effect-values/slider\" } ] } }, \"required\" : [ \"ty\" , \"ef\" ] } ] }, \"twirl-effect\" : { \"type\" : \"object\" , \"title\" : \"Twirl Effect\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 30 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"Angle\" , \"$ref\" : \"#/$defs/effect-values/angle\" }, { \"title\" : \"Radius\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Center\" , \"$ref\" : \"#/$defs/effect-values/point\" } ] } }, \"required\" : [ \"ty\" , \"ef\" ] } ] }, \"gaussian-blur-effect\" : { \"type\" : \"object\" , \"title\" : \"Gaussian Blur Effect\" , \"description\" : \"Gaussian blur\" , \"caniuse\" : \"effect-gaussian-blur\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 29 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"sigma\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"direction\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"wrap\" , \"$ref\" : \"#/$defs/effect-values/checkbox\" } ] } }, \"required\" : [ \"ty\" ] } ] } }, \"helpers\" : { \"mask\" : { \"type\" : \"object\" , \"title\" : \"Mask\" , \"caniuse\" : \"mask\" , \"description\" : \"Bezier shape used to mask/clip a layer\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/visual-object\" }, { \"type\" : \"object\" , \"properties\" : { \"inv\" : { \"title\" : \"Inverted\" , \"caniuse\" : \"mask-inverted\" , \"type\" : \"boolean\" , \"default\" : false }, \"pt\" : { \"title\" : \"Shape\" , \"$ref\" : \"#/$defs/animated-properties/shape-property\" }, \"o\" : { \"title\" : \"Opacity\" , \"caniuse\" : \"mask-opacity\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"mode\" : { \"title\" : \"Mode\" , \"caniuse\" : \"mask-modes\" , \"$ref\" : \"#/$defs/constants/mask-mode\" , \"default\" : \"i\" }, \"x\" : { \"title\" : \"Expand\" , \"caniuse\" : \"mask-expansion\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [] } ] }, \"marker\" : { \"type\" : \"object\" , \"title\" : \"Marker\" , \"description\" : \"Defines named portions of the composition.\" , \"properties\" : { \"cm\" : { \"title\" : \"Comment\" , \"type\" : \"string\" }, \"tm\" : { \"title\" : \"Time\" , \"type\" : \"number\" }, \"dr\" : { \"title\" : \"Duration\" , \"type\" : \"number\" } } }, \"bezier\" : { \"type\" : \"object\" , \"title\" : \"Bezier\" , \"description\" : \"Single bezier curve\" , \"properties\" : { \"c\" : { \"title\" : \"Closed\" , \"type\" : \"boolean\" , \"default\" : false }, \"i\" : { \"title\" : \"In Tangents\" , \"type\" : \"array\" , \"description\" : \"Array of points, each point is an array of coordinates.\\nThese points are along the in tangents relative to the corresponding v .\" , \"items\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"number\" , \"default\" : [] } } }, \"o\" : { \"title\" : \"Out Tangents\" , \"type\" : \"array\" , \"description\" : \"Array of points, each point is an array of coordinates.\\nThese points are along the out tangents relative to the corresponding v .\" , \"items\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"number\" , \"default\" : [] } } }, \"v\" : { \"title\" : \"Vertices\" , \"description\" : \"Array of points, each point is an array of coordinates.\\nThese points are along the bezier path\" , \"type\" : \"array\" , \"items\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"number\" , \"default\" : [] } } } }, \"required\" : [ \"i\" , \"v\" , \"o\" ] }, \"visual-object\" : { \"type\" : \"object\" , \"title\" : \"Visual Object\" , \"description\" : \"\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"nm\" : { \"title\" : \"Name\" , \"description\" : \"Name, as seen from editors and the like\" , \"type\" : \"string\" }, \"mn\" : { \"title\" : \"Match Name\" , \"description\" : \"Match name, used in expressions\" , \"type\" : \"string\" } }, \"required\" : [] } ] }, \"transform\" : { \"type\" : \"object\" , \"title\" : \"Transform\" , \"description\" : \"Layer transform\" , \"allOf\" : [ { \"properties\" : { \"a\" : { \"title\" : \"Anchor Point\" , \"caniuse\" : \"transform-anchor-point\" , \"description\" : \"Anchor point: a position (relative to its parent) around which transformations are applied (ie: center for rotation / scale)\" , \"$ref\" : \"#/$defs/animated-properties/position\" }, \"s\" : { \"title\" : \"Scale\" , \"caniuse\" : \"transform-scale\" , \"description\" : \"Scale factor, [100, 100] for no scaling\" , \"$ref\" : \"#/$defs/animated-properties/multi-dimensional\" }, \"o\" : { \"title\" : \"Opacity\" , \"caniuse\" : \"transform-opacity\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"sk\" : { \"title\" : \"Skew\" , \"caniuse\" : \"transform-skew\" , \"description\" : \"Skew amount as an angle in degrees\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"sa\" : { \"title\" : \"Skew Axis\" , \"caniuse\" : \"transform-skew\" , \"description\" : \"Direction along which skew is applied, in degrees ( 0 skews along the X axis, 90 along the Y axis)\" , \"$ref\" : \"#/$defs/animated-properties/value\" } } }, { \"anyOf\" : [ { \"oneOf\" : [ { \"properties\" : { \"p\" : { \"title\" : \"Position\" , \"caniuse\" : \"transform-position\" , \"description\" : \"Position / Translation\" , \"$ref\" : \"#/$defs/animated-properties/position\" } } }, { \"properties\" : { \"p\" : { \"title\" : \"Position\" , \"description\" : \"Position / Translation with split components\" , \"$ref\" : \"#/$defs/animated-properties/split-vector\" } } } ] }, { \"oneOf\" : [ { \"properties\" : { \"r\" : { \"title\" : \"Rotation\" , \"caniuse\" : \"transform-rotation\" , \"description\" : \"Rotation in degrees, clockwise\" , \"$ref\" : \"#/$defs/animated-properties/value\" } } }, { \"properties\" : { \"rx\" : { \"title\" : \"X Rotation\" , \"description\" : \"Split rotation component\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"ry\" : { \"title\" : \"Y Rotation\" , \"description\" : \"Split rotation component\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"rz\" : { \"title\" : \"Z Rotation\" , \"description\" : \"Split rotation component, equivalent to r when not split\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"or\" : { \"title\" : \"Orientation\" , \"$ref\" : \"#/$defs/animated-properties/multi-dimensional\" } } } ] } ] } ] }, \"int-boolean\" : { \"type\" : \"integer\" , \"title\" : \"Integer Boolean\" , \"description\" : \"Represents boolean values as an integer. 0 is false, 1 is true.\" , \"default\" : 0 , \"examples\" : [ 0 ], \"enum\" : [ 0 , 1 ], \"oneOf\" : [ { \"title\" : \"True\" , \"const\" : 1 }, { \"title\" : \"False\" , \"const\" : 0 } ] }, \"color\" : { \"type\" : \"array\" , \"title\" : \"Color\" , \"description\" : \"Color as a [r, g, b] array with values in [0, 1]\" , \"items\" : { \"type\" : \"number\" , \"minimum\" : 0 , \"maximum\" : 1 }, \"minItems\" : 3 , \"maxItems\" : 4 } }, \"layers\" : { \"precomposition-layer\" : { \"type\" : \"object\" , \"title\" : \"Precomposition Layer\" , \"description\" : \"Layer that renders a Precomposition asset\" , \"caniuse\" : \"layer-precomp\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/visual-layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer type\" , \"type\" : \"integer\" , \"const\" : 0 }, \"refId\" : { \"title\" : \"Reference Id\" , \"description\" : \"ID of the precomp as specified in the assets\" , \"type\" : \"string\" }, \"w\" : { \"title\" : \"Width\" , \"description\" : \"Width of the clipping rect\" , \"type\" : \"integer\" }, \"h\" : { \"title\" : \"Height\" , \"description\" : \"Height of the clipping rect\" , \"type\" : \"integer\" }, \"tm\" : { \"title\" : \"Time Remapping\" , \"caniuse\" : \"property-timeremap\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" , \"refId\" , \"w\" , \"h\" ] } ] }, \"null-layer\" : { \"type\" : \"object\" , \"title\" : \"Null Layer\" , \"description\" : \"Layer with no data, useful to group layers together\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/visual-layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer type\" , \"type\" : \"integer\" , \"const\" : 3 } }, \"required\" : [ \"ty\" ] } ] }, \"visual-layer\" : { \"type\" : \"object\" , \"title\" : \"Visual Layer\" , \"description\" : \"Layer used to affect visual elements\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ks\" : { \"title\" : \"Transform\" , \"caniuse\" : \"transform\" , \"description\" : \"Layer transform\" , \"$ref\" : \"#/$defs/helpers/transform\" }, \"ao\" : { \"title\" : \"Auto Orient\" , \"$ref\" : \"#/$defs/helpers/int-boolean\" , \"default\" : 0 , \"description\" : \"If 1, The layer will rotate itself to match its animated position path\" }, \"tt\" : { \"title\" : \"Matte Mode\" , \"caniuse\" : \"property-matte-mask\" , \"$ref\" : \"#/$defs/constants/matte-mode\" , \"description\" : \"Defines the track matte mode for the layer\" }, \"tp\" : { \"title\" : \"Matte Parent\" , \"type\" : \"integer\" , \"description\" : \"Index of the layer used as matte, if omitted assume the layer above the current one\" }, \"td\" : { \"title\" : \"Matte Target\" , \"caniuse\" : \"property-matte-mask\" , \"$ref\" : \"#/$defs/helpers/int-boolean\" , \"description\" : \"If set to 1, it means a layer is using this layer as a track matte\" }, \"hasMask\" : { \"title\" : \"Has Masks\" , \"caniuse\" : \"mask\" , \"description\" : \"Whether the layer has masks applied\" , \"type\" : \"boolean\" }, \"masksProperties\" : { \"title\" : \"Masks\" , \"caniuse\" : \"mask\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/helpers/mask\" } }, \"ef\" : { \"title\" : \"Effects\" , \"description\" : \"List of layer effects\" , \"caniuse\" : \"effects\" , \"type\" : \"array\" , \"items\" : { \"oneOf\" : [ { \"$ref\" : \"#/$defs/effects/custom-effect\" }, { \"$ref\" : \"#/$defs/effects/drop-shadow-effect\" }, { \"$ref\" : \"#/$defs/effects/fill-effect\" }, { \"$ref\" : \"#/$defs/effects/gaussian-blur-effect\" }, { \"$ref\" : \"#/$defs/effects/matte3-effect\" }, { \"$ref\" : \"#/$defs/effects/pro-levels-effect\" }, { \"$ref\" : \"#/$defs/effects/stroke-effect\" }, { \"$ref\" : \"#/$defs/effects/tint-effect\" }, { \"$ref\" : \"#/$defs/effects/tritone-effect\" }, { \"$ref\" : \"#/$defs/effects/radial-wipe-effect\" }, { \"$ref\" : \"#/$defs/effects/wavy-effect\" }, { \"$ref\" : \"#/$defs/effects/puppet-effect\" }, { \"$ref\" : \"#/$defs/effects/spherize-effect\" }, { \"$ref\" : \"#/$defs/effects/mesh-warp-effect\" }, { \"$ref\" : \"#/$defs/effects/displacement-map-effect\" }, { \"$ref\" : \"#/$defs/effects/twirl-effect\" } ] } }, \"mb\" : { \"title\" : \"Motion Blur\" , \"description\" : \"Whether motion blur is enabled for the layer\" , \"type\" : \"boolean\" }, \"sy\" : { \"title\" : \"Layer style\" , \"caniuse\" : \"styles\" , \"description\" : \"Styling effects for this layer\" , \"type\" : \"array\" , \"items\" : { \"oneOf\" : [ { \"$ref\" : \"#/$defs/styles/stroke-style\" }, { \"$ref\" : \"#/$defs/styles/drop-shadow-style\" }, { \"$ref\" : \"#/$defs/styles/inner-shadow-style\" }, { \"$ref\" : \"#/$defs/styles/outer-glow-style\" }, { \"$ref\" : \"#/$defs/styles/inner-glow-style\" }, { \"$ref\" : \"#/$defs/styles/bevel-emboss-style\" }, { \"$ref\" : \"#/$defs/styles/satin-style\" }, { \"$ref\" : \"#/$defs/styles/color-overlay-style\" }, { \"$ref\" : \"#/$defs/styles/gradient-overlay-style\" } ] } }, \"bm\" : { \"title\" : \"Blend Mode\" , \"$ref\" : \"#/$defs/constants/blend-mode\" , \"default\" : 0 }, \"cl\" : { \"title\" : \"CSS Class\" , \"description\" : \"CSS class used by the SVG renderer\" , \"type\" : \"string\" }, \"ln\" : { \"title\" : \"Layer XML ID\" , \"description\" : \" id attribute used by the SVG renderer\" , \"type\" : \"string\" }, \"tg\" : { \"title\" : \"Layer XML tag name\" , \"description\" : \"tag name used by the SVG renderer\" , \"type\" : \"string\" }, \"cp\" : { \"deprecated\" : true , \"title\" : \"Collapse Transform\" , \"description\" : \"This is deprecated in favour of ct \" , \"type\" : \"boolean\" }, \"ct\" : { \"title\" : \"Collapse Transform\" , \"description\" : \"Marks that transforms should be applied before masks\" , \"$ref\" : \"#/$defs/helpers/int-boolean\" , \"default\" : 0 } }, \"required\" : [ \"ks\" ] } ] }, \"camera-layer\" : { \"type\" : \"object\" , \"title\" : \"Camera Layer\" , \"description\" : \"3D Camera\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer type\" , \"type\" : \"integer\" , \"const\" : 13 }, \"ks\" : { \"title\" : \"Transform\" , \"description\" : \"Layer transform\" , \"$ref\" : \"#/$defs/helpers/transform\" }, \"pe\" : { \"title\" : \"Perspective\" , \"description\" : \"Distance from the Z=0 plane.\\nSmall values yield a higher perspective effect.\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" , \"ks\" , \"pe\" ] } ] }, \"solid-color-layer\" : { \"type\" : \"object\" , \"title\" : \"Solid Color Layer\" , \"description\" : \"Layer with a solid color rectangle\" , \"caniuse\" : \"layer-solid\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/visual-layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer type\" , \"type\" : \"integer\" , \"const\" : 1 }, \"sc\" : { \"title\" : \"Color\" , \"description\" : \"Color of the layer, unlike most other places, the color is a #rrggbb hex string\" , \"type\" : \"string\" , \"default\" : \"\" }, \"sh\" : { \"title\" : \"Height\" , \"type\" : \"number\" }, \"sw\" : { \"title\" : \"Width\" , \"type\" : \"number\" } }, \"required\" : [ \"ty\" , \"sc\" , \"sw\" , \"sh\" ] } ] }, \"audio-layer\" : { \"type\" : \"object\" , \"title\" : \"Audio Layer\" , \"description\" : \"A layer playing sounds\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer type\" , \"type\" : \"integer\" , \"const\" : 6 }, \"au\" : { \"title\" : \"Audio Settings\" , \"$ref\" : \"#/$defs/layers/audio-settings\" }, \"refId\" : { \"title\" : \"Sound Id\" , \"description\" : \"ID of the sound as specified in the assets\" , \"type\" : \"string\" } }, \"required\" : [ \"ty\" , \"au\" ] } ] }, \"data-layer\" : { \"type\" : \"object\" , \"title\" : \"Data Layer\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer type\" , \"type\" : \"integer\" , \"const\" : 15 }, \"refId\" : { \"title\" : \"Data source Id\" , \"description\" : \"ID of the data source in assets\" , \"type\" : \"string\" } }, \"required\" : [ \"ty\" ] } ] }, \"audio-settings\" : { \"type\" : \"object\" , \"title\" : \"Audio Settings\" , \"description\" : \"\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"lv\" : { \"title\" : \"Level\" , \"$ref\" : \"#/$defs/animated-properties/multi-dimensional\" } }, \"required\" : [ \"lv\" ] } ] }, \"shape-layer\" : { \"type\" : \"object\" , \"title\" : \"Shape Layer\" , \"description\" : \"Layer containing Shapes\" , \"caniuse\" : \"layer-shape\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/visual-layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer type\" , \"type\" : \"integer\" , \"const\" : 4 }, \"shapes\" : { \"title\" : \"Shapes\" , \"$ref\" : \"#/$defs/shapes/shape-list\" } }, \"required\" : [ \"ty\" , \"shapes\" ] } ] }, \"image-layer\" : { \"type\" : \"object\" , \"title\" : \"Image Layer\" , \"description\" : \"Layer that shows an image asset\" , \"caniuse\" : \"layer-image\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/visual-layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer type\" , \"type\" : \"integer\" , \"const\" : 2 }, \"refId\" : { \"title\" : \"Image Id\" , \"description\" : \"ID of the image as specified in the assets\" , \"type\" : \"string\" , \"default\" : \"\" } }, \"required\" : [ \"ty\" , \"refId\" ] } ] }, \"layer\" : { \"type\" : \"object\" , \"title\" : \"Layer\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/visual-object\" }, { \"type\" : \"object\" , \"properties\" : { \"ddd\" : { \"title\" : \"Threedimensional\" , \"description\" : \"Whether the layer is threedimensional\" , \"$ref\" : \"#/$defs/helpers/int-boolean\" , \"default\" : 0 }, \"hd\" : { \"title\" : \"Hidden\" , \"description\" : \"Whether the layer is hidden\" , \"type\" : \"boolean\" }, \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"oneOf\" : [ { \"const\" : 0 , \"title\" : \"Precomposition layer\" }, { \"const\" : 1 , \"title\" : \"Solid color layer\" }, { \"const\" : 2 , \"title\" : \"Image layer\" }, { \"const\" : 3 , \"title\" : \"Null layer\" }, { \"const\" : 4 , \"title\" : \"Shape layer\" }, { \"const\" : 5 , \"title\" : \"Text layer\" }, { \"const\" : 6 , \"title\" : \"Audio layer\" }, { \"const\" : 7 , \"title\" : \"Video placeholder\" }, { \"const\" : 8 , \"title\" : \"Image sequence\" }, { \"const\" : 9 , \"title\" : \"Video layer\" }, { \"const\" : 10 , \"title\" : \"Image placeholder\" }, { \"const\" : 11 , \"title\" : \"Guide layer\" }, { \"const\" : 12 , \"title\" : \"Adjustment layer\" }, { \"const\" : 13 , \"title\" : \"Camera\" }, { \"const\" : 14 , \"title\" : \"Light layer\" }, { \"const\" : 15 , \"title\" : \"Data layer\" } ] }, \"ind\" : { \"title\" : \"Index\" , \"type\" : \"integer\" , \"description\" : \"Index that can be used for parenting and referenced in expressions\" }, \"parent\" : { \"title\" : \"Parent Index\" , \"description\" : \"Must be the ind property of another layer\" , \"type\" : \"integer\" }, \"sr\" : { \"title\" : \"Time Stretch\" , \"caniuse\" : \"property-time-stretch\" , \"type\" : \"number\" , \"default\" : 1 }, \"ip\" : { \"title\" : \"In Point\" , \"description\" : \"Frame when the layer becomes visible\" , \"type\" : \"number\" }, \"op\" : { \"title\" : \"Out Point\" , \"description\" : \"Frame when the layer becomes invisible\" , \"type\" : \"number\" }, \"st\" : { \"title\" : \"Start Time\" , \"type\" : \"number\" , \"default\" : 0 } }, \"required\" : [ \"ty\" , \"st\" , \"ip\" , \"op\" ] } ] }, \"text-layer\" : { \"type\" : \"object\" , \"title\" : \"Text Layer\" , \"description\" : \"Layer with some text\" , \"caniuse\" : \"layer-text\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/visual-layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer type\" , \"type\" : \"integer\" , \"const\" : 5 }, \"t\" : { \"title\" : \"Data\" , \"$ref\" : \"#/$defs/text/text-data\" } }, \"required\" : [ \"ty\" , \"t\" ] } ] } }, \"shapes\" : { \"modifier\" : { \"type\" : \"object\" , \"title\" : \"Modifier\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-element\" } ] }, \"ellipse\" : { \"type\" : \"object\" , \"title\" : \"Ellipse\" , \"description\" : \"Ellipse shape\" , \"caniuse\" : \"shape-ellipse\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"el\" }, \"p\" : { \"title\" : \"Position\" , \"$ref\" : \"#/$defs/animated-properties/position\" }, \"s\" : { \"title\" : \"Size\" , \"$ref\" : \"#/$defs/animated-properties/multi-dimensional\" } }, \"required\" : [ \"ty\" , \"s\" , \"p\" ] } ] }, \"shape-list\" : { \"title\" : \"Shape List\" , \"description\" : \"List of valid shapes\" , \"type\" : \"array\" , \"items\" : { \"oneOf\" : [ { \"$ref\" : \"#/$defs/shapes/ellipse\" }, { \"$ref\" : \"#/$defs/shapes/fill\" }, { \"$ref\" : \"#/$defs/shapes/gradient-fill\" }, { \"$ref\" : \"#/$defs/shapes/gradient-stroke\" }, { \"$ref\" : \"#/$defs/shapes/group\" }, { \"$ref\" : \"#/$defs/shapes/path\" }, { \"$ref\" : \"#/$defs/shapes/polystar\" }, { \"$ref\" : \"#/$defs/shapes/pucker-bloat\" }, { \"$ref\" : \"#/$defs/shapes/rectangle\" }, { \"$ref\" : \"#/$defs/shapes/repeater\" }, { \"$ref\" : \"#/$defs/shapes/rounded-corners\" }, { \"$ref\" : \"#/$defs/shapes/stroke\" }, { \"$ref\" : \"#/$defs/shapes/transform\" }, { \"$ref\" : \"#/$defs/shapes/trim\" }, { \"$ref\" : \"#/$defs/shapes/twist\" }, { \"$ref\" : \"#/$defs/shapes/merge\" }, { \"$ref\" : \"#/$defs/shapes/offset-path\" }, { \"$ref\" : \"#/$defs/shapes/zig-zag\" }, { \"$ref\" : \"#/$defs/shapes/no-style\" } ] } }, \"stroke-dash\" : { \"type\" : \"object\" , \"title\" : \"Stroke Dash\" , \"description\" : \"An item used to described the dashe pattern in a stroked path\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/visual-object\" }, { \"type\" : \"object\" , \"properties\" : { \"n\" : { \"title\" : \"Dash Type\" , \"$ref\" : \"#/$defs/constants/stroke-dash-type\" , \"default\" : \"d\" }, \"v\" : { \"title\" : \"Length\" , \"description\" : \"Length of the dash\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [] } ] }, \"repeater-transform\" : { \"type\" : \"object\" , \"title\" : \"Repeater Transform\" , \"description\" : \"Transform used by a repeater, the transform is applied to each subsequent repeated object.\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/transform\" }, { \"type\" : \"object\" , \"properties\" : { \"so\" : { \"title\" : \"Start Opacity\" , \"description\" : \"Opacity of the first repeated object.\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"eo\" : { \"title\" : \"End Opacity\" , \"description\" : \"Opacity of the last repeated object.\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [] } ] }, \"twist\" : { \"type\" : \"object\" , \"title\" : \"Twist\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-element\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"tw\" }, \"a\" : { \"title\" : \"Angle\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"c\" : { \"title\" : \"Center\" , \"$ref\" : \"#/$defs/animated-properties/multi-dimensional\" } }, \"required\" : [ \"ty\" ] } ] }, \"offset-path\" : { \"type\" : \"object\" , \"title\" : \"Offset Path\" , \"caniuse\" : \"shape-offset-path\" , \"description\" : \"Interpolates the shape with its center point and bezier tangents with the opposite direction\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-element\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"op\" }, \"a\" : { \"title\" : \"Amount\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"lj\" : { \"title\" : \"Line Join\" , \"$ref\" : \"#/$defs/constants/line-join\" , \"default\" : 2 }, \"ml\" : { \"title\" : \"Miter Limit\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" ] } ] }, \"gradient\" : { \"type\" : \"object\" , \"title\" : \"Gradient\" , \"description\" : \"\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"s\" : { \"title\" : \"Start Point\" , \"description\" : \"Starting point for the gradient\" , \"$ref\" : \"#/$defs/animated-properties/multi-dimensional\" }, \"e\" : { \"title\" : \"End Point\" , \"description\" : \"End point for the gradient\" , \"$ref\" : \"#/$defs/animated-properties/multi-dimensional\" }, \"t\" : { \"title\" : \"Gradient Type\" , \"description\" : \"Type of the gradient\" , \"$ref\" : \"#/$defs/constants/gradient-type\" , \"default\" : 1 }, \"h\" : { \"title\" : \"Highlight Length\" , \"description\" : \"Highlight Length, as a percentage between s and e \" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"a\" : { \"title\" : \"Highlight Angle\" , \"description\" : \"Highlight Angle, relative to the direction from s to e \" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"g\" : { \"title\" : \"Colors\" , \"description\" : \"Gradient colors\" , \"$ref\" : \"#/$defs/animated-properties/gradient-colors\" } }, \"required\" : [ \"s\" , \"e\" , \"g\" ] } ] }, \"gradient-stroke\" : { \"type\" : \"object\" , \"title\" : \"Gradient Stroke\" , \"description\" : \"Gradient stroke\" , \"caniuse\" : \"shape-stroke-gradient\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-element\" }, { \"$ref\" : \"#/$defs/shapes/base-stroke\" }, { \"$ref\" : \"#/$defs/shapes/gradient\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"gs\" } }, \"required\" : [ \"ty\" ] } ] }, \"polystar\" : { \"type\" : \"object\" , \"title\" : \"PolyStar\" , \"description\" : \"Star or regular polygon\" , \"caniuse\" : \"shape-polystar\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"sr\" }, \"p\" : { \"title\" : \"Position\" , \"$ref\" : \"#/$defs/animated-properties/position\" }, \"or\" : { \"title\" : \"Outer Radius\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"os\" : { \"title\" : \"Outer Roundness\" , \"description\" : \"Outer Roundness as a percentage\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"r\" : { \"title\" : \"Rotation\" , \"description\" : \"Rotation, clockwise in degrees\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"pt\" : { \"title\" : \"Points\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"sy\" : { \"title\" : \"Star Type\" , \"description\" : \"Star type, 1 for Star, 2 for Polygon\" , \"$ref\" : \"#/$defs/constants/star-type\" , \"default\" : 1 } }, \"required\" : [ \"ty\" , \"or\" , \"os\" , \"pt\" , \"p\" , \"r\" ] }, { \"if\" : { \"properties\" : { \"sy\" : { \"const\" : 1 } } }, \"then\" : { \"properties\" : { \"ir\" : { \"title\" : \"Inner Radius\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"is\" : { \"title\" : \"Inner Roundness\" , \"description\" : \"Inner Roundness as a percentage\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ir\" , \"is\" ] } } ] }, \"shape-element\" : { \"type\" : \"object\" , \"title\" : \"Shape Element\" , \"description\" : \"Base class for all elements of ShapeLayer and Group\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/visual-object\" }, { \"type\" : \"object\" , \"properties\" : { \"hd\" : { \"title\" : \"Hidden\" , \"description\" : \"Whether the shape is hidden\" , \"type\" : \"boolean\" }, \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"oneOf\" : [ { \"const\" : \"rc\" , \"title\" : \"Rectangle\" }, { \"const\" : \"el\" , \"title\" : \"Ellipse\" }, { \"const\" : \"sr\" , \"title\" : \"Polygon / Star\" }, { \"const\" : \"sh\" , \"title\" : \"Path\" }, { \"const\" : \"fl\" , \"title\" : \"Fill\" }, { \"const\" : \"st\" , \"title\" : \"Stroke\" }, { \"const\" : \"gf\" , \"title\" : \"Gradient fill\" }, { \"const\" : \"gs\" , \"title\" : \"Gradient stroke\" }, { \"const\" : \"no\" , \"title\" : \"No Style\" }, { \"const\" : \"gr\" , \"title\" : \"Group\" }, { \"const\" : \"tr\" , \"title\" : \"Transform\" }, { \"const\" : \"rd\" , \"title\" : \"Rounded corners\" }, { \"const\" : \"pb\" , \"title\" : \"Pucker / bloat\" }, { \"const\" : \"mm\" , \"title\" : \"Merge\" }, { \"const\" : \"tw\" , \"title\" : \"Twist\" }, { \"const\" : \"op\" , \"title\" : \"Offset path\" }, { \"const\" : \"zz\" , \"title\" : \"Zig zag\" }, { \"const\" : \"rp\" , \"title\" : \"Repeater\" }, { \"const\" : \"tm\" , \"title\" : \"Trim\" } ] }, \"bm\" : { \"title\" : \"Blend Mode\" , \"$ref\" : \"#/$defs/constants/blend-mode\" }, \"ix\" : { \"title\" : \"Property index\" , \"description\" : \"Index used in expressions\" , \"type\" : \"integer\" }, \"cl\" : { \"title\" : \"CSS Class\" , \"description\" : \"CSS class used by the SVG renderer\" , \"type\" : \"string\" }, \"ln\" : { \"title\" : \"Layer XML ID\" , \"description\" : \" id attribute used by the SVG renderer\" , \"type\" : \"string\" } }, \"required\" : [ \"ty\" ] } ] }, \"group\" : { \"type\" : \"object\" , \"title\" : \"Group\" , \"description\" : \"Shape Element that can contain other shapes\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-element\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"gr\" }, \"np\" : { \"title\" : \"Number Of Properties\" , \"type\" : \"number\" }, \"it\" : { \"title\" : \"Shapes\" , \"$ref\" : \"#/$defs/shapes/shape-list\" }, \"cix\" : { \"title\" : \"Property index\" , \"description\" : \"Index used in expressions\" , \"type\" : \"integer\" } }, \"required\" : [ \"ty\" ] } ] }, \"fill\" : { \"type\" : \"object\" , \"title\" : \"Fill\" , \"description\" : \"Solid fill color\" , \"caniuse\" : \"shape-fill\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-element\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"fl\" }, \"o\" : { \"title\" : \"Opacity\" , \"description\" : \"Opacity, 100 means fully opaque\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"c\" : { \"title\" : \"Color\" , \"$ref\" : \"#/$defs/animated-properties/color-value\" }, \"r\" : { \"title\" : \"Fill Rule\" , \"$ref\" : \"#/$defs/constants/fill-rule\" } }, \"required\" : [ \"ty\" , \"c\" , \"o\" ] } ] }, \"gradient-fill\" : { \"type\" : \"object\" , \"title\" : \"Gradient Fill\" , \"description\" : \"Gradient fill\" , \"caniuse\" : \"shape-fill-gradient\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-element\" }, { \"$ref\" : \"#/$defs/shapes/gradient\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"gf\" }, \"o\" : { \"title\" : \"Opacity\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"r\" : { \"title\" : \"Fill Rule\" , \"$ref\" : \"#/$defs/constants/fill-rule\" } }, \"required\" : [ \"ty\" , \"o\" ] } ] }, \"path\" : { \"type\" : \"object\" , \"title\" : \"Path\" , \"description\" : \"Animatable Bezier curve\" , \"caniuse\" : \"shape-path\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"sh\" }, \"ks\" : { \"title\" : \"Shape\" , \"description\" : \"Bezier path\" , \"$ref\" : \"#/$defs/animated-properties/shape-property\" } }, \"required\" : [ \"ty\" , \"ks\" ] } ] }, \"merge\" : { \"type\" : \"object\" , \"title\" : \"Merge\" , \"caniuse\" : \"shape-merge-path\" , \"description\" : \"Boolean operator on shapes\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-element\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"mm\" }, \"mm\" : { \"title\" : \"Merge Mode\" , \"$ref\" : \"#/$defs/constants/merge-mode\" , \"default\" : 1 } }, \"required\" : [ \"ty\" ] } ] }, \"repeater\" : { \"type\" : \"object\" , \"title\" : \"Repeater\" , \"description\" : \"Duplicates previous shapes in a group\" , \"caniuse\" : \"shape-repeater\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/modifier\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"rp\" }, \"c\" : { \"title\" : \"Copies\" , \"description\" : \"Number of copies\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"o\" : { \"title\" : \"Offset\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"m\" : { \"title\" : \"Composite\" , \"description\" : \"Stacking order\" , \"$ref\" : \"#/$defs/constants/composite\" , \"default\" : 1 }, \"tr\" : { \"title\" : \"Transform\" , \"description\" : \"Transform applied to each copy\" , \"$ref\" : \"#/$defs/shapes/repeater-transform\" } }, \"required\" : [ \"ty\" , \"c\" , \"tr\" ] } ] }, \"shape\" : { \"type\" : \"object\" , \"title\" : \"Shape\" , \"description\" : \"Drawable shape\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-element\" }, { \"type\" : \"object\" , \"properties\" : { \"d\" : { \"title\" : \"Direction\" , \"description\" : \"Direction the shape is drawn as, mostly relevant when using trim path\" , \"$ref\" : \"#/$defs/constants/shape-direction\" } } } ] }, \"pucker-bloat\" : { \"type\" : \"object\" , \"title\" : \"Pucker Bloat\" , \"description\" : \"Interpolates the shape with its center point and bezier tangents with the opposite direction\" , \"caniuse\" : \"shape-pucker-and-bloat\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-element\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"pb\" }, \"a\" : { \"title\" : \"Amount\" , \"description\" : \"Amount as a percentage\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" ] } ] }, \"rounded-corners\" : { \"type\" : \"object\" , \"title\" : \"Rounded Corners\" , \"description\" : \"Rounds corners of other shapes\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/modifier\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"rd\" }, \"r\" : { \"title\" : \"Radius\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" , \"r\" ] } ] }, \"zig-zag\" : { \"type\" : \"object\" , \"title\" : \"Zig Zag\" , \"description\" : \"Changes the edges of affected shapes into a series of peaks and valleys of uniform size\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-element\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"zz\" }, \"r\" : { \"title\" : \"Frequency\" , \"description\" : \"Number of ridges per segment\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"s\" : { \"title\" : \"Amplitude\" , \"description\" : \"Distance between peaks and troughs\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"pt\" : { \"title\" : \"Point Type\" , \"description\" : \"Point type (1 = corner, 2 = smooth)\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" ] } ] }, \"transform\" : { \"type\" : \"object\" , \"title\" : \"Transform Shape\" , \"description\" : \"Group transform\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-element\" }, { \"$ref\" : \"#/$defs/helpers/transform\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"tr\" } }, \"required\" : [ \"ty\" ] } ] }, \"no-style\" : { \"type\" : \"object\" , \"title\" : \"No Style\" , \"description\" : \"Represents a style for shapes without fill or stroke\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-element\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"no\" } }, \"required\" : [ \"ty\" ] } ] }, \"stroke\" : { \"type\" : \"object\" , \"title\" : \"Stroke\" , \"description\" : \"Solid stroke\" , \"caniuse\" : \"shape-stroke\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-element\" }, { \"$ref\" : \"#/$defs/shapes/base-stroke\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"st\" }, \"c\" : { \"title\" : \"Color\" , \"description\" : \"Stroke color\" , \"$ref\" : \"#/$defs/animated-properties/color-value\" } }, \"required\" : [ \"ty\" , \"c\" ] } ] }, \"trim\" : { \"type\" : \"object\" , \"title\" : \"Trim\" , \"description\" : \"Trims shapes into a segment\" , \"caniuse\" : \"shape-trim-path\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/modifier\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"tm\" }, \"s\" : { \"title\" : \"Start\" , \"description\" : \"Segment start\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"e\" : { \"title\" : \"End\" , \"description\" : \"Segment end\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"o\" : { \"title\" : \"Offset\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"m\" : { \"title\" : \"Multiple\" , \"description\" : \"How to treat multiple copies\" , \"$ref\" : \"#/$defs/constants/trim-multiple-shapes\" } }, \"required\" : [ \"ty\" , \"o\" , \"s\" , \"e\" ] } ] }, \"rectangle\" : { \"type\" : \"object\" , \"title\" : \"Rectangle\" , \"description\" : \"A simple rectangle shape\" , \"caniuse\" : \"shape-rectangle\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"rc\" }, \"p\" : { \"title\" : \"Position\" , \"description\" : \"Center of the rectangle\" , \"$ref\" : \"#/$defs/animated-properties/position\" }, \"s\" : { \"title\" : \"Size\" , \"$ref\" : \"#/$defs/animated-properties/multi-dimensional\" }, \"r\" : { \"title\" : \"Rounded\" , \"description\" : \"Rounded corners radius\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" , \"s\" , \"p\" , \"r\" ] } ] }, \"base-stroke\" : { \"type\" : \"object\" , \"title\" : \"Base Stroke\" , \"description\" : \"\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"lc\" : { \"title\" : \"Line Cap\" , \"$ref\" : \"#/$defs/constants/line-cap\" , \"default\" : 2 }, \"lj\" : { \"title\" : \"Line Join\" , \"$ref\" : \"#/$defs/constants/line-join\" , \"default\" : 2 }, \"ml\" : { \"title\" : \"Miter Limit\" , \"type\" : \"number\" , \"default\" : 0 }, \"ml2\" : { \"title\" : \"Miter Limit\" , \"description\" : \"Animatable alternative to ml\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"o\" : { \"title\" : \"Opacity\" , \"description\" : \"Opacity, 100 means fully opaque\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"w\" : { \"title\" : \"Width\" , \"description\" : \"Stroke width\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"d\" : { \"title\" : \"Dashes\" , \"description\" : \"Dashed line definition\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/shapes/stroke-dash\" } } }, \"required\" : [ \"o\" , \"w\" ] } ] } }, \"styles\" : { \"drop-shadow-style\" : { \"type\" : \"object\" , \"title\" : \"Drop Shadow\" , \"caniuse\" : \"style-drop-shadow\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/styles/layer-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"const\" : 1 }, \"c\" : { \"title\" : \"Color\" , \"$ref\" : \"#/$defs/animated-properties/color-value\" }, \"o\" : { \"title\" : \"Opacity\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"a\" : { \"title\" : \"Angle\" , \"description\" : \"Local light angle\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"s\" : { \"title\" : \"Size\" , \"description\" : \"Blur size\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"d\" : { \"title\" : \"Distance\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"ch\" : { \"title\" : \"Choke Spread\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"bm\" : { \"title\" : \"Blend Mode\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"no\" : { \"title\" : \"Noise\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"lc\" : { \"title\" : \"Layer Conceal\" , \"description\" : \"Layer knowck out drop shadow\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" ] } ] }, \"inner-shadow-style\" : { \"type\" : \"object\" , \"title\" : \"Inner Shadow\" , \"caniuse\" : \"style-inner-shadow\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/styles/layer-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"const\" : 2 }, \"c\" : { \"title\" : \"Color\" , \"$ref\" : \"#/$defs/animated-properties/color-value\" }, \"o\" : { \"title\" : \"Opacity\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"a\" : { \"title\" : \"Angle\" , \"description\" : \"Local light angle\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"s\" : { \"title\" : \"Size\" , \"description\" : \"Blur size\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"d\" : { \"title\" : \"Distance\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"ch\" : { \"title\" : \"Choke Spread\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"bm\" : { \"title\" : \"Blend Mode\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"no\" : { \"title\" : \"Noise\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" ] } ] }, \"layer-style\" : { \"type\" : \"object\" , \"title\" : \"Layer Style\" , \"description\" : \"Style applied to a layer\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/visual-object\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Style Type\" , \"type\" : \"integer\" } }, \"required\" : [ \"ty\" ] } ] }, \"bevel-emboss-style\" : { \"type\" : \"object\" , \"title\" : \"Bevel Emboss\" , \"caniuse\" : \"style-bevel-and-emboss\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/styles/layer-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"const\" : 5 }, \"bs\" : { \"title\" : \"Bevel Style\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"bt\" : { \"title\" : \"Technique\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"sr\" : { \"title\" : \"Strength\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"s\" : { \"title\" : \"Size\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"sf\" : { \"title\" : \"Soften\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"ga\" : { \"title\" : \"Global Angle\" , \"description\" : \"Use global light\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"a\" : { \"title\" : \"Angle\" , \"description\" : \"Local lighting angle\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"ll\" : { \"title\" : \"Altitude\" , \"description\" : \"Local lighting altitude\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"hm\" : { \"title\" : \"Highlight Mode\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"hc\" : { \"title\" : \"Highlight Color\" , \"$ref\" : \"#/$defs/animated-properties/color-value\" }, \"ho\" : { \"title\" : \"Highlight Opacity\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"sm\" : { \"title\" : \"Shadow Mode\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"sc\" : { \"title\" : \"Shadow Color\" , \"$ref\" : \"#/$defs/animated-properties/color-value\" }, \"so\" : { \"title\" : \"Shadow Opacity\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" ] } ] }, \"outer-glow-style\" : { \"type\" : \"object\" , \"title\" : \"Outer Glow\" , \"caniuse\" : \"style-outer-glow\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/styles/layer-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"const\" : 3 }, \"c\" : { \"title\" : \"Color\" , \"$ref\" : \"#/$defs/animated-properties/color-value\" }, \"o\" : { \"title\" : \"Opacity\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"r\" : { \"title\" : \"Range\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"ch\" : { \"title\" : \"Choke Spread\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"bm\" : { \"title\" : \"Blend Mode\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"no\" : { \"title\" : \"Noise\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"j\" : { \"title\" : \"Jitter\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" ] } ] }, \"gradient-overlay-style\" : { \"type\" : \"object\" , \"title\" : \"Gradient Overlay\" , \"caniuse\" : \"style-gradient-overlay\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/styles/layer-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"const\" : 8 }, \"bm\" : { \"title\" : \"Blend Mode\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"o\" : { \"title\" : \"Opacity\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"gf\" : { \"title\" : \"Gradient\" , \"$ref\" : \"#/$defs/animated-properties/gradient-colors\" }, \"gs\" : { \"title\" : \"Smoothness\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"a\" : { \"title\" : \"Angle\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"gt\" : { \"title\" : \"Gradient Type\" , \"$ref\" : \"#/$defs/constants/gradient-type\" }, \"re\" : { \"title\" : \"Reverse\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"al\" : { \"title\" : \"Align\" , \"description\" : \"Align with layer\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"s\" : { \"title\" : \"Scale\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"of\" : { \"title\" : \"Offset\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" ] } ] }, \"satin-style\" : { \"type\" : \"object\" , \"title\" : \"Satin\" , \"caniuse\" : \"style-satin\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/styles/layer-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"const\" : 6 }, \"bm\" : { \"title\" : \"Blend Mode\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"c\" : { \"title\" : \"Color\" , \"$ref\" : \"#/$defs/animated-properties/color-value\" }, \"o\" : { \"title\" : \"Opacity\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"a\" : { \"title\" : \"Angle\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"d\" : { \"title\" : \"Distance\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"s\" : { \"title\" : \"Size\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"in\" : { \"title\" : \"Invert\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" ] } ] }, \"stroke-style\" : { \"type\" : \"object\" , \"title\" : \"Layer Stroke\" , \"caniuse\" : \"style-stroke\" , \"description\" : \"Stroke / frame\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/styles/layer-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"const\" : 0 }, \"s\" : { \"title\" : \"Size\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"c\" : { \"title\" : \"Color\" , \"$ref\" : \"#/$defs/animated-properties/color-value\" } }, \"required\" : [ \"ty\" ] } ] }, \"color-overlay-style\" : { \"type\" : \"object\" , \"title\" : \"Color Overlay\" , \"caniuse\" : \"style-color-overlay\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/styles/layer-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"const\" : 7 }, \"bm\" : { \"title\" : \"Blend Mode\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"c\" : { \"title\" : \"Color\" , \"$ref\" : \"#/$defs/animated-properties/color-value\" }, \"so\" : { \"title\" : \"Opacity\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" ] } ] }, \"inner-glow-style\" : { \"type\" : \"object\" , \"title\" : \"Inner Glow\" , \"caniuse\" : \"style-inner-glow\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/styles/layer-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"const\" : 4 }, \"c\" : { \"title\" : \"Color\" , \"$ref\" : \"#/$defs/animated-properties/color-value\" }, \"o\" : { \"title\" : \"Opacity\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"r\" : { \"title\" : \"Range\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"sr\" : { \"title\" : \"Source\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"ch\" : { \"title\" : \"Choke Spread\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"bm\" : { \"title\" : \"Blend Mode\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"no\" : { \"title\" : \"Noise\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"j\" : { \"title\" : \"Jitter\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"ty\" ] } ] } }, \"text\" : { \"text-data\" : { \"type\" : \"object\" , \"title\" : \"Text Data\" , \"description\" : \"Contains all the text data and animation\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"a\" : { \"title\" : \"Ranges\" , \"caniuse\" : \"text-animators\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/text/text-range\" } }, \"d\" : { \"title\" : \"Document\" , \"$ref\" : \"#/$defs/text/animated-text-document\" }, \"m\" : { \"title\" : \"Alignment\" , \"$ref\" : \"#/$defs/text/text-alignment-options\" }, \"p\" : { \"title\" : \"Follow Path\" , \"$ref\" : \"#/$defs/text/text-follow-path\" } }, \"required\" : [ \"a\" , \"d\" , \"m\" , \"p\" ] } ] }, \"text-follow-path\" : { \"type\" : \"object\" , \"title\" : \"Text Follow Path\" , \"caniuse\" : \"text-path\" , \"description\" : \"Uses the path described by a layer mask to put the text on said path.\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"m\" : { \"title\" : \"Mask\" , \"type\" : \"integer\" , \"description\" : \"Index of the mask to use\" }, \"f\" : { \"title\" : \"First Margin\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"l\" : { \"title\" : \"Last Margin\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"r\" : { \"title\" : \"Reverse Path\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"a\" : { \"title\" : \"Force Alignment\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"p\" : { \"title\" : \"Perpendicular To Path\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [] } ] }, \"text-document\" : { \"type\" : \"object\" , \"title\" : \"Text Document\" , \"description\" : \"\" , \"properties\" : { \"f\" : { \"title\" : \"Font Family\" , \"type\" : \"string\" , \"default\" : \"\" }, \"fc\" : { \"title\" : \"Fill Color\" , \"$ref\" : \"#/$defs/helpers/color\" , \"default\" : [ 0 , 0 , 0 ] }, \"sc\" : { \"title\" : \"Stroke Color\" , \"$ref\" : \"#/$defs/helpers/color\" }, \"sw\" : { \"title\" : \"Stroke Width\" , \"type\" : \"number\" , \"default\" : 0 }, \"of\" : { \"title\" : \"Stroke Over Fill\" , \"description\" : \"Render stroke above the fill\" , \"type\" : \"boolean\" }, \"s\" : { \"title\" : \"Font Size\" , \"type\" : \"number\" , \"default\" : 10 }, \"lh\" : { \"title\" : \"Line Height\" , \"description\" : \"Distance between lines on multiline or wrapped text\" , \"type\" : \"number\" }, \"sz\" : { \"title\" : \"Wrap Size\" , \"description\" : \"Size of the box containing the text\" , \"type\" : \"array\" , \"minItems\" : 2 , \"maxItems\" : 2 , \"items\" : { \"type\" : \"number\" } }, \"ps\" : { \"title\" : \"Wrap Position\" , \"description\" : \"Position of the box containing the text\" , \"type\" : \"array\" , \"minItems\" : 2 , \"maxItems\" : 2 , \"items\" : { \"type\" : \"number\" } }, \"t\" : { \"title\" : \"Text\" , \"type\" : \"string\" , \"description\" : \"Text, note that newlines are encoded with \\r\" , \"default\" : \"\" }, \"j\" : { \"title\" : \"Justify\" , \"$ref\" : \"#/$defs/constants/text-justify\" , \"default\" : 0 }, \"ca\" : { \"title\" : \"Text Caps\" , \"$ref\" : \"#/$defs/constants/text-caps\" }, \"tr\" : { \"title\" : \"Tracking\" , \"description\" : \"Text Tracking\" , \"type\" : \"number\" }, \"ls\" : { \"title\" : \"Baseline Shift\" , \"type\" : \"number\" } }, \"required\" : [ \"f\" , \"fc\" , \"s\" , \"t\" ] }, \"character-precomp\" : { \"type\" : \"object\" , \"title\" : \"Character Precomp\" , \"description\" : \"Defines a character as a precomp layer\" , \"properties\" : { \"refId\" : { \"title\" : \"Reference Id\" , \"description\" : \"ID of the precomp as specified in the assets\" , \"type\" : \"string\" }, \"ks\" : { \"title\" : \"Transform\" , \"description\" : \"Layer transform\" , \"$ref\" : \"#/$defs/helpers/transform\" }, \"ip\" : { \"title\" : \"In Point\" , \"description\" : \"Frame when the layer becomes visible\" , \"type\" : \"number\" , \"default\" : 0 }, \"op\" : { \"title\" : \"Out Point\" , \"description\" : \"Frame when the layer becomes invisible\" , \"type\" : \"number\" , \"default\" : 99999 }, \"sr\" : { \"title\" : \"Time Stretch\" , \"type\" : \"number\" , \"default\" : 1 }, \"st\" : { \"title\" : \"Start Time\" , \"type\" : \"number\" , \"default\" : 0 } }, \"required\" : [ \"refId\" ] }, \"text-range-selector\" : { \"type\" : \"object\" , \"title\" : \"Text Range Selector\" , \"caniuse\" : \"animators-range-selectors\" , \"properties\" : { \"t\" : { \"title\" : \"Expressible\" , \"$ref\" : \"#/$defs/helpers/int-boolean\" }, \"xe\" : { \"title\" : \"Max Ease\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"ne\" : { \"title\" : \"Min Ease\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"a\" : { \"title\" : \"Max Amount\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"b\" : { \"title\" : \"Based On\" , \"$ref\" : \"#/$defs/constants/text-based\" }, \"rn\" : { \"title\" : \"Randomize\" , \"$ref\" : \"#/$defs/helpers/int-boolean\" }, \"sh\" : { \"title\" : \"Shape\" , \"$ref\" : \"#/$defs/constants/text-shape\" }, \"o\" : { \"title\" : \"Offset\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"r\" : { \"title\" : \"Range Units\" , \"caniuse\" : \"range-selectors-units\" , \"$ref\" : \"#/$defs/constants/text-range-units\" }, \"sm\" : { \"title\" : \"Selector Smoothness\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"s\" : { \"title\" : \"Start\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"e\" : { \"title\" : \"End\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [ \"t\" , \"a\" , \"b\" , \"sh\" ] }, \"font-list\" : { \"type\" : \"object\" , \"title\" : \"Font List\" , \"description\" : \"List of fonts\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"list\" : { \"title\" : \"List\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/text/font\" } } }, \"required\" : [] } ] }, \"character-shapes\" : { \"type\" : \"object\" , \"title\" : \"Character Shape\" , \"description\" : \"Defines a character as shapes\" , \"properties\" : { \"shapes\" : { \"title\" : \"Shapes\" , \"description\" : \"Shapes forming the character\" , \"$ref\" : \"#/$defs/shapes/shape-list\" } }, \"required\" : [ \"shapes\" ] }, \"animated-text-document\" : { \"type\" : \"object\" , \"title\" : \"Animated Text Document\" , \"description\" : \"Animated property representing the text contents\" , \"properties\" : { \"k\" : { \"title\" : \"Keyframes\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/text/text-document-keyframe\" } }, \"x\" : { \"title\" : \"Expression\" , \"type\" : \"string\" }, \"sid\" : { \"title\" : \"Slot ID\" , \"description\" : \"One of the ID in the file's slots\" , \"type\" : \"string\" } }, \"required\" : [ \"k\" ] }, \"text-range\" : { \"type\" : \"object\" , \"title\" : \"Text Range\" , \"description\" : \"Range of text with custom animations and style\" , \"caniuse\" : \"animators-range-selectors\" , \"properties\" : { \"nm\" : { \"title\" : \"Name\" , \"type\" : \"string\" }, \"s\" : { \"title\" : \"Selector\" , \"$ref\" : \"#/$defs/text/text-range-selector\" }, \"a\" : { \"title\" : \"Style\" , \"$ref\" : \"#/$defs/text/text-style\" } } }, \"text-style\" : { \"type\" : \"object\" , \"title\" : \"Text Style\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/transform\" }, { \"type\" : \"object\" , \"properties\" : { \"sw\" : { \"title\" : \"Stroke Width\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"sc\" : { \"title\" : \"Stroke Color\" , \"$ref\" : \"#/$defs/animated-properties/color-value\" }, \"sh\" : { \"title\" : \"Stroke Hue\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"ss\" : { \"title\" : \"Stroke Saturation\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"sb\" : { \"title\" : \"Stroke Brightness\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"so\" : { \"title\" : \"Stroke Opacity\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"fc\" : { \"title\" : \"Fill Color\" , \"$ref\" : \"#/$defs/animated-properties/color-value\" }, \"fh\" : { \"title\" : \"Fill Hue\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"fs\" : { \"title\" : \"Fill Saturation\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"fb\" : { \"title\" : \"Fill Brightness\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"fo\" : { \"title\" : \"Fill Opacity\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"t\" : { \"title\" : \"Letter Spacing\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"bl\" : { \"title\" : \"Blur\" , \"caniuse\" : \"text-animators-blur\" , \"$ref\" : \"#/$defs/animated-properties/value\" }, \"ls\" : { \"title\" : \"Line Spacing\" , \"$ref\" : \"#/$defs/animated-properties/value\" } }, \"required\" : [] } ] }, \"character-data\" : { \"type\" : \"object\" , \"title\" : \"Character Data\" , \"description\" : \"Defines character shapes\" , \"properties\" : { \"ch\" : { \"title\" : \"Character\" , \"type\" : \"string\" , \"default\" : \"\" }, \"fFamily\" : { \"title\" : \"Font Family\" , \"type\" : \"string\" , \"default\" : \"\" }, \"size\" : { \"title\" : \"Font Size\" , \"type\" : \"number\" , \"default\" : 0 }, \"style\" : { \"title\" : \"Font Style\" , \"type\" : \"string\" , \"default\" : \"\" }, \"w\" : { \"title\" : \"Width\" , \"type\" : \"number\" , \"default\" : 0 }, \"data\" : { \"title\" : \"Data\" , \"oneOf\" : [ { \"$ref\" : \"#/$defs/text/character-shapes\" }, { \"$ref\" : \"#/$defs/text/character-precomp\" } ] } }, \"required\" : [ \"data\" , \"ch\" , \"fFamily\" , \"size\" , \"style\" , \"w\" ] }, \"text-alignment-options\" : { \"type\" : \"object\" , \"title\" : \"Text Alignment Options\" , \"description\" : \"\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"a\" : { \"title\" : \"Alignment\" , \"description\" : \"Group alignment\" , \"caniuse\" : \"animators-grouping-alignment\" , \"$ref\" : \"#/$defs/animated-properties/multi-dimensional\" }, \"g\" : { \"title\" : \"Grouping\" , \"description\" : \"Anchor point grouping\" , \"caniuse\" : \"animators-anchor-point-grouping\" , \"$ref\" : \"#/$defs/constants/text-grouping\" } }, \"required\" : [] } ] }, \"text-document-keyframe\" : { \"type\" : \"object\" , \"title\" : \"Text Document Keyframe\" , \"description\" : \"A keyframe containing a text document\" , \"properties\" : { \"s\" : { \"title\" : \"Start\" , \"$ref\" : \"#/$defs/text/text-document\" }, \"t\" : { \"title\" : \"Time\" , \"type\" : \"number\" , \"default\" : 0 } }, \"required\" : [ \"s\" , \"t\" ] }, \"font\" : { \"type\" : \"object\" , \"title\" : \"Font\" , \"description\" : \"Describes how a font with given settings should be loaded\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"ascent\" : { \"title\" : \"Ascent\" , \"type\" : \"number\" , \"description\" : \"Text will be moved down based on this value\" }, \"fFamily\" : { \"title\" : \"Font Family\" , \"type\" : \"string\" , \"default\" : \"sans\" }, \"fName\" : { \"title\" : \"Name\" , \"description\" : \"Name used by text documents to reference this font, usually it's fFamily followed by fStyle \" , \"type\" : \"string\" , \"default\" : \"sans-Regular\" }, \"fStyle\" : { \"title\" : \"Font Style\" , \"examples\" : [ \"Regular\" , \"Bold\" , \"Bold Italic\" ], \"type\" : \"string\" , \"default\" : \"Regular\" }, \"fPath\" : { \"title\" : \"Path\" , \"type\" : \"string\" }, \"fWeight\" : { \"title\" : \"Weight\" , \"type\" : \"string\" }, \"origin\" : { \"title\" : \"Origin\" , \"$ref\" : \"#/$defs/constants/font-path-origin\" }, \"fClass\" : { \"type\" : \"string\" , \"title\" : \"CSS Class\" , \"description\" : \"CSS Class applied to text objects using this font\" } }, \"required\" : [ \"fFamily\" , \"fName\" , \"fStyle\" ] } ] } } } }","title":"JSON Schema"},{"location":"shapes/","text":"Shape Elements Lottie considers everything related to vector data as a \"shape\" but I think it's worth distinguishing across a few categories: Shapes These provide only the shape information, but no styling Style These provide styling info (like fill and stroke) Group This is a shape that contains other shape Modifier These change other shapes Transform Special shape that defines the transforms in a group shape All shapes have the following properties: Attribute Type Description nm string Name, as seen from editors and the like mn string Match name, used in expressions ty string Shape type (see values below) hd boolean Whether the shape is hidden bm Blend Mode Blend Mode ix integer Index used in expressions cl string CSS class used by the SVG renderer ln string id attribute used by the SVG renderer Shape Types ty Shape rc Rectangle el Ellipse sr PolyStar sh Path fl Fill st Stroke gf Gradient Fill gs Gradient Stroke no No Style gr Group tr Transform rp Repeater tm Trim rd Rounded Corners pb Pucker / Bloat mm Merge tw Twist op Offset Path zz Zig Zag Shape These shapes only define path data, to actually show something, they must be followed by some style shape . They have a d attribute which specifies the drawing direction, which can be seen when using Trim Path . Attribute Type Description d Shape Direction Direction the shape is drawn as, mostly relevant when using trim path Rectangle A rectangle, defined by its center point and size. Attribute Type Description ty string = 'rc' Shape Type p Animated Position Center of the rectangle s Animated Vector Size r Animated number Rounded corners radius Position x 256 Position y 256 Width 256 Height 256 Roundness 0 Show JSON var lottie_player_50 = new PlaygroundPlayer( 50, 'playground_50_6', 'lottie_target_50', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { lottie.layers[0].shapes[0].it[0].p.k = [ data[\"Position x\"], data[\"Position y\"] ]; lottie.layers[0].shapes[0].it[0].s.k = [ data[\"Width\"], data[\"Height\"] ]; lottie.layers[0].shapes[0].it[0].r.k = data[\"Roundness\"];this.json_viewer_contents = lottie.layers[0].shapes[0].it[0]; }, {} ); Ellipse Attribute Type Description ty string = 'el' Shape Type p Animated Position Position s Animated Vector Size Position x 256 Position y 256 Width 256 Height 256 Show JSON var lottie_player_51 = new PlaygroundPlayer( 51, 'playground_51_5', 'lottie_target_51', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"el\", \"nm\": \"Ellipse\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [256, 256]}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { lottie.layers[0].shapes[0].it[0].p.k = [ data[\"Position x\"], data[\"Position y\"] ]; lottie.layers[0].shapes[0].it[0].s.k = [ data[\"Width\"], data[\"Height\"] ];this.json_viewer_contents = lottie.layers[0].shapes[0].it[0]; }, {} ); PolyStar Regular polygon or star. Attribute Type Description ty string = 'sr' Shape Type p Animated Position Position or Animated number Outer Radius os Animated number Outer Roundness as a percentage r Animated number Rotation, clockwise in degrees pt Animated number Points sy Star Type Star type, 1 for Star, 2 for Polygon If sy is 1 (star) you also have attributes defining the inner ends of the star: Attribute Type Description ir Animated number Inner Radius is Animated number Inner Roundness as a percentage Points 5 Rotation 0 Outer Radius 200 Inner Radius 100 Outer Roundness 0 Inner Roundness 0 Type Star Polygon Show JSON var lottie_player_52 = new PlaygroundPlayer( 52, 'playground_52_8', 'lottie_target_52', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [{\"ty\": 4, \"ddd\": 0, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ip\": 0, \"op\": 180, \"ind\": 0, \"st\": 0, \"sr\": 1, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{9199543e-3552-4e51-a802-623f2a4a2ca1}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.979995422293431, 0.28000305180437934]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { var star = { \"ty\": \"sr\", \"nm\": \"PolyStar\", \"sy\": Number(data[\"Type\"]), \"p\": { \"a\": 0, \"k\": [ 249.3134328358209, 254.47164179104476 ] }, \"r\": { \"a\": 0, \"k\": data[\"Rotation\"] }, \"pt\": { \"a\": 0, \"k\": data[\"Points\"] }, \"or\": { \"a\": 0, \"k\": data[\"Outer Radius\"] }, \"os\": { \"a\": 0, \"k\": data[\"Outer Roundness\"] }, }; if ( data[\"Type\"] == \"1\" ) { star = { ...star, \"ir\": { \"a\": 0, \"k\": data[\"Inner Radius\"] }, \"is\": { \"a\": 0, \"k\": data[\"Inner Roundness\"] }, }; } lottie.layers[0].shapes[0].it[0] = star;this.json_viewer_contents = lottie.layers[0].shapes[0].it[0]; }, {} ); Path Bezier path, note that it's a continuous shape, to have multiple shapes like when you need holes or gaps you need to create multiple Path shapes and group them together. Attribute Type Description ty string = 'sh' Shape Type ks Animated Bezier Bezier path Style These apply a style (such as fill stroke) to the paths defined by the shapes . Each style is applied to all preceding shapes in the same group / layer. In most formats the style is usually defined as a property of a shape, in lottie they are separate and allows for more flexibility. Some examples of the added flexibility would be a shape with multiple strokes, or a gradient fading into a solid color. Fill Solid fill color. Attribute Type Description ty string = 'fl' Shape Type o Animated number Opacity, 100 means fully opaque c Animated Color Color r Fill Rule Fill Rule Red 1 Green 0.98 Blue 0.28 Opacity 100 Fill Rule Non Zero Even Odd Show JSON var lottie_player_53 = new PlaygroundPlayer( 53, 'playground_53_6', 'lottie_target_53', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{f5d94f54-bb8f-4f07-be45-232ebd4b9eb1}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{4b0993ed-e35b-48a5-ab12-687dbc147c7c}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Path\", \"mn\": \"{29196ff2-0a65-48b4-a450-f9fbc3a3640d}\", \"it\": [{\"ty\": \"sh\", \"nm\": \"Path\", \"mn\": \"{bb7e6c60-755e-4a21-a7ba-bd054feab5c7}\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [[125.51641791044776, 452.20298507462684], [240.71641791044777, 38.6865671641791], [435.8686567164179, 447.9044776119403], [42.125373134328356, 173.65970149253732], [460.8, 156.46567164179103]], \"i\": [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]], \"o\": [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]]}}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{3af40b83-15f6-4f69-aa2a-96acd03eb3b6}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.98, 0.28]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [251.46268656716418, 245.4447761194029]}, \"p\": {\"a\": 0, \"k\": [251.46268656716418, 245.4447761194029]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { var shape = lottie.layers[0].shapes[0].it[1]; shape.c.k = [data[\"Red\"], data[\"Green\"], data[\"Blue\"]]; shape.o.k = data[\"Opacity\"]; shape.r = Number(data[\"Fill Rule\"]);this.json_viewer_contents = lottie.layers[0].shapes[0].it[1]; }, {} ); Stroke Defines a stroke. Attribute Type Description ty string = 'st' Shape Type lc Line Cap Line Cap lj Line Join Line Join ml number Miter Limit ml2 Animated number Animatable alternative to ml o Animated number Opacity, 100 means fully opaque w Animated number Stroke width d array of Stroke Dash Dashed line definition c Animated Color Stroke color Stroke Dashes Defined as a sequence of alternating dashes and gaps. Attribute Type Description n Stroke Dash Type Dash Type v Animated number Length of the dash Red 1 Green 0.98 Blue 0.28 Width 32 Opacity 100 Line Cap Butt Round Square Line Join Miter Round Bevel Miter Limit 3 Dash Offset 0 Dash Length 100 Dash Gap 0 Show JSON var lottie_player_54 = new PlaygroundPlayer( 54, 'playground_54_12', 'lottie_target_54', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"tm\", \"nm\": \"Trim Path\", \"mn\": \"{dcd7570f-5105-485b-bd43-42ad990b01e8}\", \"s\": {\"a\": 0, \"k\": 0}, \"e\": {\"a\": 0, \"k\": 100}, \"o\": {\"a\": 0, \"k\": 0}, \"m\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.98, 0.28]}, \"lc\": 2, \"lj\": 2, \"ml\": 3, \"w\": {\"a\": 0, \"k\": 20}, \"d\": [{\"n\": \"o\", \"nm\": \"offset\", \"v\": {\"a\": 0, \"k\": 0}}, {\"n\": \"d\", \"nm\": \"dash\", \"v\": {\"a\": 0, \"k\": 100}}, {\"n\": \"g\", \"nm\": \"gap\", \"v\": {\"a\": 0, \"k\": 0}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { var shape = lottie.layers[0].shapes[2]; shape.c.k = [data[\"Red\"], data[\"Green\"], data[\"Blue\"]]; shape.o.k = data[\"Opacity\"]; shape.w.k = data[\"Width\"]; shape.r = Number(data[\"Fill Rule\"]); shape.lc = Number(data[\"Line Cap\"]); shape.lj = Number(data[\"Line Join\"]); shape.ml = data[\"Miter Limit\"]; shape.d[0].v.k = data[\"Dash Offset\"]; shape.d[1].v.k = data[\"Dash Length\"]; shape.d[2].v.k = data[\"Dash Gap\"];this.json_viewer_contents = lottie.layers[0].shapes[2]; }, {} ); Gradients Gradient fill and gradient stroke have the same attributes as fill and stroke but remove color ( c ) and add the following: Attribute Type Description s Animated Vector Starting point for the gradient e Animated Vector End point for the gradient t Gradient Type Type of the gradient g Gradient Colors Gradient colors If it's a radial gradient, s refers to the center of the gradient, and the style object may have these additional properties: Attribute Type Description h Animated number Highlight Length, as a percentage between s and e a Animated number Highlight Angle, relative to the direction from s to e Basically the radial highlight position is defined in polar coordinates relative to s . Gradient Colors Attribute Type Description View Schema k Animated Gradient Gradient Colors p integer Number of Colors Since gradient values might have different representation based on whether they have transparency or not, you need to check p to determine whether a keyframe value has transparency. Gradient Example Start X 256 Start Y 496 End X 256 End Y 16 Type Linear Radial Highlight 0 Highlight Angle 0 Show JSON var lottie_player_55 = new PlaygroundPlayer( 55, 'playground_55_8', 'lottie_target_55', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{3da63a46-0ec5-45b8-90fb-d31c5614d5be}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 1, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer 2\", \"mn\": \"{04a8ef87-75fd-451c-868b-7413969c8ad9}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"e\", \"mn\": \"{078a0bf7-08ce-49f7-9dca-c473ad9ff09d}\", \"it\": [{\"ty\": \"gr\", \"nm\": \"e\", \"mn\": \"{efb1ff36-fe2b-4939-97a5-d75a167d003b}\", \"it\": [{\"ty\": \"gr\", \"nm\": \"e\", \"mn\": \"{759da60a-0439-496c-89a9-66e1d721ceb7}\", \"it\": [{\"ty\": \"gr\", \"nm\": \"\", \"mn\": \"{b56ba91b-5ef9-40d2-a1da-27265d105c7a}\", \"it\": [{\"ty\": \"sh\", \"nm\": \"\", \"mn\": \"{020e377d-646e-45f6-830f-756cfff57aa9}\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [[3.7994567051676293, -7.097994637365934], [5.33994951436286, -6.707992504500113], [6.327946284594615, -5.609490432573314], [6.672442201680043, -3.952002315682892], [6.672442201680043, -3.262995246756169], [1.901449879997, -3.262995246756169], [2.505949758118953, -1.4624984765244131], [4.124444517362934, -0.8449957342683567], [5.300948539338484, -0.968496282719568], [6.360449636240906, -1.326002681317033], [6.360449636240906, -0.32500304695117377], [5.307446162716568, 0.019500487512187806], [4.072448295582389, 0.12999817182929574], [2.3239477471311782, -0.2729992077926948], [1.1409537191554788, -1.4755013406585165], [0.7184558520213006, -3.4319943936098403], [1.1019527441311032, -5.395000304695118], [2.1809543285457136, -6.655996282719569], [3.7994567051676293, -7.097994637365934]], \"i\": [[0, 0], [-0.4290005687642191, -0.2600014219105473], [-0.22966394472361795, -0.4723332927073187], [0, -0.6326587852196304], [0, 0], [0, 0], [-0.3856627665691641, -0.411668494837371], [-0.69333373959349, 0], [-0.34233512087802254, 0.08233369896747422], [-0.3639989437235931, 0.15600390009750242], [0, 0], [0.34666686979674477, -0.07366512287807196], [0.47666504162604095, 0], [0.506997440561014, 0.2686649197479937], [0.281665244756119, 0.5330031688292207], [0, 0.7713255331383286], [-0.25566459473986836, 0.5459984155853892], [-0.4636697948698716, 0.29466556976424485], [-0.6153317895447388, 0]], \"o\": [[0.5979946373659342, 0], [0.4290005687642182, 0.2600014219105473], [0.22966394472361795, 0.47233329270731783], [0, 0], [0, 0], [0.017337152178804383, 0.7886626853171328], [0.3856627665691641, 0.411668494837371], [0.4420008937723443, 0], [0.34233512087802165, -0.08233369896747411], [0, 0], [-0.35533544588614685, 0.15600390009750242], [-0.34666686979674477, 0.07366512287807195], [-0.6586695917397929, 0], [-0.5069974405610138, -0.26866491974799367], [-0.28166524475611887, -0.5330031688292207], [0, -0.7626721918047954], [0.2556645947398686, -0.5459984155853901], [0.46366979486987203, -0.29466556976424396], [0, 0]]}}}, {\"ty\": \"sh\", \"nm\": \"\", \"mn\": \"{b3f5759c-30aa-4352-a4ea-23b71ead28ad}\", \"ks\": {\"a\": 0, \"k\": {\"c\": false, \"v\": [[3.7864462236555916, -6.162001706292657], [2.4929545113627842, -5.635496160841521], [1.9274556082652068, -4.172997684317108], [5.476452926948174, -4.172997684317108], [5.06045268319208, -5.609498049951249], [3.7864462236555916, -6.162001706292657]], \"i\": [[0, 0], [0.3163344708617717, -0.3510036969674246], [0.06066479786994661, -0.6239952873821846], [0, 0], [0.2686699979999494, 0.36833577089427205], [0.5806676416910426, 0]], \"o\": [[-0.5459933373334334, 0], [-0.3163344708617717, 0.3510036969674246], [0, 0], [-0.008663497837446243, -0.5893311395284879], [-0.2686699979999503, -0.36833577089427205], [0, 0]]}}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"fl\", \"nm\": \"Fill 1\", \"mn\": \"{2fcb588a-7de7-4cba-8508-46952f160940}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.9411764705882353, 0.11372549019607843, 0.0392156862745098]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [-2.7166567164177735, 3.822454790113566]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [256, 16]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"gr\", \"nm\": \"s\", \"mn\": \"{e16b0057-203a-4dab-8e5b-495775987f85}\", \"it\": [{\"ty\": \"gr\", \"nm\": \"s\", \"mn\": \"{07bcfe04-40c2-4636-807c-d64982f7a44d}\", \"it\": [{\"ty\": \"gr\", \"nm\": \"s\", \"mn\": \"{0de90988-3e53-4e7a-8a7d-cb147d0c42b5}\", \"it\": [{\"ty\": \"sh\", \"nm\": \"\", \"mn\": \"{22460e65-f67b-48b8-844b-e361867d003b}\", \"ks\": {\"a\": 0, \"k\": {\"c\": false, \"v\": [[5.645452073801845, -1.923997318682967], [4.891453536338409, -0.39000213286582164], [2.8634485393384836, 0.12999817182929574], [1.608957802070052, 0.013002864134103353], [0.679454876996925, -0.311992565439136], [0.679454876996925, -1.3519931748293708], [1.6869521347408687, -0.968496282719568], [2.8894542676066903, -0.7929995124878122], [4.150450245631141, -1.0724963436585915], [4.540444761119028, -1.820004875121878], [4.3974513425335635, -2.2880013406585165], [3.8839562785944652, -2.7040015844146104], [2.824447564314108, -3.171998049951249], [1.6674516472286809, -3.6919983546463664], [0.9264559738993475, -4.315998720280507], [0.666459630240756, -5.251999268731718], [1.3879548160579016, -6.616995307695193], [3.2794487830945775, -7.097994637365934], [4.468948051826296, -6.9744940889147236], [5.502443420460512, -6.629998171829296], [5.1124489049726245, -5.719995734268357], [4.189443603277582, -6.031995917085427], [3.2014468330458263, -6.162001706292657], [2.128950489387235, -5.934501096902423], [1.7584564614115354, -5.316990737268432], [1.9274556082652068, -4.82950140159754], [2.4929545113627842, -4.439499268731718], [3.552455608265207, -3.9910032907072677], [4.683453414460362, -3.4839982327683194], [5.398450976899423, -2.853500243756094], [5.645452073801845, -1.923997318682967]], \"i\": [[0, 0], [0.5026656916422914, -0.346666869796745], [0.8493376396909924, 0], [0.35099861871546767, 0.07799687179679493], [0.26866999799995006, 0.13866674791869799], [0, 0], [-0.3943313426585666, -0.11699784682117054], [-0.4073367459186481, 0], [-0.2599963436585919, 0.18633122078051945], [0, 0.31200780019500485], [0.09532894572364281, 0.13866674791869782], [0.2470010969024221, 0.13866674791869782], [0.45933804595114847, 0.17333089577239447], [0.32066621978049437, 0.17333597402435075], [0.17333089577239413, 0.24266426973174227], [0, 0.38133609590239725], [-0.48099679054476374, 0.32066621978049437], [-0.779999187479687, 0], [-0.36833577089427294, -0.08233369896747345], [-0.32066114152853853, -0.14733024575614362], [0, 0], [0.32066621978049437, 0.08667052613815329], [0.3379982937073427, 0], [0.24699601865046583, -0.15166707292682258], [0, -0.2600065001625049], [-0.11266609790244764, -0.13433499899997603], [-0.26433317082927044, -0.12566642291057306], [-0.4420008937723443, -0.17333089577239447], [-0.3119976436910923, -0.1733359740243503], [-0.16466739793494867, -0.24699601865046628], [0, -0.3726725980649519]], \"o\": [[0, 0.6759965874146854], [-0.5026656916422914, 0.3466668697967449], [-0.4853285394634863, 0], [-0.3509986187154679, -0.07799687179679493], [0, 0], [0.27733349583739597, 0.13866674791869804], [0.3943313426585664, 0.11699784682117043], [0.5806676416910421, 0], [0.2599963436585915, -0.18633122078051967], [0, -0.17333089577239424], [-0.09532894572364281, -0.13866674791869826], [-0.24700109690242256, -0.13866674791869826], [-0.45066439160979055, -0.17333089577239447], [-0.3206662197804946, -0.1733359740243503], [-0.17333089577239436, -0.24266426973174315], [0, -0.5893311395284879], [0.4809967905447634, -0.3206662197804935], [0.4246637415935397, 0], [0.36833577089427205, 0.08233369896747433], [0, 0], [-0.2946706480162007, -0.12132959573989321], [-0.3206662197804948, -0.08667052613815329], [-0.4680015437885947, 0], [-0.2469960186504665, 0.15166707292682347], [0, 0.1906578914472865], [0.11266609790244786, 0.13433499899997514], [0.26433317082927044, 0.12566642291057306], [0.44200089377234475, 0.16466739793494822], [0.3119976436910914, 0.17333597402435075], [0.16466739793494867, 0.24699601865046583], [0, 0]]}}}, {\"ty\": \"fl\", \"nm\": \"Fill 1\", \"mn\": \"{2fcb588a-7de7-4cba-8508-46952f160940}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.9411764705882353, 0.11372549019607843, 0.0392156862745098]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [-2.7166567164177735, 3.822454790113566]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [256, 496]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}, {\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{a5276bb6-4d7c-4b4f-b371-a0e14a279176}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Gradient\", \"mn\": \"{9df3ba96-24a3-412e-abd4-e64e2e76e6df}\", \"it\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"mn\": \"{20934ad0-1c22-4752-a5b1-be99889ea79a}\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [512, 512]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"gf\", \"nm\": \"Gradient Fill\", \"o\": {\"a\": 0, \"k\": 100}, \"r\": 1, \"s\": {\"a\": 0, \"k\": [256, 496]}, \"e\": {\"a\": 0, \"k\": [256, 16]}, \"t\": 1, \"h\": {\"a\": 0, \"k\": 0}, \"a\": {\"a\": 0, \"k\": 0}, \"g\": {\"p\": 3, \"k\": {\"a\": 0, \"k\": [0, 0.7686274509803922, 0.8509803921568627, 0.9607843137254902, 0.5, 0.19600213626306554, 0.31400015259021896, 0.6899977111467155, 1, 0.16099794003204396, 0.18399328603036547, 0.45900663767452504, 0, 1, 0.5, 1, 1, 1]}}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [257.4805970149254, 255.76119402985074]}, \"p\": {\"a\": 0, \"k\": [257.4805970149254, 255.76119402985074]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { var gradient = lottie.layers[1].shapes[0].it[1]; var start_marker = lottie.layers[0].shapes[1].it[1]; var end_marker = lottie.layers[0].shapes[0].it[1]; gradient.s.k = start_marker.p.k = [data[\"Start X\"], data[\"Start Y\"]]; gradient.e.k = end_marker.p.k = [data[\"End X\"], data[\"End Y\"]]; gradient.t = Number(data[\"Type\"]); gradient.h.k = data[\"Highlight\"]; gradient.a.k = data[\"Highlight Angle\"];this.json_viewer_contents = lottie.layers[1].shapes[0].it[1]; }, {} ); No Style Represents a style for shapes without fill or stroke. Attribute Type Description ty string = 'no' Shape Type Group A group is a shape that can contain other shapes (including other groups). The usual contents of a group are: Shapes Style Transform For example, if you want to have a red rectangle with a black outline, its group will contain A Rectangle defining the actual shape of the rectangle A Fill for the color red A Stroke for the black outline A Transform for the group transform While the contents may vary, a group must always end with a Transform shape . The attributes of a Group are: Attribute Type Description View Schema np number Number of properties it Array of shapes Shapes Transform Shape Basically the same as Transform but with the ty attribute. Modifiers Modifiers process their siblings and alter the path defined by shapes . Repeater This is a bit different compared from other modifiers, since it will take into account style as well. The effect of a Repeater is to duplicate the other shapes a number of times applying a transform for each copy. Also has the attributes from Modifier . Attribute Type Description ty string = 'rp' Shape Type c Animated number Number of copies o Animated number Offset m Composite Stacking order tr Repeater Transform Transform applied to each copy The transform is multiplied by o + 1 (where o is the Offset property above). So if o is 0 , the first instance shown by the Repeater is at its starting location. If it's 1 , the first instance has the matrix applied to it. Other values multiply the initial transform accordingly. Repeater Transform Same as a regular Transform but instead of a single opacity value ( o ), it has two: Attribute Type Description so Animated number Start Opacity eo Animated number End Opacity The first copy will use so , the last eo , and copies between them will have an interpolated value. Copies 4 Start Opacity 100 End Opacity 50 Position x 130 Position y 0 Rotation 137 Offset 0 Composite Above Below Show JSON var lottie_player_56 = new PlaygroundPlayer( 56, 'playground_56_9', 'lottie_target_56', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{33a02914-c5a9-4c4e-a0bd-0ec07f05b204}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{9eb62fdc-6d5b-4771-94c0-ebdafbd7a54e}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{bfbf6254-ff78-4d00-9d09-eafe4e34b732}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{5a453691-6b60-4bd3-bc43-e28b7a0ebc48}\", \"p\": {\"a\": 0, \"k\": [80, 120]}, \"or\": {\"a\": 0, \"k\": 80}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{b0ba4cf0-3a1b-45a3-8912-d0ed2bdd2082}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{0c2313ae-ccff-4e71-9e00-81649390d850}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"r\": 1}, {\"ty\": \"rp\", \"nm\": \"Repeater\", \"mn\": \"{a9e13270-7dd8-4520-b5a1-c1c9cf96286b}\", \"c\": {\"a\": 0, \"k\": 4}, \"o\": {\"a\": 0, \"k\": 0}, \"m\": 1, \"tr\": {\"a\": {\"a\": 0, \"k\": [80, 120]}, \"p\": {\"a\": 0, \"k\": [130, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 137.508}, \"so\": {\"a\": 0, \"k\": 100}, \"eo\": {\"a\": 0, \"k\": 50}}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [65.33731343283583, 117.77910447761194]}, \"p\": {\"a\": 0, \"k\": [73.93432835820896, 93.70746268656717]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { lottie.layers[0].shapes[0].it[3].c.k = data[\"Copies\"]; lottie.layers[0].shapes[0].it[3].tr.so.k = data[\"Start Opacity\"]; lottie.layers[0].shapes[0].it[3].tr.eo.k = data[\"End Opacity\"]; lottie.layers[0].shapes[0].it[3].tr.p.k[0] = data[\"Position x\"]; lottie.layers[0].shapes[0].it[3].tr.p.k[1] = data[\"Position y\"]; lottie.layers[0].shapes[0].it[3].tr.r.k = data[\"Rotation\"]; lottie.layers[0].shapes[0].it[3].o.k = data[\"Offset\"]; lottie.layers[0].shapes[0].it[3].m = Number(data[\"Composite\"]);this.json_viewer_contents = lottie.layers[0].shapes[0].it[3]; }, {} ); Trim Path This is mostly useful for shapes with a stroke and not a fill. It takes the path defined by shapes and only shows a segment of the resulting bezier data. Also has the attributes from Modifier . Attribute Type Description ty string = 'tm' Shape Type s Animated number Segment start e Animated number Segment end o Animated number Offset m Trim Multiple Shapes How to treat multiple copies s and e go from 0 to 100 , 0 being at the beginning of the path and 100 at the end. The displayed segment is what lays between the two. o is an offset from the start, to allow values to wrap around. Its value goes from 0 (start of the path) to 360 (end of the path). It looks like an angle but it isn't really, the difference between o and s is that with o you can go over 360 or below 0 to shift the whole segment along the path. Here is an interactive example: Start 0 End 50 Offset 0 Multiple Shapes Simultaneously Individually Show JSON var lottie_player_57 = new PlaygroundPlayer( 57, 'playground_57_5', 'lottie_target_57', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [128, 128]}, \"or\": {\"a\": 0, \"k\": 100}, \"ir\": {\"a\": 0, \"k\": 50}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{74587b40-1ef1-445d-b9ab-02b8a42a96aa}\", \"p\": {\"a\": 0, \"k\": [384, 128]}, \"s\": {\"a\": 0, \"k\": [200, 200]}}, {\"ty\": \"rc\", \"nm\": \"Rect\", \"mn\": \"{0776f2df-2619-415c-b10d-f648f2edfa0f}\", \"d\": 1, \"p\": {\"a\": 0, \"k\": [128, 384]}, \"s\": {\"a\": 0, \"k\": [200, 200]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"sr\", \"nm\": \"Triangle\", \"mn\": \"{db373594-d0ae-44ff-9295-30ff72616af2}\", \"p\": {\"a\": 0, \"k\": [384, 384]}, \"or\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 3}, \"sy\": 2, \"os\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"tm\", \"nm\": \"Trim Path\", \"mn\": \"{dcd7570f-5105-485b-bd43-42ad990b01e8}\", \"s\": {\"a\": 0, \"k\": 0}, \"e\": {\"a\": 0, \"k\": 50}, \"o\": {\"a\": 0, \"k\": 0}, \"m\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 20}}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { lottie.layers[0].shapes[4].s.k = data[\"Start\"]; lottie.layers[0].shapes[4].e.k = data[\"End\"]; lottie.layers[0].shapes[4].o.k = data[\"Offset\"]; lottie.layers[0].shapes[4].m = Number(data[\"Multiple Shapes\"]);this.json_viewer_contents = lottie.layers[0].shapes[4]; }, {} ); Rounded Corners Self explanatory Also has the attributes from Modifier . Attribute Type Description ty string = 'rd' Shape Type r Animated number Radius Radius 50 Show JSON var lottie_player_58 = new PlaygroundPlayer( 58, 'playground_58_2', 'lottie_target_58', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{9199543e-3552-4e51-a802-623f2a4a2ca1}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 222.72242736816406}, \"ir\": {\"a\": 0, \"k\": 111.36121368408203}, \"r\": {\"a\": 0, \"k\": 358.67291259765625}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"rd\", \"nm\": \"Rounded Corners\", \"mn\": \"{dcd7570f-5105-485b-bd43-42ad990b01e8}\", \"r\": {\"a\": 0, \"k\": 50}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"fl\", \"hd\": true, \"nm\": \"Fill\", \"mn\": \"{a1bcc159-6916-4718-841d-a99140c0e74b}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { lottie.layers[0].shapes[0].it[1].r.k = data[\"Radius\"];this.json_viewer_contents = lottie.layers[0].shapes[0].it[1]; }, {} ); Pucker / Bloat Interpolates bezier vertices towards the center of the shape, and tangent handles away from it (or vice-versa). Attribute Type Description ty string = 'pb' Shape Type a Animated number Amount as a percentage When a is 0 , nothing changes. When a is positive, the vertices are pulled towards the center, with 100 being at the center. And the tangents are pushed away. When a is negative the vertices are pushed away from the center with 100 being twice far away from the center. And the tangents are pulled towards the center. Amount 50 Show JSON var lottie_player_59 = new PlaygroundPlayer( 59, 'playground_59_2', 'lottie_target_59', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{9199543e-3552-4e51-a802-623f2a4a2ca1}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 160}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 2, \"os\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"pb\", \"nm\": \"Inflate and Deflate\", \"mn\": \"{b4af429a-546e-4728-a869-711a404c55ae}\", \"a\": {\"a\": 0, \"k\": 50}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"fl\", \"hd\": true, \"nm\": \"Fill\", \"mn\": \"{a1bcc159-6916-4718-841d-a99140c0e74b}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { lottie.layers[0].shapes[0].it[1].a.k = data[\"Amount\"];this.json_viewer_contents = lottie.layers[0].shapes[0].it[1]; }, {} ); Twist Attribute Type Description ty string = 'tw' Shape Type a Animated number Angle c Animated Vector Center Merge Boolean operator on shapes Attribute Type Description ty string = 'mm' Shape Type mm Merge Mode Merge Mode Offset Path Interpolates the shape with its center point and bezier tangents with the opposite direction Attribute Type Description ty string = 'op' Shape Type a Animated number Amount lj Line Join Line Join ml Animated number Miter Limit Zig Zag Changes the edges of affected shapes into a series of peaks and valleys of uniform size Attribute Type Description ty string = 'zz' Shape Type r Animated number Number of ridges per segment s Animated number Distance between peaks and troughs pt Animated number Point type (1 = corner, 2 = smooth)","title":"Shapes"},{"location":"shapes/#shape-elements","text":"Lottie considers everything related to vector data as a \"shape\" but I think it's worth distinguishing across a few categories: Shapes These provide only the shape information, but no styling Style These provide styling info (like fill and stroke) Group This is a shape that contains other shape Modifier These change other shapes Transform Special shape that defines the transforms in a group shape All shapes have the following properties: Attribute Type Description nm string Name, as seen from editors and the like mn string Match name, used in expressions ty string Shape type (see values below) hd boolean Whether the shape is hidden bm Blend Mode Blend Mode ix integer Index used in expressions cl string CSS class used by the SVG renderer ln string id attribute used by the SVG renderer","title":"Shape Elements"},{"location":"shapes/#shape-types","text":"ty Shape rc Rectangle el Ellipse sr PolyStar sh Path fl Fill st Stroke gf Gradient Fill gs Gradient Stroke no No Style gr Group tr Transform rp Repeater tm Trim rd Rounded Corners pb Pucker / Bloat mm Merge tw Twist op Offset Path zz Zig Zag","title":"Shape Types"},{"location":"shapes/#shape","text":"These shapes only define path data, to actually show something, they must be followed by some style shape . They have a d attribute which specifies the drawing direction, which can be seen when using Trim Path . Attribute Type Description d Shape Direction Direction the shape is drawn as, mostly relevant when using trim path","title":"Shape"},{"location":"shapes/#rectangle","text":"A rectangle, defined by its center point and size. Attribute Type Description ty string = 'rc' Shape Type p Animated Position Center of the rectangle s Animated Vector Size r Animated number Rounded corners radius Position x 256 Position y 256 Width 256 Height 256 Roundness 0 Show JSON var lottie_player_50 = new PlaygroundPlayer( 50, 'playground_50_6', 'lottie_target_50', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { lottie.layers[0].shapes[0].it[0].p.k = [ data[\"Position x\"], data[\"Position y\"] ]; lottie.layers[0].shapes[0].it[0].s.k = [ data[\"Width\"], data[\"Height\"] ]; lottie.layers[0].shapes[0].it[0].r.k = data[\"Roundness\"];this.json_viewer_contents = lottie.layers[0].shapes[0].it[0]; }, {} );","title":"Rectangle"},{"location":"shapes/#ellipse","text":"Attribute Type Description ty string = 'el' Shape Type p Animated Position Position s Animated Vector Size Position x 256 Position y 256 Width 256 Height 256 Show JSON var lottie_player_51 = new PlaygroundPlayer( 51, 'playground_51_5', 'lottie_target_51', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"el\", \"nm\": \"Ellipse\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [256, 256]}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { lottie.layers[0].shapes[0].it[0].p.k = [ data[\"Position x\"], data[\"Position y\"] ]; lottie.layers[0].shapes[0].it[0].s.k = [ data[\"Width\"], data[\"Height\"] ];this.json_viewer_contents = lottie.layers[0].shapes[0].it[0]; }, {} );","title":"Ellipse"},{"location":"shapes/#polystar","text":"Regular polygon or star. Attribute Type Description ty string = 'sr' Shape Type p Animated Position Position or Animated number Outer Radius os Animated number Outer Roundness as a percentage r Animated number Rotation, clockwise in degrees pt Animated number Points sy Star Type Star type, 1 for Star, 2 for Polygon If sy is 1 (star) you also have attributes defining the inner ends of the star: Attribute Type Description ir Animated number Inner Radius is Animated number Inner Roundness as a percentage Points 5 Rotation 0 Outer Radius 200 Inner Radius 100 Outer Roundness 0 Inner Roundness 0 Type Star Polygon Show JSON var lottie_player_52 = new PlaygroundPlayer( 52, 'playground_52_8', 'lottie_target_52', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [{\"ty\": 4, \"ddd\": 0, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ip\": 0, \"op\": 180, \"ind\": 0, \"st\": 0, \"sr\": 1, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{9199543e-3552-4e51-a802-623f2a4a2ca1}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.979995422293431, 0.28000305180437934]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { var star = { \"ty\": \"sr\", \"nm\": \"PolyStar\", \"sy\": Number(data[\"Type\"]), \"p\": { \"a\": 0, \"k\": [ 249.3134328358209, 254.47164179104476 ] }, \"r\": { \"a\": 0, \"k\": data[\"Rotation\"] }, \"pt\": { \"a\": 0, \"k\": data[\"Points\"] }, \"or\": { \"a\": 0, \"k\": data[\"Outer Radius\"] }, \"os\": { \"a\": 0, \"k\": data[\"Outer Roundness\"] }, }; if ( data[\"Type\"] == \"1\" ) { star = { ...star, \"ir\": { \"a\": 0, \"k\": data[\"Inner Radius\"] }, \"is\": { \"a\": 0, \"k\": data[\"Inner Roundness\"] }, }; } lottie.layers[0].shapes[0].it[0] = star;this.json_viewer_contents = lottie.layers[0].shapes[0].it[0]; }, {} );","title":"PolyStar"},{"location":"shapes/#path","text":"Bezier path, note that it's a continuous shape, to have multiple shapes like when you need holes or gaps you need to create multiple Path shapes and group them together. Attribute Type Description ty string = 'sh' Shape Type ks Animated Bezier Bezier path","title":"Path"},{"location":"shapes/#style","text":"These apply a style (such as fill stroke) to the paths defined by the shapes . Each style is applied to all preceding shapes in the same group / layer. In most formats the style is usually defined as a property of a shape, in lottie they are separate and allows for more flexibility. Some examples of the added flexibility would be a shape with multiple strokes, or a gradient fading into a solid color.","title":"Style"},{"location":"shapes/#fill","text":"Solid fill color. Attribute Type Description ty string = 'fl' Shape Type o Animated number Opacity, 100 means fully opaque c Animated Color Color r Fill Rule Fill Rule Red 1 Green 0.98 Blue 0.28 Opacity 100 Fill Rule Non Zero Even Odd Show JSON var lottie_player_53 = new PlaygroundPlayer( 53, 'playground_53_6', 'lottie_target_53', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{f5d94f54-bb8f-4f07-be45-232ebd4b9eb1}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{4b0993ed-e35b-48a5-ab12-687dbc147c7c}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Path\", \"mn\": \"{29196ff2-0a65-48b4-a450-f9fbc3a3640d}\", \"it\": [{\"ty\": \"sh\", \"nm\": \"Path\", \"mn\": \"{bb7e6c60-755e-4a21-a7ba-bd054feab5c7}\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [[125.51641791044776, 452.20298507462684], [240.71641791044777, 38.6865671641791], [435.8686567164179, 447.9044776119403], [42.125373134328356, 173.65970149253732], [460.8, 156.46567164179103]], \"i\": [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]], \"o\": [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]]}}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{3af40b83-15f6-4f69-aa2a-96acd03eb3b6}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.98, 0.28]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [251.46268656716418, 245.4447761194029]}, \"p\": {\"a\": 0, \"k\": [251.46268656716418, 245.4447761194029]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { var shape = lottie.layers[0].shapes[0].it[1]; shape.c.k = [data[\"Red\"], data[\"Green\"], data[\"Blue\"]]; shape.o.k = data[\"Opacity\"]; shape.r = Number(data[\"Fill Rule\"]);this.json_viewer_contents = lottie.layers[0].shapes[0].it[1]; }, {} );","title":"Fill"},{"location":"shapes/#stroke","text":"Defines a stroke. Attribute Type Description ty string = 'st' Shape Type lc Line Cap Line Cap lj Line Join Line Join ml number Miter Limit ml2 Animated number Animatable alternative to ml o Animated number Opacity, 100 means fully opaque w Animated number Stroke width d array of Stroke Dash Dashed line definition c Animated Color Stroke color","title":"Stroke"},{"location":"shapes/#stroke-dashes","text":"Defined as a sequence of alternating dashes and gaps. Attribute Type Description n Stroke Dash Type Dash Type v Animated number Length of the dash Red 1 Green 0.98 Blue 0.28 Width 32 Opacity 100 Line Cap Butt Round Square Line Join Miter Round Bevel Miter Limit 3 Dash Offset 0 Dash Length 100 Dash Gap 0 Show JSON var lottie_player_54 = new PlaygroundPlayer( 54, 'playground_54_12', 'lottie_target_54', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"tm\", \"nm\": \"Trim Path\", \"mn\": \"{dcd7570f-5105-485b-bd43-42ad990b01e8}\", \"s\": {\"a\": 0, \"k\": 0}, \"e\": {\"a\": 0, \"k\": 100}, \"o\": {\"a\": 0, \"k\": 0}, \"m\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.98, 0.28]}, \"lc\": 2, \"lj\": 2, \"ml\": 3, \"w\": {\"a\": 0, \"k\": 20}, \"d\": [{\"n\": \"o\", \"nm\": \"offset\", \"v\": {\"a\": 0, \"k\": 0}}, {\"n\": \"d\", \"nm\": \"dash\", \"v\": {\"a\": 0, \"k\": 100}}, {\"n\": \"g\", \"nm\": \"gap\", \"v\": {\"a\": 0, \"k\": 0}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { var shape = lottie.layers[0].shapes[2]; shape.c.k = [data[\"Red\"], data[\"Green\"], data[\"Blue\"]]; shape.o.k = data[\"Opacity\"]; shape.w.k = data[\"Width\"]; shape.r = Number(data[\"Fill Rule\"]); shape.lc = Number(data[\"Line Cap\"]); shape.lj = Number(data[\"Line Join\"]); shape.ml = data[\"Miter Limit\"]; shape.d[0].v.k = data[\"Dash Offset\"]; shape.d[1].v.k = data[\"Dash Length\"]; shape.d[2].v.k = data[\"Dash Gap\"];this.json_viewer_contents = lottie.layers[0].shapes[2]; }, {} );","title":"Stroke Dashes"},{"location":"shapes/#gradients","text":"Gradient fill and gradient stroke have the same attributes as fill and stroke but remove color ( c ) and add the following: Attribute Type Description s Animated Vector Starting point for the gradient e Animated Vector End point for the gradient t Gradient Type Type of the gradient g Gradient Colors Gradient colors If it's a radial gradient, s refers to the center of the gradient, and the style object may have these additional properties: Attribute Type Description h Animated number Highlight Length, as a percentage between s and e a Animated number Highlight Angle, relative to the direction from s to e Basically the radial highlight position is defined in polar coordinates relative to s .","title":"Gradients"},{"location":"shapes/#gradient-colors","text":"Attribute Type Description View Schema k Animated Gradient Gradient Colors p integer Number of Colors Since gradient values might have different representation based on whether they have transparency or not, you need to check p to determine whether a keyframe value has transparency.","title":"Gradient Colors"},{"location":"shapes/#gradient-example","text":"Start X 256 Start Y 496 End X 256 End Y 16 Type Linear Radial Highlight 0 Highlight Angle 0 Show JSON var lottie_player_55 = new PlaygroundPlayer( 55, 'playground_55_8', 'lottie_target_55', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{3da63a46-0ec5-45b8-90fb-d31c5614d5be}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 1, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer 2\", \"mn\": \"{04a8ef87-75fd-451c-868b-7413969c8ad9}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"e\", \"mn\": \"{078a0bf7-08ce-49f7-9dca-c473ad9ff09d}\", \"it\": [{\"ty\": \"gr\", \"nm\": \"e\", \"mn\": \"{efb1ff36-fe2b-4939-97a5-d75a167d003b}\", \"it\": [{\"ty\": \"gr\", \"nm\": \"e\", \"mn\": \"{759da60a-0439-496c-89a9-66e1d721ceb7}\", \"it\": [{\"ty\": \"gr\", \"nm\": \"\", \"mn\": \"{b56ba91b-5ef9-40d2-a1da-27265d105c7a}\", \"it\": [{\"ty\": \"sh\", \"nm\": \"\", \"mn\": \"{020e377d-646e-45f6-830f-756cfff57aa9}\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [[3.7994567051676293, -7.097994637365934], [5.33994951436286, -6.707992504500113], [6.327946284594615, -5.609490432573314], [6.672442201680043, -3.952002315682892], [6.672442201680043, -3.262995246756169], [1.901449879997, -3.262995246756169], [2.505949758118953, -1.4624984765244131], [4.124444517362934, -0.8449957342683567], [5.300948539338484, -0.968496282719568], [6.360449636240906, -1.326002681317033], [6.360449636240906, -0.32500304695117377], [5.307446162716568, 0.019500487512187806], [4.072448295582389, 0.12999817182929574], [2.3239477471311782, -0.2729992077926948], [1.1409537191554788, -1.4755013406585165], [0.7184558520213006, -3.4319943936098403], [1.1019527441311032, -5.395000304695118], [2.1809543285457136, -6.655996282719569], [3.7994567051676293, -7.097994637365934]], \"i\": [[0, 0], [-0.4290005687642191, -0.2600014219105473], [-0.22966394472361795, -0.4723332927073187], [0, -0.6326587852196304], [0, 0], [0, 0], [-0.3856627665691641, -0.411668494837371], [-0.69333373959349, 0], [-0.34233512087802254, 0.08233369896747422], [-0.3639989437235931, 0.15600390009750242], [0, 0], [0.34666686979674477, -0.07366512287807196], [0.47666504162604095, 0], [0.506997440561014, 0.2686649197479937], [0.281665244756119, 0.5330031688292207], [0, 0.7713255331383286], [-0.25566459473986836, 0.5459984155853892], [-0.4636697948698716, 0.29466556976424485], [-0.6153317895447388, 0]], \"o\": [[0.5979946373659342, 0], [0.4290005687642182, 0.2600014219105473], [0.22966394472361795, 0.47233329270731783], [0, 0], [0, 0], [0.017337152178804383, 0.7886626853171328], [0.3856627665691641, 0.411668494837371], [0.4420008937723443, 0], [0.34233512087802165, -0.08233369896747411], [0, 0], [-0.35533544588614685, 0.15600390009750242], [-0.34666686979674477, 0.07366512287807195], [-0.6586695917397929, 0], [-0.5069974405610138, -0.26866491974799367], [-0.28166524475611887, -0.5330031688292207], [0, -0.7626721918047954], [0.2556645947398686, -0.5459984155853901], [0.46366979486987203, -0.29466556976424396], [0, 0]]}}}, {\"ty\": \"sh\", \"nm\": \"\", \"mn\": \"{b3f5759c-30aa-4352-a4ea-23b71ead28ad}\", \"ks\": {\"a\": 0, \"k\": {\"c\": false, \"v\": [[3.7864462236555916, -6.162001706292657], [2.4929545113627842, -5.635496160841521], [1.9274556082652068, -4.172997684317108], [5.476452926948174, -4.172997684317108], [5.06045268319208, -5.609498049951249], [3.7864462236555916, -6.162001706292657]], \"i\": [[0, 0], [0.3163344708617717, -0.3510036969674246], [0.06066479786994661, -0.6239952873821846], [0, 0], [0.2686699979999494, 0.36833577089427205], [0.5806676416910426, 0]], \"o\": [[-0.5459933373334334, 0], [-0.3163344708617717, 0.3510036969674246], [0, 0], [-0.008663497837446243, -0.5893311395284879], [-0.2686699979999503, -0.36833577089427205], [0, 0]]}}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"fl\", \"nm\": \"Fill 1\", \"mn\": \"{2fcb588a-7de7-4cba-8508-46952f160940}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.9411764705882353, 0.11372549019607843, 0.0392156862745098]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [-2.7166567164177735, 3.822454790113566]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [256, 16]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"gr\", \"nm\": \"s\", \"mn\": \"{e16b0057-203a-4dab-8e5b-495775987f85}\", \"it\": [{\"ty\": \"gr\", \"nm\": \"s\", \"mn\": \"{07bcfe04-40c2-4636-807c-d64982f7a44d}\", \"it\": [{\"ty\": \"gr\", \"nm\": \"s\", \"mn\": \"{0de90988-3e53-4e7a-8a7d-cb147d0c42b5}\", \"it\": [{\"ty\": \"sh\", \"nm\": \"\", \"mn\": \"{22460e65-f67b-48b8-844b-e361867d003b}\", \"ks\": {\"a\": 0, \"k\": {\"c\": false, \"v\": [[5.645452073801845, -1.923997318682967], [4.891453536338409, -0.39000213286582164], [2.8634485393384836, 0.12999817182929574], [1.608957802070052, 0.013002864134103353], [0.679454876996925, -0.311992565439136], [0.679454876996925, -1.3519931748293708], [1.6869521347408687, -0.968496282719568], [2.8894542676066903, -0.7929995124878122], [4.150450245631141, -1.0724963436585915], [4.540444761119028, -1.820004875121878], [4.3974513425335635, -2.2880013406585165], [3.8839562785944652, -2.7040015844146104], [2.824447564314108, -3.171998049951249], [1.6674516472286809, -3.6919983546463664], [0.9264559738993475, -4.315998720280507], [0.666459630240756, -5.251999268731718], [1.3879548160579016, -6.616995307695193], [3.2794487830945775, -7.097994637365934], [4.468948051826296, -6.9744940889147236], [5.502443420460512, -6.629998171829296], [5.1124489049726245, -5.719995734268357], [4.189443603277582, -6.031995917085427], [3.2014468330458263, -6.162001706292657], [2.128950489387235, -5.934501096902423], [1.7584564614115354, -5.316990737268432], [1.9274556082652068, -4.82950140159754], [2.4929545113627842, -4.439499268731718], [3.552455608265207, -3.9910032907072677], [4.683453414460362, -3.4839982327683194], [5.398450976899423, -2.853500243756094], [5.645452073801845, -1.923997318682967]], \"i\": [[0, 0], [0.5026656916422914, -0.346666869796745], [0.8493376396909924, 0], [0.35099861871546767, 0.07799687179679493], [0.26866999799995006, 0.13866674791869799], [0, 0], [-0.3943313426585666, -0.11699784682117054], [-0.4073367459186481, 0], [-0.2599963436585919, 0.18633122078051945], [0, 0.31200780019500485], [0.09532894572364281, 0.13866674791869782], [0.2470010969024221, 0.13866674791869782], [0.45933804595114847, 0.17333089577239447], [0.32066621978049437, 0.17333597402435075], [0.17333089577239413, 0.24266426973174227], [0, 0.38133609590239725], [-0.48099679054476374, 0.32066621978049437], [-0.779999187479687, 0], [-0.36833577089427294, -0.08233369896747345], [-0.32066114152853853, -0.14733024575614362], [0, 0], [0.32066621978049437, 0.08667052613815329], [0.3379982937073427, 0], [0.24699601865046583, -0.15166707292682258], [0, -0.2600065001625049], [-0.11266609790244764, -0.13433499899997603], [-0.26433317082927044, -0.12566642291057306], [-0.4420008937723443, -0.17333089577239447], [-0.3119976436910923, -0.1733359740243503], [-0.16466739793494867, -0.24699601865046628], [0, -0.3726725980649519]], \"o\": [[0, 0.6759965874146854], [-0.5026656916422914, 0.3466668697967449], [-0.4853285394634863, 0], [-0.3509986187154679, -0.07799687179679493], [0, 0], [0.27733349583739597, 0.13866674791869804], [0.3943313426585664, 0.11699784682117043], [0.5806676416910421, 0], [0.2599963436585915, -0.18633122078051967], [0, -0.17333089577239424], [-0.09532894572364281, -0.13866674791869826], [-0.24700109690242256, -0.13866674791869826], [-0.45066439160979055, -0.17333089577239447], [-0.3206662197804946, -0.1733359740243503], [-0.17333089577239436, -0.24266426973174315], [0, -0.5893311395284879], [0.4809967905447634, -0.3206662197804935], [0.4246637415935397, 0], [0.36833577089427205, 0.08233369896747433], [0, 0], [-0.2946706480162007, -0.12132959573989321], [-0.3206662197804948, -0.08667052613815329], [-0.4680015437885947, 0], [-0.2469960186504665, 0.15166707292682347], [0, 0.1906578914472865], [0.11266609790244786, 0.13433499899997514], [0.26433317082927044, 0.12566642291057306], [0.44200089377234475, 0.16466739793494822], [0.3119976436910914, 0.17333597402435075], [0.16466739793494867, 0.24699601865046583], [0, 0]]}}}, {\"ty\": \"fl\", \"nm\": \"Fill 1\", \"mn\": \"{2fcb588a-7de7-4cba-8508-46952f160940}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.9411764705882353, 0.11372549019607843, 0.0392156862745098]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [-2.7166567164177735, 3.822454790113566]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [256, 496]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}, {\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{a5276bb6-4d7c-4b4f-b371-a0e14a279176}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Gradient\", \"mn\": \"{9df3ba96-24a3-412e-abd4-e64e2e76e6df}\", \"it\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"mn\": \"{20934ad0-1c22-4752-a5b1-be99889ea79a}\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [512, 512]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"gf\", \"nm\": \"Gradient Fill\", \"o\": {\"a\": 0, \"k\": 100}, \"r\": 1, \"s\": {\"a\": 0, \"k\": [256, 496]}, \"e\": {\"a\": 0, \"k\": [256, 16]}, \"t\": 1, \"h\": {\"a\": 0, \"k\": 0}, \"a\": {\"a\": 0, \"k\": 0}, \"g\": {\"p\": 3, \"k\": {\"a\": 0, \"k\": [0, 0.7686274509803922, 0.8509803921568627, 0.9607843137254902, 0.5, 0.19600213626306554, 0.31400015259021896, 0.6899977111467155, 1, 0.16099794003204396, 0.18399328603036547, 0.45900663767452504, 0, 1, 0.5, 1, 1, 1]}}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [257.4805970149254, 255.76119402985074]}, \"p\": {\"a\": 0, \"k\": [257.4805970149254, 255.76119402985074]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { var gradient = lottie.layers[1].shapes[0].it[1]; var start_marker = lottie.layers[0].shapes[1].it[1]; var end_marker = lottie.layers[0].shapes[0].it[1]; gradient.s.k = start_marker.p.k = [data[\"Start X\"], data[\"Start Y\"]]; gradient.e.k = end_marker.p.k = [data[\"End X\"], data[\"End Y\"]]; gradient.t = Number(data[\"Type\"]); gradient.h.k = data[\"Highlight\"]; gradient.a.k = data[\"Highlight Angle\"];this.json_viewer_contents = lottie.layers[1].shapes[0].it[1]; }, {} );","title":"Gradient Example"},{"location":"shapes/#no-style","text":"Represents a style for shapes without fill or stroke. Attribute Type Description ty string = 'no' Shape Type","title":"No Style"},{"location":"shapes/#group","text":"A group is a shape that can contain other shapes (including other groups). The usual contents of a group are: Shapes Style Transform For example, if you want to have a red rectangle with a black outline, its group will contain A Rectangle defining the actual shape of the rectangle A Fill for the color red A Stroke for the black outline A Transform for the group transform While the contents may vary, a group must always end with a Transform shape . The attributes of a Group are: Attribute Type Description View Schema np number Number of properties it Array of shapes Shapes","title":"Group"},{"location":"shapes/#transform-shape","text":"Basically the same as Transform but with the ty attribute.","title":"Transform Shape"},{"location":"shapes/#modifiers","text":"Modifiers process their siblings and alter the path defined by shapes .","title":"Modifiers"},{"location":"shapes/#repeater","text":"This is a bit different compared from other modifiers, since it will take into account style as well. The effect of a Repeater is to duplicate the other shapes a number of times applying a transform for each copy. Also has the attributes from Modifier . Attribute Type Description ty string = 'rp' Shape Type c Animated number Number of copies o Animated number Offset m Composite Stacking order tr Repeater Transform Transform applied to each copy The transform is multiplied by o + 1 (where o is the Offset property above). So if o is 0 , the first instance shown by the Repeater is at its starting location. If it's 1 , the first instance has the matrix applied to it. Other values multiply the initial transform accordingly.","title":"Repeater"},{"location":"shapes/#repeater-transform","text":"Same as a regular Transform but instead of a single opacity value ( o ), it has two: Attribute Type Description so Animated number Start Opacity eo Animated number End Opacity The first copy will use so , the last eo , and copies between them will have an interpolated value. Copies 4 Start Opacity 100 End Opacity 50 Position x 130 Position y 0 Rotation 137 Offset 0 Composite Above Below Show JSON var lottie_player_56 = new PlaygroundPlayer( 56, 'playground_56_9', 'lottie_target_56', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{33a02914-c5a9-4c4e-a0bd-0ec07f05b204}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{9eb62fdc-6d5b-4771-94c0-ebdafbd7a54e}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{bfbf6254-ff78-4d00-9d09-eafe4e34b732}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{5a453691-6b60-4bd3-bc43-e28b7a0ebc48}\", \"p\": {\"a\": 0, \"k\": [80, 120]}, \"or\": {\"a\": 0, \"k\": 80}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{b0ba4cf0-3a1b-45a3-8912-d0ed2bdd2082}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{0c2313ae-ccff-4e71-9e00-81649390d850}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"r\": 1}, {\"ty\": \"rp\", \"nm\": \"Repeater\", \"mn\": \"{a9e13270-7dd8-4520-b5a1-c1c9cf96286b}\", \"c\": {\"a\": 0, \"k\": 4}, \"o\": {\"a\": 0, \"k\": 0}, \"m\": 1, \"tr\": {\"a\": {\"a\": 0, \"k\": [80, 120]}, \"p\": {\"a\": 0, \"k\": [130, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 137.508}, \"so\": {\"a\": 0, \"k\": 100}, \"eo\": {\"a\": 0, \"k\": 50}}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [65.33731343283583, 117.77910447761194]}, \"p\": {\"a\": 0, \"k\": [73.93432835820896, 93.70746268656717]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { lottie.layers[0].shapes[0].it[3].c.k = data[\"Copies\"]; lottie.layers[0].shapes[0].it[3].tr.so.k = data[\"Start Opacity\"]; lottie.layers[0].shapes[0].it[3].tr.eo.k = data[\"End Opacity\"]; lottie.layers[0].shapes[0].it[3].tr.p.k[0] = data[\"Position x\"]; lottie.layers[0].shapes[0].it[3].tr.p.k[1] = data[\"Position y\"]; lottie.layers[0].shapes[0].it[3].tr.r.k = data[\"Rotation\"]; lottie.layers[0].shapes[0].it[3].o.k = data[\"Offset\"]; lottie.layers[0].shapes[0].it[3].m = Number(data[\"Composite\"]);this.json_viewer_contents = lottie.layers[0].shapes[0].it[3]; }, {} );","title":"Repeater Transform"},{"location":"shapes/#trim-path","text":"This is mostly useful for shapes with a stroke and not a fill. It takes the path defined by shapes and only shows a segment of the resulting bezier data. Also has the attributes from Modifier . Attribute Type Description ty string = 'tm' Shape Type s Animated number Segment start e Animated number Segment end o Animated number Offset m Trim Multiple Shapes How to treat multiple copies s and e go from 0 to 100 , 0 being at the beginning of the path and 100 at the end. The displayed segment is what lays between the two. o is an offset from the start, to allow values to wrap around. Its value goes from 0 (start of the path) to 360 (end of the path). It looks like an angle but it isn't really, the difference between o and s is that with o you can go over 360 or below 0 to shift the whole segment along the path. Here is an interactive example: Start 0 End 50 Offset 0 Multiple Shapes Simultaneously Individually Show JSON var lottie_player_57 = new PlaygroundPlayer( 57, 'playground_57_5', 'lottie_target_57', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [128, 128]}, \"or\": {\"a\": 0, \"k\": 100}, \"ir\": {\"a\": 0, \"k\": 50}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{74587b40-1ef1-445d-b9ab-02b8a42a96aa}\", \"p\": {\"a\": 0, \"k\": [384, 128]}, \"s\": {\"a\": 0, \"k\": [200, 200]}}, {\"ty\": \"rc\", \"nm\": \"Rect\", \"mn\": \"{0776f2df-2619-415c-b10d-f648f2edfa0f}\", \"d\": 1, \"p\": {\"a\": 0, \"k\": [128, 384]}, \"s\": {\"a\": 0, \"k\": [200, 200]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"sr\", \"nm\": \"Triangle\", \"mn\": \"{db373594-d0ae-44ff-9295-30ff72616af2}\", \"p\": {\"a\": 0, \"k\": [384, 384]}, \"or\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 3}, \"sy\": 2, \"os\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"tm\", \"nm\": \"Trim Path\", \"mn\": \"{dcd7570f-5105-485b-bd43-42ad990b01e8}\", \"s\": {\"a\": 0, \"k\": 0}, \"e\": {\"a\": 0, \"k\": 50}, \"o\": {\"a\": 0, \"k\": 0}, \"m\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 20}}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { lottie.layers[0].shapes[4].s.k = data[\"Start\"]; lottie.layers[0].shapes[4].e.k = data[\"End\"]; lottie.layers[0].shapes[4].o.k = data[\"Offset\"]; lottie.layers[0].shapes[4].m = Number(data[\"Multiple Shapes\"]);this.json_viewer_contents = lottie.layers[0].shapes[4]; }, {} );","title":"Trim Path"},{"location":"shapes/#rounded-corners","text":"Self explanatory Also has the attributes from Modifier . Attribute Type Description ty string = 'rd' Shape Type r Animated number Radius Radius 50 Show JSON var lottie_player_58 = new PlaygroundPlayer( 58, 'playground_58_2', 'lottie_target_58', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{9199543e-3552-4e51-a802-623f2a4a2ca1}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 222.72242736816406}, \"ir\": {\"a\": 0, \"k\": 111.36121368408203}, \"r\": {\"a\": 0, \"k\": 358.67291259765625}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"rd\", \"nm\": \"Rounded Corners\", \"mn\": \"{dcd7570f-5105-485b-bd43-42ad990b01e8}\", \"r\": {\"a\": 0, \"k\": 50}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"fl\", \"hd\": true, \"nm\": \"Fill\", \"mn\": \"{a1bcc159-6916-4718-841d-a99140c0e74b}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { lottie.layers[0].shapes[0].it[1].r.k = data[\"Radius\"];this.json_viewer_contents = lottie.layers[0].shapes[0].it[1]; }, {} );","title":"Rounded Corners"},{"location":"shapes/#pucker-bloat","text":"Interpolates bezier vertices towards the center of the shape, and tangent handles away from it (or vice-versa). Attribute Type Description ty string = 'pb' Shape Type a Animated number Amount as a percentage When a is 0 , nothing changes. When a is positive, the vertices are pulled towards the center, with 100 being at the center. And the tangents are pushed away. When a is negative the vertices are pushed away from the center with 100 being twice far away from the center. And the tangents are pulled towards the center. Amount 50 Show JSON var lottie_player_59 = new PlaygroundPlayer( 59, 'playground_59_2', 'lottie_target_59', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{9199543e-3552-4e51-a802-623f2a4a2ca1}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 160}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 2, \"os\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"pb\", \"nm\": \"Inflate and Deflate\", \"mn\": \"{b4af429a-546e-4728-a869-711a404c55ae}\", \"a\": {\"a\": 0, \"k\": 50}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"fl\", \"hd\": true, \"nm\": \"Fill\", \"mn\": \"{a1bcc159-6916-4718-841d-a99140c0e74b}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { lottie.layers[0].shapes[0].it[1].a.k = data[\"Amount\"];this.json_viewer_contents = lottie.layers[0].shapes[0].it[1]; }, {} );","title":"Pucker / Bloat"},{"location":"shapes/#twist","text":"Attribute Type Description ty string = 'tw' Shape Type a Animated number Angle c Animated Vector Center","title":"Twist"},{"location":"shapes/#merge","text":"Boolean operator on shapes Attribute Type Description ty string = 'mm' Shape Type mm Merge Mode Merge Mode","title":"Merge"},{"location":"shapes/#offset-path","text":"Interpolates the shape with its center point and bezier tangents with the opposite direction Attribute Type Description ty string = 'op' Shape Type a Animated number Amount lj Line Join Line Join ml Animated number Miter Limit","title":"Offset Path"},{"location":"shapes/#zig-zag","text":"Changes the edges of affected shapes into a series of peaks and valleys of uniform size Attribute Type Description ty string = 'zz' Shape Type r Animated number Number of ridges per segment s Animated number Distance between peaks and troughs pt Animated number Point type (1 = corner, 2 = smooth)","title":"Zig Zag"},{"location":"text/","text":"Text Font List Fonts are defined in the animation object, under fonts . When fonts is present in the Animation object, it has a single attribute called list , which is an array of font objects: Attribute Type Description ascent number Text will be moved down based on this value fFamily string Font Family fName string Name used by text documents to reference this font, usually it's fFamily followed by fStyle fStyle string Font Style fPath string Path fWeight string Weight origin Font Path Origin Origin fClass string CSS Class applied to text objects using this font To understand how to load fonts it's better to look at some examples so here follow various ways of adding a font into lottie. The tables show the JSON, its resulting output, then an equivalent font definition using CSS. @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@700&display=swap'); @font-face { font-family: 'Ubuntu'; font-style: italic; font-weight: 300; font-display: swap; src: url(https://fonts.gstatic.com/s/ubuntu/v15/4iCp6KVjbNBYlgoKejZftWyI.ttf) format('truetype'); } Using a system font Here we use origin 0 (and we can omit it). fFamily needs to be an available font family. JSON Lottie Output { \"fFamily\": \"monospace\", \"fName\": \"MyFont\", \"fStyle\": \"Regular\" } var lottie_player_66 = new LottiePlayer( 'lottie_target_66', '../examples/font-local.json', true, {} ); CSS Output { font-family: monospace; } Hello Font from CSS URL Here we use origin 1. JSON Lottie Output { \"fPath\": \"https://fonts.googleapis.com/css2?family=Montserrat:wght@800&display=swap\", \"fFamily\": \"Poppins\", \"fStyle\": \"Bold\", \"fName\": \"Poppins Bold\", \"origin\": 1 } var lottie_player_65 = new LottiePlayer( 'lottie_target_65', '../examples/font-css.json', true, {} ); CSS Output @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@700&display=swap'); or <link href=\"https://fonts.googleapis.com/css2?family=Poppins:wght@700&amp;display=swap\" rel=\"stylesheet\"> Hello Font from URL Here we use origin 3. JSON Lottie Output { \"fPath\": \"https://fonts.gstatic.com/s/ubuntu/v15/4iCp6KVjbNBYlgoKejZftWyI.ttf\", \"fFamily\": \"Ubuntu\", \"fStyle\": \"Light Italic\", \"fName\": \"Ubuntu Light Italic\", \"origin\": 3 } var lottie_player_64 = new LottiePlayer( 'lottie_target_64', '../examples/font-url.json', true, {} ); CSS Output @font-face { font-family: 'Ubuntu'; font-style: italic; font-weight: 300; font-display: swap; src: url(https://fonts.gstatic.com/s/ubuntu/v15/4iCp6KVjbNBYlgoKejZftWyI.ttf) format('truetype'); } Hello Character Data You can also have font data directly into the lottie, this is done by having an array of character data objects in the chars attribute of the animation . Attribute Type Description data Character Shape or Character Precomp Defines how the character is defined ch string Character fFamily string Font Family size number Font Size style string Font Style w number Width Character Shapes Defines a character as shapes Attribute Type Description shapes Shape List Shapes forming the character Character Precomp Defines a character as a precomp layer Attribute Type Description refId string ID of the precomp as specified in the assets ks Transform Layer transform ip number Frame when the layer becomes visible op number Frame when the layer becomes invisible sr number Time Stretch st number Start Time Text Layer The text layer has an attribute called t containing a Text Animator Data object. Text Data Contains all the text data and animation Attribute Type Description a array of Text Range Ranges d Animated Text Document Document m Text Alignment Options Alignment p Text Follow Path Follow Path Animated Text Document This object is similar to an animated property for text. The main difference is that it's always treated as animated (ie: you must use keyframes). Attribute Type Description k array of Text Document Keyframe Array of keyframes x string Expression sid string One of the ID in the file's slots Text Document Keyframe This is similar to the keyframe object used by animated properties, but it doesn't have any attribute specifying interpolation as text is always animated in discrete steps. Attribute Type Description s Text Document Start t number Time Text Document This is where the actual text data is stored. Attribute Type Description f string Font Family fc Color Fill Color sc Color Stroke Color sw number Stroke Width of boolean Render stroke above the fill s number Font Size lh number Distance between lines on multiline or wrapped text sz array of number Size of the box containing the text ps array of number Position of the box containing the text t string Text, note that newlines are encoded with \\r j Text Justify Justify ca Text Caps Text Caps tr number Text Tracking ls number Baseline Shift Text Color Red 0 Color Green 0 Color Blue 0 Stroke Width 0 Stroke Red 0 Stroke Green 0 Stroke Blue 0 Position X 5 Position Y 80 Font Size 100 Justify Left Right Center Justify with Last Line Left Justify with Last Line Right Justify with Last Line Center Justify with Last Line Full Show JSON var lottie_player_60 = new PlaygroundPlayer( 60, 'playground_60_13', 'lottie_target_60', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 120, \"w\": 300, \"h\": 100, \"ddd\": 0, \"assets\": [], \"fonts\": {\"list\": [{\"fPath\": \"https://fonts.gstatic.com/s/ubuntu/v15/4iCp6KVjbNBYlgoKejZftWyI.ttf\", \"fFamily\": \"Ubuntu\", \"fStyle\": \"Light Italic\", \"fName\": \"Ubuntu Light Italic\", \"origin\": 3}]}, \"layers\": [{\"nm\": \"Text Layer\", \"ty\": 5, \"sr\": 1, \"ks\": {\"p\": {\"k\": [5, 80], \"a\": 0}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"t\": {\"a\": [], \"d\": {\"k\": [{\"s\": {\"f\": \"Ubuntu Light Italic\", \"fc\": [0, 0, 0], \"s\": 100, \"t\": \"Hello\", \"j\": 0}, \"t\": 0}]}, \"m\": {\"a\": {\"k\": [0, 0], \"a\": 0}}, \"p\": {}}}]}, function (lottie, data) { lottie.layers[0].t.d.k[0].s.t = data[\"Text\"]; lottie.layers[0].t.d.k[0].s.fc[0] = data[\"Color Red\"]; lottie.layers[0].t.d.k[0].s.fc[1] = data[\"Color Green\"]; lottie.layers[0].t.d.k[0].s.fc[2] = data[\"Color Blue\"]; lottie.layers[0].t.d.k[0].s.sc = [ data[\"Stroke Red\"], data[\"Stroke Green\"], data[\"Stroke Blue\"] ]; lottie.layers[0].t.d.k[0].s.sw = data[\"Stroke Width\"]; lottie.layers[0].ks.p.k[0] = data[\"Position X\"]; lottie.layers[0].ks.p.k[1] = data[\"Position Y\"]; lottie.layers[0].t.d.k[0].s.s = data[\"Font Size\"]; lottie.layers[0].t.d.k[0].s.j = Number(data[\"Justify\"]);this.json_viewer_contents = lottie.layers[0]; }, {} ); Text Alignment Options Used to change the origin point for transformations, such as Rotation, that may be applied to the text string. The origin point for each character, word, or line can be changed. Attribute Type Description a Animated Vector Group alignment g Text Grouping Anchor point grouping Text Follow Path Uses the path described by a layer mask to put the text on said path. Attribute Type Description m integer Index of the mask to use f Animated number First Margin l Animated number Last Margin r Animated number Reverse Path a Animated number Force Alignment p Animated number Perpendicular To Path Text Range Range of text with custom animations and style Attribute Type Description nm string Name s Text Range Selector Selector a Text Style Style Text Hello World the quick brown fox jumps over the lazy dog Selector Start 60 End 75 Offset 0 Min Ease 0 Max Ease 0 Randomize Range Units Percent Index Based On Characters Character Excluding Spaces Words Lines Shape Square Ramp Up Ramp Down Triangle Round Smooth Transform Position X 0 Position Y 0 Rotation 0 Opacity 100 Style Fill Fill Hue 0 Fill Saturation 0 Fill Brightness 0 Stroke Stroke Width 0 Letter Spacing 0 Show JSON var lottie_player_61 = new PlaygroundPlayer( 61, 'playground_61_22', 'lottie_target_61', {\"v\": \"5.9.6\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 350, \"assets\": [], \"fonts\": {\"list\": [{\"origin\": 0, \"fPath\": \"\", \"fClass\": \"\", \"fFamily\": \"Sans\", \"fWeight\": \"\", \"fStyle\": \"Regular\", \"fName\": \"Sans\"}]}, \"layers\": [{\"ty\": 5, \"sr\": 1, \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": {\"p\": {\"a\": 0, \"k\": [256, 70, 0]}}, \"t\": {\"d\": {\"k\": [{\"s\": {\"s\": 70, \"f\": \"Sans\", \"t\": \"Hello World\\rthe quick brown\\rfox jumps over\\rthe lazy dog\", \"ls\": 0, \"j\": 2, \"fc\": [0, 0, 0], \"sc\": [0, 0, 0], \"sw\": 0, \"of\": true}, \"t\": 0}]}, \"p\": {}, \"m\": {\"g\": 1, \"a\": {\"a\": 0, \"k\": [0, 0], \"ix\": 2}}, \"a\": [{\"nm\": \"Text Range\", \"s\": {\"t\": 0, \"o\": {\"a\": 0, \"k\": 0}, \"s\": {\"a\": 0, \"k\": 60}, \"e\": {\"a\": 0, \"k\": 75}, \"a\": {\"a\": 0, \"k\": 100}, \"b\": 1, \"rn\": 0, \"sh\": 1, \"xe\": {\"a\": 0, \"k\": 0}, \"ne\": {\"a\": 0, \"k\": 0}, \"sm\": {\"a\": 0, \"k\": 100}, \"r\": 1}, \"a\": {\"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}, \"fc\": {\"a\": 0, \"k\": [0.196, 0.314, 0.69]}, \"fh\": {\"a\": 0, \"k\": 0}, \"fs\": {\"a\": 0, \"k\": 0}, \"fb\": {\"a\": 0, \"k\": 0}, \"sc\": {\"a\": 0, \"k\": [1, 0, 0]}, \"sw\": {\"a\": 0, \"k\": 0}, \"t\": {\"a\": 0, \"k\": 0}}}]}}, {\"ty\": 1, \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": {}, \"sc\": \"#ffffff\", \"sw\": 512, \"sh\": 350}]}, function (lottie, data) { var range = lottie.layers[0].t.a[0]; lottie.fonts.list[0].fFamily = \"monospace\"; lottie.layers[0].t.d.k[0].s.t = data[\"Text\"].replace(/\\n\\r?/g, \"\\r\") range.s.s.k = data[\"Start\"]; range.s.e.k = data[\"End\"]; range.s.o.k = data[\"Offset\"]; range.s.ne.k = data[\"Min Ease\"]; range.s.xe.k = data[\"Max Ease\"]; range.s.rn = Number(data[\"Randomize\"]); range.s.b = Number(data[\"Based On\"]); range.s.sh = Number(data[\"Shape\"]); range.s.r = Number(data[\"Range Units\"]); range.a.p.k = [data[\"Position X\"], data[\"Position Y\"]]; range.a.o.k = data[\"Opacity\"]; range.a.r.k = data[\"Rotation\"]; range.a.fc.k = data[\"Fill\"]; range.a.sc.k = data[\"Stroke\"]; range.a.sw.k = data[\"Stroke Width\"]; range.a.t.k = data[\"Letter Spacing\"]; range.a.fh.k = data[\"Fill Hue\"]; range.a.fs.k = data[\"Fill Saturation\"]; range.a.fb.k = data[\"Fill Brightness\"];this.json_viewer_contents = lottie.layers[0].t.a[0]; }, {} ); Text Range Selector Defines the range of characters to apply a property value only to a specific subset of the text document. r Defines whether the values are defined as a percentage or indices. The range is defined by s , e , and o . ne and xe define what happes to text that is only partly inside the selected range. b changes whether selection is done on per character basis, per word, etc. It also changes the meaning of an index when r is set to Indices. Attribute Type Description t 0-1 integer Expressible xe Animated number Max Ease ne Animated number Min Ease a Animated number Max Amount b Text Based Based On rn 0-1 integer Randomize sh Text Shape Shape o Animated number Offset r Text Range Units Range Units sm Animated number Selector Smoothness s Animated number Start e Animated number End Start 60 End 75 Offset 0 Min Ease 0 Max Ease 0 Randomize Range Units Percent Index Based On Characters Character Excluding Spaces Words Lines Shape Square Ramp Up Ramp Down Triangle Round Smooth Show JSON var lottie_player_62 = new PlaygroundPlayer( 62, 'playground_62_10', 'lottie_target_62', {\"v\": \"5.9.6\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 350, \"assets\": [], \"fonts\": {\"list\": [{\"origin\": 0, \"fPath\": \"\", \"fClass\": \"\", \"fFamily\": \"Sans\", \"fWeight\": \"\", \"fStyle\": \"Regular\", \"fName\": \"Sans\"}]}, \"layers\": [{\"ty\": 5, \"sr\": 1, \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": {\"p\": {\"a\": 0, \"k\": [256, 70, 0]}}, \"t\": {\"d\": {\"k\": [{\"s\": {\"s\": 70, \"f\": \"Sans\", \"t\": \"Hello World\\rthe quick brown\\rfox jumps over\\rthe lazy dog\", \"ls\": 0, \"j\": 2, \"fc\": [0, 0, 0], \"sc\": [0, 0, 0], \"sw\": 0, \"of\": true}, \"t\": 0}]}, \"p\": {}, \"m\": {\"g\": 1, \"a\": {\"a\": 0, \"k\": [0, 0], \"ix\": 2}}, \"a\": [{\"nm\": \"Text Range\", \"s\": {\"t\": 0, \"o\": {\"a\": 0, \"k\": 0}, \"s\": {\"a\": 0, \"k\": 60}, \"e\": {\"a\": 0, \"k\": 75}, \"a\": {\"a\": 0, \"k\": 100}, \"b\": 1, \"rn\": 0, \"sh\": 1, \"xe\": {\"a\": 0, \"k\": 0}, \"ne\": {\"a\": 0, \"k\": 0}, \"sm\": {\"a\": 0, \"k\": 100}, \"r\": 1}, \"a\": {\"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}, \"fc\": {\"a\": 0, \"k\": [0.196, 0.314, 0.69]}, \"fh\": {\"a\": 0, \"k\": 0}, \"fs\": {\"a\": 0, \"k\": 0}, \"fb\": {\"a\": 0, \"k\": 0}, \"sc\": {\"a\": 0, \"k\": [1, 0, 0]}, \"sw\": {\"a\": 0, \"k\": 0}, \"t\": {\"a\": 0, \"k\": 0}}}]}}, {\"ty\": 1, \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": {}, \"sc\": \"#ffffff\", \"sw\": 512, \"sh\": 350}]}, function (lottie, data) { var selector = lottie.layers[0].t.a[0].s; selector.s.k = data[\"Start\"]; selector.e.k = data[\"End\"]; selector.o.k = data[\"Offset\"]; selector.ne.k = data[\"Min Ease\"]; selector.xe.k = data[\"Max Ease\"]; selector.rn = Number(data[\"Randomize\"]); selector.b = Number(data[\"Based On\"]); selector.sh = Number(data[\"Shape\"]); selector.r = Number(data[\"Range Units\"]);this.json_viewer_contents = lottie.layers[0].t.a[0].s; }, {} ); Text Style Has the properties of a transform and the style options of a text document. It applies such transform and style to the part of the text defined by the text selector property Also has the attributes from Transform . Attribute Type Description sw Animated number Stroke Width sc Animated Color Stroke Color sh Animated number Stroke Hue ss Animated number Stroke Saturation sb Animated number Stroke Brightness so Animated number Stroke Opacity fc Animated Color Fill Color fh Animated number Fill Hue fs Animated number Fill Saturation fb Animated number Fill Brightness fo Animated number Fill Opacity t Animated number Letter Spacing bl Animated number Blur ls Animated number Line Spacing Transform Position X 0 Position Y 0 Rotation 0 Opacity 100 Style Fill Fill Hue 0 Fill Saturation 0 Fill Brightness 0 Stroke Stroke Width 0 Letter Spacing 0 Show JSON var lottie_player_63 = new PlaygroundPlayer( 63, 'playground_63_12', 'lottie_target_63', {\"v\": \"5.9.6\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 350, \"assets\": [], \"fonts\": {\"list\": [{\"origin\": 0, \"fPath\": \"\", \"fClass\": \"\", \"fFamily\": \"Sans\", \"fWeight\": \"\", \"fStyle\": \"Regular\", \"fName\": \"Sans\"}]}, \"layers\": [{\"ty\": 5, \"sr\": 1, \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": {\"p\": {\"a\": 0, \"k\": [256, 70, 0]}}, \"t\": {\"d\": {\"k\": [{\"s\": {\"s\": 70, \"f\": \"Sans\", \"t\": \"Hello World\\rthe quick brown\\rfox jumps over\\rthe lazy dog\", \"ls\": 0, \"j\": 2, \"fc\": [0, 0, 0], \"sc\": [0, 0, 0], \"sw\": 0, \"of\": true}, \"t\": 0}]}, \"p\": {}, \"m\": {\"g\": 1, \"a\": {\"a\": 0, \"k\": [0, 0], \"ix\": 2}}, \"a\": [{\"nm\": \"Text Range\", \"s\": {\"t\": 0, \"o\": {\"a\": 0, \"k\": 0}, \"s\": {\"a\": 0, \"k\": 60}, \"e\": {\"a\": 0, \"k\": 75}, \"a\": {\"a\": 0, \"k\": 100}, \"b\": 1, \"rn\": 0, \"sh\": 1, \"xe\": {\"a\": 0, \"k\": 0}, \"ne\": {\"a\": 0, \"k\": 0}, \"sm\": {\"a\": 0, \"k\": 100}, \"r\": 1}, \"a\": {\"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}, \"fc\": {\"a\": 0, \"k\": [0.196, 0.314, 0.69]}, \"fh\": {\"a\": 0, \"k\": 0}, \"fs\": {\"a\": 0, \"k\": 0}, \"fb\": {\"a\": 0, \"k\": 0}, \"sc\": {\"a\": 0, \"k\": [1, 0, 0]}, \"sw\": {\"a\": 0, \"k\": 0}, \"t\": {\"a\": 0, \"k\": 0}}}]}}, {\"ty\": 1, \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": {}, \"sc\": \"#ffffff\", \"sw\": 512, \"sh\": 350}]}, function (lottie, data) { var range = lottie.layers[0].t.a[0]; range.a.p.k = [data[\"Position X\"], data[\"Position Y\"]]; range.a.o.k = data[\"Opacity\"]; range.a.r.k = data[\"Rotation\"]; range.a.fc.k = data[\"Fill\"]; range.a.sc.k = data[\"Stroke\"]; range.a.sw.k = data[\"Stroke Width\"]; range.a.t.k = data[\"Letter Spacing\"]; range.a.fh.k = data[\"Fill Hue\"]; range.a.fs.k = data[\"Fill Saturation\"]; range.a.fb.k = data[\"Fill Brightness\"];this.json_viewer_contents = lottie.layers[0].t.a[0].a; }, {} );","title":"Text"},{"location":"text/#text","text":"","title":"Text"},{"location":"text/#font-list","text":"Fonts are defined in the animation object, under fonts . When fonts is present in the Animation object, it has a single attribute called list , which is an array of font objects: Attribute Type Description ascent number Text will be moved down based on this value fFamily string Font Family fName string Name used by text documents to reference this font, usually it's fFamily followed by fStyle fStyle string Font Style fPath string Path fWeight string Weight origin Font Path Origin Origin fClass string CSS Class applied to text objects using this font To understand how to load fonts it's better to look at some examples so here follow various ways of adding a font into lottie. The tables show the JSON, its resulting output, then an equivalent font definition using CSS. @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@700&display=swap'); @font-face { font-family: 'Ubuntu'; font-style: italic; font-weight: 300; font-display: swap; src: url(https://fonts.gstatic.com/s/ubuntu/v15/4iCp6KVjbNBYlgoKejZftWyI.ttf) format('truetype'); }","title":"Font List"},{"location":"text/#using-a-system-font","text":"Here we use origin 0 (and we can omit it). fFamily needs to be an available font family. JSON Lottie Output { \"fFamily\": \"monospace\", \"fName\": \"MyFont\", \"fStyle\": \"Regular\" } var lottie_player_66 = new LottiePlayer( 'lottie_target_66', '../examples/font-local.json', true, {} ); CSS Output { font-family: monospace; } Hello","title":"Using a system font"},{"location":"text/#font-from-css-url","text":"Here we use origin 1. JSON Lottie Output { \"fPath\": \"https://fonts.googleapis.com/css2?family=Montserrat:wght@800&display=swap\", \"fFamily\": \"Poppins\", \"fStyle\": \"Bold\", \"fName\": \"Poppins Bold\", \"origin\": 1 } var lottie_player_65 = new LottiePlayer( 'lottie_target_65', '../examples/font-css.json', true, {} ); CSS Output @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@700&display=swap'); or <link href=\"https://fonts.googleapis.com/css2?family=Poppins:wght@700&amp;display=swap\" rel=\"stylesheet\"> Hello","title":"Font from CSS URL"},{"location":"text/#font-from-url","text":"Here we use origin 3. JSON Lottie Output { \"fPath\": \"https://fonts.gstatic.com/s/ubuntu/v15/4iCp6KVjbNBYlgoKejZftWyI.ttf\", \"fFamily\": \"Ubuntu\", \"fStyle\": \"Light Italic\", \"fName\": \"Ubuntu Light Italic\", \"origin\": 3 } var lottie_player_64 = new LottiePlayer( 'lottie_target_64', '../examples/font-url.json', true, {} ); CSS Output @font-face { font-family: 'Ubuntu'; font-style: italic; font-weight: 300; font-display: swap; src: url(https://fonts.gstatic.com/s/ubuntu/v15/4iCp6KVjbNBYlgoKejZftWyI.ttf) format('truetype'); } Hello","title":"Font from URL"},{"location":"text/#character-data","text":"You can also have font data directly into the lottie, this is done by having an array of character data objects in the chars attribute of the animation . Attribute Type Description data Character Shape or Character Precomp Defines how the character is defined ch string Character fFamily string Font Family size number Font Size style string Font Style w number Width","title":"Character Data"},{"location":"text/#character-shapes","text":"Defines a character as shapes Attribute Type Description shapes Shape List Shapes forming the character","title":"Character Shapes"},{"location":"text/#character-precomp","text":"Defines a character as a precomp layer Attribute Type Description refId string ID of the precomp as specified in the assets ks Transform Layer transform ip number Frame when the layer becomes visible op number Frame when the layer becomes invisible sr number Time Stretch st number Start Time","title":"Character Precomp"},{"location":"text/#text-layer","text":"The text layer has an attribute called t containing a Text Animator Data object.","title":"Text Layer"},{"location":"text/#text-data","text":"Contains all the text data and animation Attribute Type Description a array of Text Range Ranges d Animated Text Document Document m Text Alignment Options Alignment p Text Follow Path Follow Path","title":"Text Data"},{"location":"text/#animated-text-document","text":"This object is similar to an animated property for text. The main difference is that it's always treated as animated (ie: you must use keyframes). Attribute Type Description k array of Text Document Keyframe Array of keyframes x string Expression sid string One of the ID in the file's slots","title":"Animated Text Document"},{"location":"text/#text-document-keyframe","text":"This is similar to the keyframe object used by animated properties, but it doesn't have any attribute specifying interpolation as text is always animated in discrete steps. Attribute Type Description s Text Document Start t number Time","title":"Text Document Keyframe"},{"location":"text/#text-document","text":"This is where the actual text data is stored. Attribute Type Description f string Font Family fc Color Fill Color sc Color Stroke Color sw number Stroke Width of boolean Render stroke above the fill s number Font Size lh number Distance between lines on multiline or wrapped text sz array of number Size of the box containing the text ps array of number Position of the box containing the text t string Text, note that newlines are encoded with \\r j Text Justify Justify ca Text Caps Text Caps tr number Text Tracking ls number Baseline Shift Text Color Red 0 Color Green 0 Color Blue 0 Stroke Width 0 Stroke Red 0 Stroke Green 0 Stroke Blue 0 Position X 5 Position Y 80 Font Size 100 Justify Left Right Center Justify with Last Line Left Justify with Last Line Right Justify with Last Line Center Justify with Last Line Full Show JSON var lottie_player_60 = new PlaygroundPlayer( 60, 'playground_60_13', 'lottie_target_60', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 120, \"w\": 300, \"h\": 100, \"ddd\": 0, \"assets\": [], \"fonts\": {\"list\": [{\"fPath\": \"https://fonts.gstatic.com/s/ubuntu/v15/4iCp6KVjbNBYlgoKejZftWyI.ttf\", \"fFamily\": \"Ubuntu\", \"fStyle\": \"Light Italic\", \"fName\": \"Ubuntu Light Italic\", \"origin\": 3}]}, \"layers\": [{\"nm\": \"Text Layer\", \"ty\": 5, \"sr\": 1, \"ks\": {\"p\": {\"k\": [5, 80], \"a\": 0}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"t\": {\"a\": [], \"d\": {\"k\": [{\"s\": {\"f\": \"Ubuntu Light Italic\", \"fc\": [0, 0, 0], \"s\": 100, \"t\": \"Hello\", \"j\": 0}, \"t\": 0}]}, \"m\": {\"a\": {\"k\": [0, 0], \"a\": 0}}, \"p\": {}}}]}, function (lottie, data) { lottie.layers[0].t.d.k[0].s.t = data[\"Text\"]; lottie.layers[0].t.d.k[0].s.fc[0] = data[\"Color Red\"]; lottie.layers[0].t.d.k[0].s.fc[1] = data[\"Color Green\"]; lottie.layers[0].t.d.k[0].s.fc[2] = data[\"Color Blue\"]; lottie.layers[0].t.d.k[0].s.sc = [ data[\"Stroke Red\"], data[\"Stroke Green\"], data[\"Stroke Blue\"] ]; lottie.layers[0].t.d.k[0].s.sw = data[\"Stroke Width\"]; lottie.layers[0].ks.p.k[0] = data[\"Position X\"]; lottie.layers[0].ks.p.k[1] = data[\"Position Y\"]; lottie.layers[0].t.d.k[0].s.s = data[\"Font Size\"]; lottie.layers[0].t.d.k[0].s.j = Number(data[\"Justify\"]);this.json_viewer_contents = lottie.layers[0]; }, {} );","title":"Text Document"},{"location":"text/#text-alignment-options","text":"Used to change the origin point for transformations, such as Rotation, that may be applied to the text string. The origin point for each character, word, or line can be changed. Attribute Type Description a Animated Vector Group alignment g Text Grouping Anchor point grouping","title":"Text Alignment Options"},{"location":"text/#text-follow-path","text":"Uses the path described by a layer mask to put the text on said path. Attribute Type Description m integer Index of the mask to use f Animated number First Margin l Animated number Last Margin r Animated number Reverse Path a Animated number Force Alignment p Animated number Perpendicular To Path","title":"Text Follow Path"},{"location":"text/#text-range","text":"Range of text with custom animations and style Attribute Type Description nm string Name s Text Range Selector Selector a Text Style Style Text Hello World the quick brown fox jumps over the lazy dog Selector Start 60 End 75 Offset 0 Min Ease 0 Max Ease 0 Randomize Range Units Percent Index Based On Characters Character Excluding Spaces Words Lines Shape Square Ramp Up Ramp Down Triangle Round Smooth Transform Position X 0 Position Y 0 Rotation 0 Opacity 100 Style Fill Fill Hue 0 Fill Saturation 0 Fill Brightness 0 Stroke Stroke Width 0 Letter Spacing 0 Show JSON var lottie_player_61 = new PlaygroundPlayer( 61, 'playground_61_22', 'lottie_target_61', {\"v\": \"5.9.6\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 350, \"assets\": [], \"fonts\": {\"list\": [{\"origin\": 0, \"fPath\": \"\", \"fClass\": \"\", \"fFamily\": \"Sans\", \"fWeight\": \"\", \"fStyle\": \"Regular\", \"fName\": \"Sans\"}]}, \"layers\": [{\"ty\": 5, \"sr\": 1, \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": {\"p\": {\"a\": 0, \"k\": [256, 70, 0]}}, \"t\": {\"d\": {\"k\": [{\"s\": {\"s\": 70, \"f\": \"Sans\", \"t\": \"Hello World\\rthe quick brown\\rfox jumps over\\rthe lazy dog\", \"ls\": 0, \"j\": 2, \"fc\": [0, 0, 0], \"sc\": [0, 0, 0], \"sw\": 0, \"of\": true}, \"t\": 0}]}, \"p\": {}, \"m\": {\"g\": 1, \"a\": {\"a\": 0, \"k\": [0, 0], \"ix\": 2}}, \"a\": [{\"nm\": \"Text Range\", \"s\": {\"t\": 0, \"o\": {\"a\": 0, \"k\": 0}, \"s\": {\"a\": 0, \"k\": 60}, \"e\": {\"a\": 0, \"k\": 75}, \"a\": {\"a\": 0, \"k\": 100}, \"b\": 1, \"rn\": 0, \"sh\": 1, \"xe\": {\"a\": 0, \"k\": 0}, \"ne\": {\"a\": 0, \"k\": 0}, \"sm\": {\"a\": 0, \"k\": 100}, \"r\": 1}, \"a\": {\"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}, \"fc\": {\"a\": 0, \"k\": [0.196, 0.314, 0.69]}, \"fh\": {\"a\": 0, \"k\": 0}, \"fs\": {\"a\": 0, \"k\": 0}, \"fb\": {\"a\": 0, \"k\": 0}, \"sc\": {\"a\": 0, \"k\": [1, 0, 0]}, \"sw\": {\"a\": 0, \"k\": 0}, \"t\": {\"a\": 0, \"k\": 0}}}]}}, {\"ty\": 1, \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": {}, \"sc\": \"#ffffff\", \"sw\": 512, \"sh\": 350}]}, function (lottie, data) { var range = lottie.layers[0].t.a[0]; lottie.fonts.list[0].fFamily = \"monospace\"; lottie.layers[0].t.d.k[0].s.t = data[\"Text\"].replace(/\\n\\r?/g, \"\\r\") range.s.s.k = data[\"Start\"]; range.s.e.k = data[\"End\"]; range.s.o.k = data[\"Offset\"]; range.s.ne.k = data[\"Min Ease\"]; range.s.xe.k = data[\"Max Ease\"]; range.s.rn = Number(data[\"Randomize\"]); range.s.b = Number(data[\"Based On\"]); range.s.sh = Number(data[\"Shape\"]); range.s.r = Number(data[\"Range Units\"]); range.a.p.k = [data[\"Position X\"], data[\"Position Y\"]]; range.a.o.k = data[\"Opacity\"]; range.a.r.k = data[\"Rotation\"]; range.a.fc.k = data[\"Fill\"]; range.a.sc.k = data[\"Stroke\"]; range.a.sw.k = data[\"Stroke Width\"]; range.a.t.k = data[\"Letter Spacing\"]; range.a.fh.k = data[\"Fill Hue\"]; range.a.fs.k = data[\"Fill Saturation\"]; range.a.fb.k = data[\"Fill Brightness\"];this.json_viewer_contents = lottie.layers[0].t.a[0]; }, {} );","title":"Text Range"},{"location":"text/#text-range-selector","text":"Defines the range of characters to apply a property value only to a specific subset of the text document. r Defines whether the values are defined as a percentage or indices. The range is defined by s , e , and o . ne and xe define what happes to text that is only partly inside the selected range. b changes whether selection is done on per character basis, per word, etc. It also changes the meaning of an index when r is set to Indices. Attribute Type Description t 0-1 integer Expressible xe Animated number Max Ease ne Animated number Min Ease a Animated number Max Amount b Text Based Based On rn 0-1 integer Randomize sh Text Shape Shape o Animated number Offset r Text Range Units Range Units sm Animated number Selector Smoothness s Animated number Start e Animated number End Start 60 End 75 Offset 0 Min Ease 0 Max Ease 0 Randomize Range Units Percent Index Based On Characters Character Excluding Spaces Words Lines Shape Square Ramp Up Ramp Down Triangle Round Smooth Show JSON var lottie_player_62 = new PlaygroundPlayer( 62, 'playground_62_10', 'lottie_target_62', {\"v\": \"5.9.6\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 350, \"assets\": [], \"fonts\": {\"list\": [{\"origin\": 0, \"fPath\": \"\", \"fClass\": \"\", \"fFamily\": \"Sans\", \"fWeight\": \"\", \"fStyle\": \"Regular\", \"fName\": \"Sans\"}]}, \"layers\": [{\"ty\": 5, \"sr\": 1, \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": {\"p\": {\"a\": 0, \"k\": [256, 70, 0]}}, \"t\": {\"d\": {\"k\": [{\"s\": {\"s\": 70, \"f\": \"Sans\", \"t\": \"Hello World\\rthe quick brown\\rfox jumps over\\rthe lazy dog\", \"ls\": 0, \"j\": 2, \"fc\": [0, 0, 0], \"sc\": [0, 0, 0], \"sw\": 0, \"of\": true}, \"t\": 0}]}, \"p\": {}, \"m\": {\"g\": 1, \"a\": {\"a\": 0, \"k\": [0, 0], \"ix\": 2}}, \"a\": [{\"nm\": \"Text Range\", \"s\": {\"t\": 0, \"o\": {\"a\": 0, \"k\": 0}, \"s\": {\"a\": 0, \"k\": 60}, \"e\": {\"a\": 0, \"k\": 75}, \"a\": {\"a\": 0, \"k\": 100}, \"b\": 1, \"rn\": 0, \"sh\": 1, \"xe\": {\"a\": 0, \"k\": 0}, \"ne\": {\"a\": 0, \"k\": 0}, \"sm\": {\"a\": 0, \"k\": 100}, \"r\": 1}, \"a\": {\"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}, \"fc\": {\"a\": 0, \"k\": [0.196, 0.314, 0.69]}, \"fh\": {\"a\": 0, \"k\": 0}, \"fs\": {\"a\": 0, \"k\": 0}, \"fb\": {\"a\": 0, \"k\": 0}, \"sc\": {\"a\": 0, \"k\": [1, 0, 0]}, \"sw\": {\"a\": 0, \"k\": 0}, \"t\": {\"a\": 0, \"k\": 0}}}]}}, {\"ty\": 1, \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": {}, \"sc\": \"#ffffff\", \"sw\": 512, \"sh\": 350}]}, function (lottie, data) { var selector = lottie.layers[0].t.a[0].s; selector.s.k = data[\"Start\"]; selector.e.k = data[\"End\"]; selector.o.k = data[\"Offset\"]; selector.ne.k = data[\"Min Ease\"]; selector.xe.k = data[\"Max Ease\"]; selector.rn = Number(data[\"Randomize\"]); selector.b = Number(data[\"Based On\"]); selector.sh = Number(data[\"Shape\"]); selector.r = Number(data[\"Range Units\"]);this.json_viewer_contents = lottie.layers[0].t.a[0].s; }, {} );","title":"Text Range Selector"},{"location":"text/#text-style","text":"Has the properties of a transform and the style options of a text document. It applies such transform and style to the part of the text defined by the text selector property Also has the attributes from Transform . Attribute Type Description sw Animated number Stroke Width sc Animated Color Stroke Color sh Animated number Stroke Hue ss Animated number Stroke Saturation sb Animated number Stroke Brightness so Animated number Stroke Opacity fc Animated Color Fill Color fh Animated number Fill Hue fs Animated number Fill Saturation fb Animated number Fill Brightness fo Animated number Fill Opacity t Animated number Letter Spacing bl Animated number Blur ls Animated number Line Spacing Transform Position X 0 Position Y 0 Rotation 0 Opacity 100 Style Fill Fill Hue 0 Fill Saturation 0 Fill Brightness 0 Stroke Stroke Width 0 Letter Spacing 0 Show JSON var lottie_player_63 = new PlaygroundPlayer( 63, 'playground_63_12', 'lottie_target_63', {\"v\": \"5.9.6\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 350, \"assets\": [], \"fonts\": {\"list\": [{\"origin\": 0, \"fPath\": \"\", \"fClass\": \"\", \"fFamily\": \"Sans\", \"fWeight\": \"\", \"fStyle\": \"Regular\", \"fName\": \"Sans\"}]}, \"layers\": [{\"ty\": 5, \"sr\": 1, \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": {\"p\": {\"a\": 0, \"k\": [256, 70, 0]}}, \"t\": {\"d\": {\"k\": [{\"s\": {\"s\": 70, \"f\": \"Sans\", \"t\": \"Hello World\\rthe quick brown\\rfox jumps over\\rthe lazy dog\", \"ls\": 0, \"j\": 2, \"fc\": [0, 0, 0], \"sc\": [0, 0, 0], \"sw\": 0, \"of\": true}, \"t\": 0}]}, \"p\": {}, \"m\": {\"g\": 1, \"a\": {\"a\": 0, \"k\": [0, 0], \"ix\": 2}}, \"a\": [{\"nm\": \"Text Range\", \"s\": {\"t\": 0, \"o\": {\"a\": 0, \"k\": 0}, \"s\": {\"a\": 0, \"k\": 60}, \"e\": {\"a\": 0, \"k\": 75}, \"a\": {\"a\": 0, \"k\": 100}, \"b\": 1, \"rn\": 0, \"sh\": 1, \"xe\": {\"a\": 0, \"k\": 0}, \"ne\": {\"a\": 0, \"k\": 0}, \"sm\": {\"a\": 0, \"k\": 100}, \"r\": 1}, \"a\": {\"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}, \"fc\": {\"a\": 0, \"k\": [0.196, 0.314, 0.69]}, \"fh\": {\"a\": 0, \"k\": 0}, \"fs\": {\"a\": 0, \"k\": 0}, \"fb\": {\"a\": 0, \"k\": 0}, \"sc\": {\"a\": 0, \"k\": [1, 0, 0]}, \"sw\": {\"a\": 0, \"k\": 0}, \"t\": {\"a\": 0, \"k\": 0}}}]}}, {\"ty\": 1, \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": {}, \"sc\": \"#ffffff\", \"sw\": 512, \"sh\": 350}]}, function (lottie, data) { var range = lottie.layers[0].t.a[0]; range.a.p.k = [data[\"Position X\"], data[\"Position Y\"]]; range.a.o.k = data[\"Opacity\"]; range.a.r.k = data[\"Rotation\"]; range.a.fc.k = data[\"Fill\"]; range.a.sc.k = data[\"Stroke\"]; range.a.sw.k = data[\"Stroke Width\"]; range.a.t.k = data[\"Letter Spacing\"]; range.a.fh.k = data[\"Fill Hue\"]; range.a.fs.k = data[\"Fill Saturation\"]; range.a.fb.k = data[\"Fill Brightness\"];this.json_viewer_contents = lottie.layers[0].t.a[0].a; }, {} );","title":"Text Style"},{"location":"breakdown/bezier/","text":"Bezier Curves var lottie_player_69 = new LottiePlayer( 'lottie_target_69', '../../examples/bezier_expression.json', true, {} ); Introduction to Beziers Bezier curves are a common way of approximating arbitrary shapes in computer graphics. They represent an arc of a polynomial, and they can be of any degree, but usually you will mostly find quadratic and cubic beziers. Lottie only deals in cubic beziers so we'll focus on those. A bezier curve of degree n is defined by n +1 points. The first and the last of such points will lay on the curve, while the others define the shape of the segment. So for the case of a cubic bezier (degree 3) you have 4 points. To find a point on a bezier, you usually define it as the result of an interpolation within the polynomial curve. The interpolation factor is usually referred to as t . The easiest way of calculating the poition of a point in a bezier given a t is to perform linear interpolations between the bezier points, each step reducing the curve to one with a degree less than the previous, until you end up with a final point. For example in the cubic case, you interpolate each cubic point with the next, resulting in 3 quadratic points. You repeat the process on these 3 points, and you end up with 2 other points. Finally you perform linear interpolation between the two to get the result. In the example below you can control the t value to see how this algorithm works. The black dots are the ones that define the bezier, and the red dot is the position along the bezier at the given t . t 0.5 var lottie_player_67 = new PlaygroundPlayer( 67, 'None', 'lottie_target_67', {\"nm\": \"Animation\", \"fr\": 60, \"ip\": 0, \"op\": 280, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [], \"chars\": [], \"layers\": [{\"nm\": \"Shapes\", \"ddd\": 0, \"hd\": false, \"ks\": {}, \"ao\": 0, \"ip\": 0, \"op\": 280, \"st\": 0, \"hasMask\": false, \"masksProperties\": [], \"ef\": [{\"ef\": [{\"ty\": 0, \"nm\": \"Slider\", \"v\": {\"a\": 1, \"k\": [{\"t\": 0, \"i\": {\"x\": [0.667], \"y\": [1]}, \"o\": {\"x\": [0.333], \"y\": [0]}, \"s\": [0]}, {\"t\": 120, \"i\": {\"x\": [0.667], \"y\": [1]}, \"o\": {\"x\": [0.333], \"y\": [0]}, \"s\": [1]}, {\"t\": 140, \"i\": {\"x\": [0.667], \"y\": [1]}, \"o\": {\"x\": [0.333], \"y\": [0]}, \"s\": [1]}, {\"t\": 260, \"s\": [0]}]}}], \"ty\": 5, \"nm\": \"Slider\"}], \"mb\": false, \"ty\": 4, \"shapes\": [{\"nm\": \"Bezier Point\", \"hd\": false, \"ty\": \"gr\", \"it\": [{\"nm\": \"p0\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [25, 400], \"x\": \"var group = thisLayer.content(\\\"Linear Points\\\");\\nvar pt_index = 0;\\nvar pt_from = group.content(\\\"p\\\"+pt_index).position;\\nvar pt_to = group.content(\\\"p\\\"+(pt_index+1)).position;\\nvar t = thisLayer.effect(\\\"Slider\\\")(\\\"Slider\\\");\\nvar $bm_rt = linear(t, pt_from, pt_to);\\n\"}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"hd\": false, \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.125, 0]}}, {\"hd\": false, \"ty\": \"tr\", \"s\": {\"a\": 0, \"k\": [100, 100]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"nm\": \"Linear Points\", \"hd\": false, \"ty\": \"gr\", \"it\": [{\"nm\": \"p0\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [25, 400], \"x\": \"var group = thisLayer.content(\\\"Quadratic Points\\\");\\nvar pt_index = 0;\\nvar pt_from = group.content(\\\"p\\\"+pt_index).position;\\nvar pt_to = group.content(\\\"p\\\"+(pt_index+1)).position;\\nvar t = thisLayer.effect(\\\"Slider\\\")(\\\"Slider\\\");\\nvar $bm_rt = linear(t, pt_from, pt_to);\\n\"}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"nm\": \"p1\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [130, 170], \"x\": \"var group = thisLayer.content(\\\"Quadratic Points\\\");\\nvar pt_index = 1;\\nvar pt_from = group.content(\\\"p\\\"+pt_index).position;\\nvar pt_to = group.content(\\\"p\\\"+(pt_index+1)).position;\\nvar t = thisLayer.effect(\\\"Slider\\\")(\\\"Slider\\\");\\nvar $bm_rt = linear(t, pt_from, pt_to);\\n\"}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"hd\": false, \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.8, 0]}}, {\"hd\": false, \"ty\": \"tr\", \"s\": {\"a\": 0, \"k\": [100, 100]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"nm\": \"Linear Lines\", \"hd\": false, \"ty\": \"gr\", \"it\": [{\"ty\": \"sh\", \"ks\": {\"a\": 0, \"k\": {\"i\": [], \"o\": [], \"v\": []}, \"x\": \"var group = thisLayer.content(\\\"Linear Points\\\");\\nvar num_points = 2;\\nvar points = [];\\nvar ip = [];\\nvar op = [];\\nfor ( var i = 0; i < num_points; i++ )\\n{\\n var pos = group.content(\\\"p\\\" + i).position;\\n points.push(pos);\\n ip.push(pos);\\n op.push(pos);\\n}\\nvar $bm_rt = {\\n v: points,\\n i: ip,\\n o: op\\n};\\n\"}}, {\"hd\": false, \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.8, 0]}, \"w\": {\"a\": 0, \"k\": 10}}, {\"hd\": false, \"ty\": \"tr\", \"s\": {\"a\": 0, \"k\": [100, 100]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"nm\": \"Quadratic Points\", \"hd\": false, \"ty\": \"gr\", \"it\": [{\"nm\": \"p0\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [25, 400], \"x\": \"var group = thisLayer.content(\\\"Cubic Points\\\");\\nvar pt_index = 0;\\nvar pt_from = group.content(\\\"p\\\"+pt_index).position;\\nvar pt_to = group.content(\\\"p\\\"+(pt_index+1)).position;\\nvar t = thisLayer.effect(\\\"Slider\\\")(\\\"Slider\\\");\\nvar $bm_rt = linear(t, pt_from, pt_to);\\n\"}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"nm\": \"p1\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [130, 170], \"x\": \"var group = thisLayer.content(\\\"Cubic Points\\\");\\nvar pt_index = 1;\\nvar pt_from = group.content(\\\"p\\\"+pt_index).position;\\nvar pt_to = group.content(\\\"p\\\"+(pt_index+1)).position;\\nvar t = thisLayer.effect(\\\"Slider\\\")(\\\"Slider\\\");\\nvar $bm_rt = linear(t, pt_from, pt_to);\\n\"}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"nm\": \"p2\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [350, 230], \"x\": \"var group = thisLayer.content(\\\"Cubic Points\\\");\\nvar pt_index = 2;\\nvar pt_from = group.content(\\\"p\\\"+pt_index).position;\\nvar pt_to = group.content(\\\"p\\\"+(pt_index+1)).position;\\nvar t = thisLayer.effect(\\\"Slider\\\")(\\\"Slider\\\");\\nvar $bm_rt = linear(t, pt_from, pt_to);\\n\"}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"hd\": false, \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.2, 0.2, 1]}}, {\"hd\": false, \"ty\": \"tr\", \"s\": {\"a\": 0, \"k\": [100, 100]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"nm\": \"Quadratic Lines\", \"hd\": false, \"ty\": \"gr\", \"it\": [{\"ty\": \"sh\", \"ks\": {\"a\": 0, \"k\": {\"i\": [], \"o\": [], \"v\": []}, \"x\": \"var group = thisLayer.content(\\\"Quadratic Points\\\");\\nvar num_points = 3;\\nvar points = [];\\nvar ip = [];\\nvar op = [];\\nfor ( var i = 0; i < num_points; i++ )\\n{\\n var pos = group.content(\\\"p\\\" + i).position;\\n points.push(pos);\\n ip.push(pos);\\n op.push(pos);\\n}\\nvar $bm_rt = {\\n v: points,\\n i: ip,\\n o: op\\n};\\n\"}}, {\"hd\": false, \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.2, 0.2, 1]}, \"w\": {\"a\": 0, \"k\": 10}}, {\"hd\": false, \"ty\": \"tr\", \"s\": {\"a\": 0, \"k\": [100, 100]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"nm\": \"Cubic Points\", \"hd\": false, \"ty\": \"gr\", \"it\": [{\"nm\": \"p0\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [25, 400]}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"nm\": \"p1\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [130, 170]}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"nm\": \"p2\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [350, 230]}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"nm\": \"p3\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [485, 400]}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"hd\": false, \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0, 0]}}, {\"hd\": false, \"ty\": \"tr\", \"s\": {\"a\": 0, \"k\": [100, 100]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"nm\": \"Cubic Lines\", \"hd\": false, \"ty\": \"gr\", \"it\": [{\"ty\": \"sh\", \"ks\": {\"a\": 0, \"k\": {\"i\": [], \"o\": [], \"v\": []}, \"x\": \"var group = thisLayer.content(\\\"Cubic Points\\\");\\nvar num_points = 4;\\nvar points = [];\\nvar ip = [];\\nvar op = [];\\nfor ( var i = 0; i < num_points; i++ )\\n{\\n var pos = group.content(\\\"p\\\" + i).position;\\n points.push(pos);\\n ip.push(pos);\\n op.push(pos);\\n}\\nvar $bm_rt = {\\n v: points,\\n i: ip,\\n o: op\\n};\\n\"}}, {\"hd\": false, \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0, 0]}, \"w\": {\"a\": 0, \"k\": 10}}, {\"hd\": false, \"ty\": \"tr\", \"s\": {\"a\": 0, \"k\": [100, 100]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"nm\": \"Bezier Result\", \"hd\": false, \"ty\": \"gr\", \"it\": [{\"ty\": \"sh\", \"ks\": {\"a\": 0, \"k\": {\"i\": [], \"o\": [], \"v\": []}, \"x\": \"var group = thisLayer.content(\\\"Cubic Points\\\");\\nvar $bm_rt = {\\n v: [group.content(\\\"p0\\\").position, group.content(\\\"p3\\\").position],\\n i: [[0, 0], group.content(\\\"p2\\\").position],\\n o: [group.content(\\\"p1\\\").position, [0,0]]\\n};\\n\"}}, {\"hd\": false, \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.8, 0]}, \"w\": {\"a\": 0, \"k\": 10}}, {\"hd\": false, \"ty\": \"tr\", \"s\": {\"a\": 0, \"k\": [100, 100]}, \"o\": {\"a\": 0, \"k\": 100}}]}]}]}, function (lottie, data) { lottie.layers[0].ef[0].ef[0].v.a = 0; lottie.layers[0].ef[0].ef[0].v.k = data[\"t\"]; }, {} ); Poly Beziers Usually shapes are defined as a polybezier, which is the a concept equivalent to polygons, but with bezier segments as their edges. Each bezier segment has its last point in the same position as the first point in the following segment. This results in a sequence of points, some of which are along the line and some of which are not. For polybeziers with cubic segments, there are two points outside the path between each pair of points along the path. For this reason instead of viewing the polybezier as a sequence of bezier segments, they are often seen as a sequence of vertices and tangents. The vertices are the points along the path, which correspond to the end points of the segments. Each point has two tangents associated with them, one \"in\" thangent, and one \"out\" tangent. The \"out\" tangent is the second point defining the bezier segment following the vertex and the \"in\" tangent is the third point defining the bezier segment coming into the vertex. Beziers in Lottie An shape in Lotttie is represented as a cubic polybezier and it's represented in the JSON as an object with the following attributes: v is an array of vertices. i is an array of \"in\" tangent points, relative to v . o is an array of \"out\" tangent points, relative to v . c is a boolean determining whether the polybezier is closed. If it is, there's an additional bezier segment between the last point in v and the first. Show JSON BezierPreviewEditor.stand_alone(document.getElementById(\"editor_68\"), (lottie) => { var raw_json = JSON.stringify(lottie, undefined, 4); var pretty_json = hljs.highlight(\"json\", raw_json).value; document.getElementById(\"json_viewer_68\").innerHTML = pretty_json; }, );","title":"Bezier Curves"},{"location":"breakdown/bezier/#bezier-curves","text":"var lottie_player_69 = new LottiePlayer( 'lottie_target_69', '../../examples/bezier_expression.json', true, {} );","title":"Bezier Curves"},{"location":"breakdown/bezier/#introduction-to-beziers","text":"Bezier curves are a common way of approximating arbitrary shapes in computer graphics. They represent an arc of a polynomial, and they can be of any degree, but usually you will mostly find quadratic and cubic beziers. Lottie only deals in cubic beziers so we'll focus on those. A bezier curve of degree n is defined by n +1 points. The first and the last of such points will lay on the curve, while the others define the shape of the segment. So for the case of a cubic bezier (degree 3) you have 4 points. To find a point on a bezier, you usually define it as the result of an interpolation within the polynomial curve. The interpolation factor is usually referred to as t . The easiest way of calculating the poition of a point in a bezier given a t is to perform linear interpolations between the bezier points, each step reducing the curve to one with a degree less than the previous, until you end up with a final point. For example in the cubic case, you interpolate each cubic point with the next, resulting in 3 quadratic points. You repeat the process on these 3 points, and you end up with 2 other points. Finally you perform linear interpolation between the two to get the result. In the example below you can control the t value to see how this algorithm works. The black dots are the ones that define the bezier, and the red dot is the position along the bezier at the given t . t 0.5 var lottie_player_67 = new PlaygroundPlayer( 67, 'None', 'lottie_target_67', {\"nm\": \"Animation\", \"fr\": 60, \"ip\": 0, \"op\": 280, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [], \"chars\": [], \"layers\": [{\"nm\": \"Shapes\", \"ddd\": 0, \"hd\": false, \"ks\": {}, \"ao\": 0, \"ip\": 0, \"op\": 280, \"st\": 0, \"hasMask\": false, \"masksProperties\": [], \"ef\": [{\"ef\": [{\"ty\": 0, \"nm\": \"Slider\", \"v\": {\"a\": 1, \"k\": [{\"t\": 0, \"i\": {\"x\": [0.667], \"y\": [1]}, \"o\": {\"x\": [0.333], \"y\": [0]}, \"s\": [0]}, {\"t\": 120, \"i\": {\"x\": [0.667], \"y\": [1]}, \"o\": {\"x\": [0.333], \"y\": [0]}, \"s\": [1]}, {\"t\": 140, \"i\": {\"x\": [0.667], \"y\": [1]}, \"o\": {\"x\": [0.333], \"y\": [0]}, \"s\": [1]}, {\"t\": 260, \"s\": [0]}]}}], \"ty\": 5, \"nm\": \"Slider\"}], \"mb\": false, \"ty\": 4, \"shapes\": [{\"nm\": \"Bezier Point\", \"hd\": false, \"ty\": \"gr\", \"it\": [{\"nm\": \"p0\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [25, 400], \"x\": \"var group = thisLayer.content(\\\"Linear Points\\\");\\nvar pt_index = 0;\\nvar pt_from = group.content(\\\"p\\\"+pt_index).position;\\nvar pt_to = group.content(\\\"p\\\"+(pt_index+1)).position;\\nvar t = thisLayer.effect(\\\"Slider\\\")(\\\"Slider\\\");\\nvar $bm_rt = linear(t, pt_from, pt_to);\\n\"}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"hd\": false, \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.125, 0]}}, {\"hd\": false, \"ty\": \"tr\", \"s\": {\"a\": 0, \"k\": [100, 100]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"nm\": \"Linear Points\", \"hd\": false, \"ty\": \"gr\", \"it\": [{\"nm\": \"p0\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [25, 400], \"x\": \"var group = thisLayer.content(\\\"Quadratic Points\\\");\\nvar pt_index = 0;\\nvar pt_from = group.content(\\\"p\\\"+pt_index).position;\\nvar pt_to = group.content(\\\"p\\\"+(pt_index+1)).position;\\nvar t = thisLayer.effect(\\\"Slider\\\")(\\\"Slider\\\");\\nvar $bm_rt = linear(t, pt_from, pt_to);\\n\"}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"nm\": \"p1\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [130, 170], \"x\": \"var group = thisLayer.content(\\\"Quadratic Points\\\");\\nvar pt_index = 1;\\nvar pt_from = group.content(\\\"p\\\"+pt_index).position;\\nvar pt_to = group.content(\\\"p\\\"+(pt_index+1)).position;\\nvar t = thisLayer.effect(\\\"Slider\\\")(\\\"Slider\\\");\\nvar $bm_rt = linear(t, pt_from, pt_to);\\n\"}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"hd\": false, \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.8, 0]}}, {\"hd\": false, \"ty\": \"tr\", \"s\": {\"a\": 0, \"k\": [100, 100]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"nm\": \"Linear Lines\", \"hd\": false, \"ty\": \"gr\", \"it\": [{\"ty\": \"sh\", \"ks\": {\"a\": 0, \"k\": {\"i\": [], \"o\": [], \"v\": []}, \"x\": \"var group = thisLayer.content(\\\"Linear Points\\\");\\nvar num_points = 2;\\nvar points = [];\\nvar ip = [];\\nvar op = [];\\nfor ( var i = 0; i < num_points; i++ )\\n{\\n var pos = group.content(\\\"p\\\" + i).position;\\n points.push(pos);\\n ip.push(pos);\\n op.push(pos);\\n}\\nvar $bm_rt = {\\n v: points,\\n i: ip,\\n o: op\\n};\\n\"}}, {\"hd\": false, \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.8, 0]}, \"w\": {\"a\": 0, \"k\": 10}}, {\"hd\": false, \"ty\": \"tr\", \"s\": {\"a\": 0, \"k\": [100, 100]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"nm\": \"Quadratic Points\", \"hd\": false, \"ty\": \"gr\", \"it\": [{\"nm\": \"p0\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [25, 400], \"x\": \"var group = thisLayer.content(\\\"Cubic Points\\\");\\nvar pt_index = 0;\\nvar pt_from = group.content(\\\"p\\\"+pt_index).position;\\nvar pt_to = group.content(\\\"p\\\"+(pt_index+1)).position;\\nvar t = thisLayer.effect(\\\"Slider\\\")(\\\"Slider\\\");\\nvar $bm_rt = linear(t, pt_from, pt_to);\\n\"}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"nm\": \"p1\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [130, 170], \"x\": \"var group = thisLayer.content(\\\"Cubic Points\\\");\\nvar pt_index = 1;\\nvar pt_from = group.content(\\\"p\\\"+pt_index).position;\\nvar pt_to = group.content(\\\"p\\\"+(pt_index+1)).position;\\nvar t = thisLayer.effect(\\\"Slider\\\")(\\\"Slider\\\");\\nvar $bm_rt = linear(t, pt_from, pt_to);\\n\"}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"nm\": \"p2\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [350, 230], \"x\": \"var group = thisLayer.content(\\\"Cubic Points\\\");\\nvar pt_index = 2;\\nvar pt_from = group.content(\\\"p\\\"+pt_index).position;\\nvar pt_to = group.content(\\\"p\\\"+(pt_index+1)).position;\\nvar t = thisLayer.effect(\\\"Slider\\\")(\\\"Slider\\\");\\nvar $bm_rt = linear(t, pt_from, pt_to);\\n\"}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"hd\": false, \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.2, 0.2, 1]}}, {\"hd\": false, \"ty\": \"tr\", \"s\": {\"a\": 0, \"k\": [100, 100]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"nm\": \"Quadratic Lines\", \"hd\": false, \"ty\": \"gr\", \"it\": [{\"ty\": \"sh\", \"ks\": {\"a\": 0, \"k\": {\"i\": [], \"o\": [], \"v\": []}, \"x\": \"var group = thisLayer.content(\\\"Quadratic Points\\\");\\nvar num_points = 3;\\nvar points = [];\\nvar ip = [];\\nvar op = [];\\nfor ( var i = 0; i < num_points; i++ )\\n{\\n var pos = group.content(\\\"p\\\" + i).position;\\n points.push(pos);\\n ip.push(pos);\\n op.push(pos);\\n}\\nvar $bm_rt = {\\n v: points,\\n i: ip,\\n o: op\\n};\\n\"}}, {\"hd\": false, \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.2, 0.2, 1]}, \"w\": {\"a\": 0, \"k\": 10}}, {\"hd\": false, \"ty\": \"tr\", \"s\": {\"a\": 0, \"k\": [100, 100]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"nm\": \"Cubic Points\", \"hd\": false, \"ty\": \"gr\", \"it\": [{\"nm\": \"p0\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [25, 400]}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"nm\": \"p1\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [130, 170]}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"nm\": \"p2\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [350, 230]}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"nm\": \"p3\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [485, 400]}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"hd\": false, \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0, 0]}}, {\"hd\": false, \"ty\": \"tr\", \"s\": {\"a\": 0, \"k\": [100, 100]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"nm\": \"Cubic Lines\", \"hd\": false, \"ty\": \"gr\", \"it\": [{\"ty\": \"sh\", \"ks\": {\"a\": 0, \"k\": {\"i\": [], \"o\": [], \"v\": []}, \"x\": \"var group = thisLayer.content(\\\"Cubic Points\\\");\\nvar num_points = 4;\\nvar points = [];\\nvar ip = [];\\nvar op = [];\\nfor ( var i = 0; i < num_points; i++ )\\n{\\n var pos = group.content(\\\"p\\\" + i).position;\\n points.push(pos);\\n ip.push(pos);\\n op.push(pos);\\n}\\nvar $bm_rt = {\\n v: points,\\n i: ip,\\n o: op\\n};\\n\"}}, {\"hd\": false, \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0, 0]}, \"w\": {\"a\": 0, \"k\": 10}}, {\"hd\": false, \"ty\": \"tr\", \"s\": {\"a\": 0, \"k\": [100, 100]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"nm\": \"Bezier Result\", \"hd\": false, \"ty\": \"gr\", \"it\": [{\"ty\": \"sh\", \"ks\": {\"a\": 0, \"k\": {\"i\": [], \"o\": [], \"v\": []}, \"x\": \"var group = thisLayer.content(\\\"Cubic Points\\\");\\nvar $bm_rt = {\\n v: [group.content(\\\"p0\\\").position, group.content(\\\"p3\\\").position],\\n i: [[0, 0], group.content(\\\"p2\\\").position],\\n o: [group.content(\\\"p1\\\").position, [0,0]]\\n};\\n\"}}, {\"hd\": false, \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.8, 0]}, \"w\": {\"a\": 0, \"k\": 10}}, {\"hd\": false, \"ty\": \"tr\", \"s\": {\"a\": 0, \"k\": [100, 100]}, \"o\": {\"a\": 0, \"k\": 100}}]}]}]}, function (lottie, data) { lottie.layers[0].ef[0].ef[0].v.a = 0; lottie.layers[0].ef[0].ef[0].v.k = data[\"t\"]; }, {} );","title":"Introduction to Beziers"},{"location":"breakdown/bezier/#poly-beziers","text":"Usually shapes are defined as a polybezier, which is the a concept equivalent to polygons, but with bezier segments as their edges. Each bezier segment has its last point in the same position as the first point in the following segment. This results in a sequence of points, some of which are along the line and some of which are not. For polybeziers with cubic segments, there are two points outside the path between each pair of points along the path. For this reason instead of viewing the polybezier as a sequence of bezier segments, they are often seen as a sequence of vertices and tangents. The vertices are the points along the path, which correspond to the end points of the segments. Each point has two tangents associated with them, one \"in\" thangent, and one \"out\" tangent. The \"out\" tangent is the second point defining the bezier segment following the vertex and the \"in\" tangent is the third point defining the bezier segment coming into the vertex.","title":"Poly Beziers"},{"location":"breakdown/bezier/#beziers-in-lottie","text":"An shape in Lotttie is represented as a cubic polybezier and it's represented in the JSON as an object with the following attributes: v is an array of vertices. i is an array of \"in\" tangent points, relative to v . o is an array of \"out\" tangent points, relative to v . c is a boolean determining whether the polybezier is closed. If it is, there's an additional bezier segment between the last point in v and the first. Show JSON BezierPreviewEditor.stand_alone(document.getElementById(\"editor_68\"), (lottie) => { var raw_json = JSON.stringify(lottie, undefined, 4); var pretty_json = hljs.highlight(\"json\", raw_json).value; document.getElementById(\"json_viewer_68\").innerHTML = pretty_json; }, );","title":"Beziers in Lottie"},{"location":"breakdown/bouncy_ball/","text":"Bouncy Ball This page will show the basics of Lottie by inspecting this simple animation: var lottie_player_70 = new LottiePlayer( 'lottie_target_70', '../../examples/bouncy_ball.json', true, {} ); Note that Lottie files usually have their JSON minified, but the example files here have been expanded for ease of inspection. This dissection is not meant to be a complete description, so certain attributes will not be described but each section will have links to the relevant reference pages where you can find a description for those. Top level The top level object, describes the animation as a whole. { \"nm\": \"Bouncy Ball\", \"v\": \"5.5.2\", \"ip\": 0, \"op\": 120, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ ... ] } Here we see the basic properties: nm is the name of the document, it's not actually used by players. v shows the Lottie format version, some older files might have a slightly different structure. fr is the framerate in frames per second. Note that most timing information is described in frames within Lottie, so changing the framerate means the duration of the animation will also change. op is the last frame of the animation, after which the animation will loop or stop, depending on how the player is set up. In this case 120 frames at 60 fps will result in 2 seconds of animation. ip marks the first frame of the animation, usually it's set to 0 . w and h describe the width and height of the animation, any content outside the box starting at (0, 0) and ending at (w, h) will not be visible. Note that a lottie file is a vector format and can be scaled up and down. So you shouldn't think of these values as a size in pixels. Layers Now we look at the layers . Most file will be more complex than this and have multiple layers but here we only have one: { \"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 120, \"nm\": \"Layer\", \"ks\": { ... }, \"shapes\": [...] } We see the layer can also have a name ( nm ). You might note that ip and op have the same values as in the animation. This means the layer will always be visible. You can decide to show a layer only for a small amount of time, in which case you would set ip to the first frame the layer should be visible at and op to the last frame, and the layer will only be visible between those frames. ddd is a boolean value that indicates whether this layer contains 3D elements. ty is the layer type. In this case it's a shape layer . Finally ind is a unique number used to reference this layer. Here it's not being used since there is only one layer. Layer transform Here we'll have a look at the ks attribute of the layer that represents its transform : { \"a\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"p\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"s\": { \"a\": 0, \"k\": [ 100, 100 ] }, \"r\": { \"a\": 0, \"k\": 0 }, \"o\": { \"a\": 0, \"k\": 100 } } This layer does not have any transform so everything is at its default value. (If you see a transform missing some attributes, you can assume they have the values above) You might have noticed that all the attributes of the transform are objects with the same structure. This is because they are animatable properties . In this case they don't have any animations applied to them so a is 0 and k is the actual value. If they were animated, a would be 1 and k would have a list of keyframes (more on this later). The animated properties of a transform are as follows: a is the anchor point along which other transformations are applied (you can think of it as the center of rotation). p is the position (translation). Both a and p have arrays as values representing 2D coordinates. s is the scale and, similar to a and p , its value has 2 components. Note that values are expressed as percentages ( 100 meaning 100% or no scaling). r is the rotation angle in degrees. o is opacity, similar to s , it also is expressed as a percentage. You might also find sk and sa in a transform object, determining the skew. Shapes Since this is a shape layer, it contains a list of shapes. In this case there is only one shape: { \"ty\": \"gr\", \"nm\": \"Ellipse Group\", \"it\": [ ... ] } ty represents the type of the shape, in this case it's a group , which is simply a shape that contains other shapes. Groups add another layer of organization: you have layers at the top, shape layers can contain group shapes, and groups can contain other groups. nm is the name, same as before. it is the list of shapes within the group, we will inspect them one by one Ellipse { \"ty\": \"el\", \"nm\": \"Ellipse\", \"p\": { \"a\": 0, \"k\": [ 204, 169 ] }, \"s\": { \"a\": 0, \"k\": [ 153, 153 ] } } The first shape in the group is an ellipse (denoted by \"ty\": \"el\" ). It has two properties: position ( p ) and size ( s ). The position determines the center of the ellipse and size its two axes. In this case we can tell it's a circle since both values in s are the same. Fill { \"ty\": \"fl\", \"nm\": \"Fill\", \"o\": { \"a\": 0, \"k\": 100 }, \"c\": { \"a\": 0, \"k\": [ 0.710, 0.192, 0.278 ] }, \"r\": 1 } An ellipse by itself doesn't actually draw anything. it just defines the shape. So we need to apply some style to it. Here we have a fill shape that determines the fill color for the ellipse. r is not animated and it determines the fill rule . o is the opacity, as a percentage. c is a color . Colors are RGB triplets with components in [0, 1] . In this case it represents this color: [0.71, 0.192, 0.278] . Transform { \"ty\": \"tr\", \"a\": { \"a\": 0, \"k\": [ 204, 169 ] }, \"p\": { ... }, \"s\": { ... }, \"r\": { \"a\": 0, \"k\": 0 }, \"o\": { \"a\": 0, \"k\": 100 } } Unlike layers, that have the transform as an attribute, groups have them as a shape . Note that this might give you a false sense of flexibility, because players expect to have a transform shape at the end of their shape list. The attributes are the same as the layer transform, with the addition of ty to represent the shape type. Here position ( p ) and scale ( s ) are animated and we'll look into them separately: Animated Position { \"a\": 1, \"k\": [ { \"t\": 0, \"s\": [ 235, 106 ], \"h\": 0, \"o\": { \"x\": [ 0.333 ], \"y\": [ 0 ] }, \"i\": { \"x\": [ 1 ], \"y\": [ 1 ] } }, { \"t\": 60, \"s\": [ 235, 441 ], \"h\": 0, \"o\": { \"x\": [ 0 ], \"y\": [ 0 ] }, \"i\": { \"x\": [ 0.667 ], \"y\": [ 1 ] } }, { \"t\": 120, \"s\": [ 235, 106 ] } ] } a is 1 , denoting the property is animated. k contains a list of keyframes . First Keyframe { \"t\": 0, \"s\": [ 235, 106 ], \"h\": 0, \"o\": { \"x\": [ 0.333 ], \"y\": [ 0 ] }, \"i\": { \"x\": [ 1 ], \"y\": [ 1 ] } } The first keyframe specifies the time at which the property starts being animated. In this case t is 0 , meaning the animation starts right away. s shows the value the property will have at t . o and i specify the easing function . o affects the movement at the beginning of the keyframe and i at the end. In this case, it uses an \"ease in\" kind of curve, where the animation starts slowly and it picks up speed at the end. Second Keyframe { \"t\": 60, \"s\": [ 235, 441 ], \"h\": 0, \"o\": { \"x\": [ 0 ], \"y\": [ 0 ] }, \"i\": { \"x\": [ 0.667 ], \"y\": [ 1 ] } } Here is the second keyframe, t is 60 which is the half way point of the animation. You can compare s with the previous keyframe to see how the position is affected. In this case it went from [235, 106] to [235, 441] , meaning the ball has moved down. i and o are set up for an \"ease out\" curve, meaning the animation starts quick but eventually it slows down. Last Keyframe { \"t\": 120, \"s\": [ 235, 106 ] } The last keyframe is at the end of the animation ( t is 100 ). It doesn't have easing information because there are no more keyframes after this. The value of s is the same as in the first keyframe, this allows for a seamless loop. Animated scale { \"a\": 1, \"k\": [ { \"t\": 55, \"s\": [ 100, 100 ], \"h\": 0, \"o\": { \"x\": [ 0 ], \"y\": [ 0 ] }, \"i\": { \"x\": [ 1 ], \"y\": [ 1 ] } }, { \"t\": 60, \"s\": [ 136, 59 ], \"h\": 0, \"o\": { \"x\": [ 0 ], \"y\": [ 0 ] }, \"i\": { \"x\": [ 1 ], \"y\": [ 1 ] } }, { \"t\": 65, \"s\": [ 100, 100 ] } ] } This provides the \"squishing\" effect. The works the same as the animated position described above. One thing to note is the first and last keyframe have t that doesn't match with the ip and op of the animation. This mean the property will maintain its value on the time before the first keyframe and after the last one.","title":"Bouncy Ball"},{"location":"breakdown/bouncy_ball/#bouncy-ball","text":"This page will show the basics of Lottie by inspecting this simple animation: var lottie_player_70 = new LottiePlayer( 'lottie_target_70', '../../examples/bouncy_ball.json', true, {} ); Note that Lottie files usually have their JSON minified, but the example files here have been expanded for ease of inspection. This dissection is not meant to be a complete description, so certain attributes will not be described but each section will have links to the relevant reference pages where you can find a description for those.","title":"Bouncy Ball"},{"location":"breakdown/bouncy_ball/#top-level","text":"The top level object, describes the animation as a whole. { \"nm\": \"Bouncy Ball\", \"v\": \"5.5.2\", \"ip\": 0, \"op\": 120, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ ... ] } Here we see the basic properties: nm is the name of the document, it's not actually used by players. v shows the Lottie format version, some older files might have a slightly different structure. fr is the framerate in frames per second. Note that most timing information is described in frames within Lottie, so changing the framerate means the duration of the animation will also change. op is the last frame of the animation, after which the animation will loop or stop, depending on how the player is set up. In this case 120 frames at 60 fps will result in 2 seconds of animation. ip marks the first frame of the animation, usually it's set to 0 . w and h describe the width and height of the animation, any content outside the box starting at (0, 0) and ending at (w, h) will not be visible. Note that a lottie file is a vector format and can be scaled up and down. So you shouldn't think of these values as a size in pixels.","title":"Top level"},{"location":"breakdown/bouncy_ball/#layers","text":"Now we look at the layers . Most file will be more complex than this and have multiple layers but here we only have one: { \"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 120, \"nm\": \"Layer\", \"ks\": { ... }, \"shapes\": [...] } We see the layer can also have a name ( nm ). You might note that ip and op have the same values as in the animation. This means the layer will always be visible. You can decide to show a layer only for a small amount of time, in which case you would set ip to the first frame the layer should be visible at and op to the last frame, and the layer will only be visible between those frames. ddd is a boolean value that indicates whether this layer contains 3D elements. ty is the layer type. In this case it's a shape layer . Finally ind is a unique number used to reference this layer. Here it's not being used since there is only one layer.","title":"Layers"},{"location":"breakdown/bouncy_ball/#layer-transform","text":"Here we'll have a look at the ks attribute of the layer that represents its transform : { \"a\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"p\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"s\": { \"a\": 0, \"k\": [ 100, 100 ] }, \"r\": { \"a\": 0, \"k\": 0 }, \"o\": { \"a\": 0, \"k\": 100 } } This layer does not have any transform so everything is at its default value. (If you see a transform missing some attributes, you can assume they have the values above) You might have noticed that all the attributes of the transform are objects with the same structure. This is because they are animatable properties . In this case they don't have any animations applied to them so a is 0 and k is the actual value. If they were animated, a would be 1 and k would have a list of keyframes (more on this later). The animated properties of a transform are as follows: a is the anchor point along which other transformations are applied (you can think of it as the center of rotation). p is the position (translation). Both a and p have arrays as values representing 2D coordinates. s is the scale and, similar to a and p , its value has 2 components. Note that values are expressed as percentages ( 100 meaning 100% or no scaling). r is the rotation angle in degrees. o is opacity, similar to s , it also is expressed as a percentage. You might also find sk and sa in a transform object, determining the skew.","title":"Layer transform"},{"location":"breakdown/bouncy_ball/#shapes","text":"Since this is a shape layer, it contains a list of shapes. In this case there is only one shape: { \"ty\": \"gr\", \"nm\": \"Ellipse Group\", \"it\": [ ... ] } ty represents the type of the shape, in this case it's a group , which is simply a shape that contains other shapes. Groups add another layer of organization: you have layers at the top, shape layers can contain group shapes, and groups can contain other groups. nm is the name, same as before. it is the list of shapes within the group, we will inspect them one by one","title":"Shapes"},{"location":"breakdown/bouncy_ball/#ellipse","text":"{ \"ty\": \"el\", \"nm\": \"Ellipse\", \"p\": { \"a\": 0, \"k\": [ 204, 169 ] }, \"s\": { \"a\": 0, \"k\": [ 153, 153 ] } } The first shape in the group is an ellipse (denoted by \"ty\": \"el\" ). It has two properties: position ( p ) and size ( s ). The position determines the center of the ellipse and size its two axes. In this case we can tell it's a circle since both values in s are the same.","title":"Ellipse"},{"location":"breakdown/bouncy_ball/#fill","text":"{ \"ty\": \"fl\", \"nm\": \"Fill\", \"o\": { \"a\": 0, \"k\": 100 }, \"c\": { \"a\": 0, \"k\": [ 0.710, 0.192, 0.278 ] }, \"r\": 1 } An ellipse by itself doesn't actually draw anything. it just defines the shape. So we need to apply some style to it. Here we have a fill shape that determines the fill color for the ellipse. r is not animated and it determines the fill rule . o is the opacity, as a percentage. c is a color . Colors are RGB triplets with components in [0, 1] . In this case it represents this color: [0.71, 0.192, 0.278] .","title":"Fill"},{"location":"breakdown/bouncy_ball/#transform","text":"{ \"ty\": \"tr\", \"a\": { \"a\": 0, \"k\": [ 204, 169 ] }, \"p\": { ... }, \"s\": { ... }, \"r\": { \"a\": 0, \"k\": 0 }, \"o\": { \"a\": 0, \"k\": 100 } } Unlike layers, that have the transform as an attribute, groups have them as a shape . Note that this might give you a false sense of flexibility, because players expect to have a transform shape at the end of their shape list. The attributes are the same as the layer transform, with the addition of ty to represent the shape type. Here position ( p ) and scale ( s ) are animated and we'll look into them separately:","title":"Transform"},{"location":"breakdown/bouncy_ball/#animated-position","text":"{ \"a\": 1, \"k\": [ { \"t\": 0, \"s\": [ 235, 106 ], \"h\": 0, \"o\": { \"x\": [ 0.333 ], \"y\": [ 0 ] }, \"i\": { \"x\": [ 1 ], \"y\": [ 1 ] } }, { \"t\": 60, \"s\": [ 235, 441 ], \"h\": 0, \"o\": { \"x\": [ 0 ], \"y\": [ 0 ] }, \"i\": { \"x\": [ 0.667 ], \"y\": [ 1 ] } }, { \"t\": 120, \"s\": [ 235, 106 ] } ] } a is 1 , denoting the property is animated. k contains a list of keyframes .","title":"Animated Position"},{"location":"breakdown/bouncy_ball/#first-keyframe","text":"{ \"t\": 0, \"s\": [ 235, 106 ], \"h\": 0, \"o\": { \"x\": [ 0.333 ], \"y\": [ 0 ] }, \"i\": { \"x\": [ 1 ], \"y\": [ 1 ] } } The first keyframe specifies the time at which the property starts being animated. In this case t is 0 , meaning the animation starts right away. s shows the value the property will have at t . o and i specify the easing function . o affects the movement at the beginning of the keyframe and i at the end. In this case, it uses an \"ease in\" kind of curve, where the animation starts slowly and it picks up speed at the end.","title":"First Keyframe"},{"location":"breakdown/bouncy_ball/#second-keyframe","text":"{ \"t\": 60, \"s\": [ 235, 441 ], \"h\": 0, \"o\": { \"x\": [ 0 ], \"y\": [ 0 ] }, \"i\": { \"x\": [ 0.667 ], \"y\": [ 1 ] } } Here is the second keyframe, t is 60 which is the half way point of the animation. You can compare s with the previous keyframe to see how the position is affected. In this case it went from [235, 106] to [235, 441] , meaning the ball has moved down. i and o are set up for an \"ease out\" curve, meaning the animation starts quick but eventually it slows down.","title":"Second Keyframe"},{"location":"breakdown/bouncy_ball/#last-keyframe","text":"{ \"t\": 120, \"s\": [ 235, 106 ] } The last keyframe is at the end of the animation ( t is 100 ). It doesn't have easing information because there are no more keyframes after this. The value of s is the same as in the first keyframe, this allows for a seamless loop.","title":"Last Keyframe"},{"location":"breakdown/bouncy_ball/#animated-scale","text":"{ \"a\": 1, \"k\": [ { \"t\": 55, \"s\": [ 100, 100 ], \"h\": 0, \"o\": { \"x\": [ 0 ], \"y\": [ 0 ] }, \"i\": { \"x\": [ 1 ], \"y\": [ 1 ] } }, { \"t\": 60, \"s\": [ 136, 59 ], \"h\": 0, \"o\": { \"x\": [ 0 ], \"y\": [ 0 ] }, \"i\": { \"x\": [ 1 ], \"y\": [ 1 ] } }, { \"t\": 65, \"s\": [ 100, 100 ] } ] } This provides the \"squishing\" effect. The works the same as the animated position described above. One thing to note is the first and last keyframe have t that doesn't match with the ip and op of the animation. This mean the property will maintain its value on the time before the first keyframe and after the last one.","title":"Animated scale"},{"location":"breakdown/lottie_from_scratch/","text":"Lottie from Scratch In this example, we'll build a simple Lottie animation from scratch. Introducing the builder tool The builder tool allows you to build lottie animations from its JSON components using a more convenient interface than manually editing the cryptic lottie JSON attributes. You can click on the categories on the toolbar to the left of the builder interface then drag and drop blocks into the workspace and see the effects. To the right you have a preview of the animation and the corresponding JSON. The rest of this guide will assume you are following along using the builder. Most block can be right-clicked to bring up a context menu, and you can select \"Help\" from that menu to go on the page that describes the object represented by that block. Setting up Ensure your workspace is empty, if it isn't click on the \"Clear\" button near the top-right. Start by selecting the Animation block in the Animation category and dragging it to the workspace. Then select a Shape Layer (from Layers) and drop it into the Layers slot of the Animation block. Your workspace should look something like this: You might have noticed the block attached to the layer. For simplicity all the common layer properties are in a separate block in the builder, this allows you to duplicate those blocks to copy the settings across layers and the block is collapsed by default to avoid cluttering the workspace. View workspace at the end of this step Adding Shapes In order to show something, we need to add some shapes to the layer. So let's add a Polystar, a Fill and a Stroke from the Shapes category. Note that the order is important: This should result in a black pentagon showing in the corner. View workspace at the end of this step Basic Properties We start by moving our shape in a more sensible position. To do so, select Static Property and connect it to the \"Position\" of the Polystar, then connect a \"x y\" block to it. Both these blocks are under \"Properties\". You can now edit the values of x and y to move the pentagon. For example, setting them both to 256 should move the shape to the center of the screen: You can do something similar to modify the size of the pentagon and the fill color, of course you need to select the right block types from the properties toolbox. The color can be changed by manually updating the RGB components or by selecting a color from the palette shown after clicking the color preview on the block. View workspace at the end of this step Making a Star We can turn the pentagon into a star by changing the star type and filling in some more properties: Note that while you can use just a number block for \"Rotation\", using the angle block allows you to edit the angle in a more intuitive way. You can tell these block apart because they are a different color and the angle block shows the \u00b0 symbol. View workspace at the end of this step Animating the Star Until now, we've only seen static properties, but now we can have a look at some animated ones. To animate the star rotation, we need to first disconnect the static property from it and connect an animated property in its place. Thne attach two keyframe blocks to the animated property. Once the keyframes are added, attach angle blocks to their value slots and change the second keyframe to have a time of 60 and a value of 72\u00b0. You should now see the star spinning in the preview. View workspace at the end of this step Making the Animation longer Currently, the animation lasts for 1 second (60 frames). If you want it to last for longer, you need to first change the Out Point in the animation block. Let's change it to 120 to make the animation last for 2 seconds. You'll see the star starts blinking, disappearing after a second and reappearing after another second. This is because we also need to update the layer Out Point. By default, the layer properties are collapsed, so right-click on the Layer Properties and select \"Expand Block\" from the context menu, then change its \"Out Point\" to match with the Animation block. Now the star remains visible the whole time, but it stops rotating at the second mark. To fix that you can update the second keyframe in the star rotation to have a time of 120. Alternatively you can add a third keyframe with that time and an appropriate value. View the final workspace","title":"Lottie from Scratch"},{"location":"breakdown/lottie_from_scratch/#lottie-from-scratch","text":"In this example, we'll build a simple Lottie animation from scratch.","title":"Lottie from Scratch"},{"location":"breakdown/lottie_from_scratch/#introducing-the-builder-tool","text":"The builder tool allows you to build lottie animations from its JSON components using a more convenient interface than manually editing the cryptic lottie JSON attributes. You can click on the categories on the toolbar to the left of the builder interface then drag and drop blocks into the workspace and see the effects. To the right you have a preview of the animation and the corresponding JSON. The rest of this guide will assume you are following along using the builder. Most block can be right-clicked to bring up a context menu, and you can select \"Help\" from that menu to go on the page that describes the object represented by that block.","title":"Introducing the builder tool"},{"location":"breakdown/lottie_from_scratch/#setting-up","text":"Ensure your workspace is empty, if it isn't click on the \"Clear\" button near the top-right. Start by selecting the Animation block in the Animation category and dragging it to the workspace. Then select a Shape Layer (from Layers) and drop it into the Layers slot of the Animation block. Your workspace should look something like this: You might have noticed the block attached to the layer. For simplicity all the common layer properties are in a separate block in the builder, this allows you to duplicate those blocks to copy the settings across layers and the block is collapsed by default to avoid cluttering the workspace. View workspace at the end of this step","title":"Setting up"},{"location":"breakdown/lottie_from_scratch/#adding-shapes","text":"In order to show something, we need to add some shapes to the layer. So let's add a Polystar, a Fill and a Stroke from the Shapes category. Note that the order is important: This should result in a black pentagon showing in the corner. View workspace at the end of this step","title":"Adding Shapes"},{"location":"breakdown/lottie_from_scratch/#basic-properties","text":"We start by moving our shape in a more sensible position. To do so, select Static Property and connect it to the \"Position\" of the Polystar, then connect a \"x y\" block to it. Both these blocks are under \"Properties\". You can now edit the values of x and y to move the pentagon. For example, setting them both to 256 should move the shape to the center of the screen: You can do something similar to modify the size of the pentagon and the fill color, of course you need to select the right block types from the properties toolbox. The color can be changed by manually updating the RGB components or by selecting a color from the palette shown after clicking the color preview on the block. View workspace at the end of this step","title":"Basic Properties"},{"location":"breakdown/lottie_from_scratch/#making-a-star","text":"We can turn the pentagon into a star by changing the star type and filling in some more properties: Note that while you can use just a number block for \"Rotation\", using the angle block allows you to edit the angle in a more intuitive way. You can tell these block apart because they are a different color and the angle block shows the \u00b0 symbol. View workspace at the end of this step","title":"Making a Star"},{"location":"breakdown/lottie_from_scratch/#animating-the-star","text":"Until now, we've only seen static properties, but now we can have a look at some animated ones. To animate the star rotation, we need to first disconnect the static property from it and connect an animated property in its place. Thne attach two keyframe blocks to the animated property. Once the keyframes are added, attach angle blocks to their value slots and change the second keyframe to have a time of 60 and a value of 72\u00b0. You should now see the star spinning in the preview. View workspace at the end of this step","title":"Animating the Star"},{"location":"breakdown/lottie_from_scratch/#making-the-animation-longer","text":"Currently, the animation lasts for 1 second (60 frames). If you want it to last for longer, you need to first change the Out Point in the animation block. Let's change it to 120 to make the animation last for 2 seconds. You'll see the star starts blinking, disappearing after a second and reappearing after another second. This is because we also need to update the layer Out Point. By default, the layer properties are collapsed, so right-click on the Layer Properties and select \"Expand Block\" from the context menu, then change its \"Out Point\" to match with the Animation block. Now the star remains visible the whole time, but it stops rotating at the second mark. To fix that you can update the second keyframe in the star rotation to have a time of 120. Alternatively you can add a third keyframe with that time and an appropriate value. View the final workspace","title":"Making the Animation longer"},{"location":"breakdown/precomps/","text":"Precompositions This page will explain Precompositions (or precomps for short), which are a defining feature of the Lottie format which allows for great flexibility in effects and organization of animation files. What are Precompositions? In short, a precomposition is an animation embedded inside another animation, of which you can control playback. Once you have a precomposition, you can use layers to reference it in various parts of the animation to avoid repeating elements. How do Precompositions work in a Lottie? The main object is the Precomposition Asset . Its structure is very simple, just an asset identifier and a list of layers. By itself a precomposition asset doesn't do much, it needs to be referenced by a Precomposition Layer . You can think of the precomp asset to be similar to a video asset, and the layer plays back the animation defined by that asset. Follows a simple example: First we start with a file without precomps: var lottie_player_78 = new LottiePlayer( 'lottie_target_78', '../../examples/precomp/star-nocomp.json', true, {} ); And the same animation but using a precomp: var lottie_player_79 = new LottiePlayer( 'lottie_target_79', '../../examples/precomp/star-comp.json', true, {} ); Now let's have a look at how the JSON changed: This is the original animation, nothing special about it: { \"nm\": \"Animation\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [ { \"nm\": \"Shape Layer\", \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"ks\": {}, \"shapes\": [/* ... */] } ] } And this is the version using a precomposition: { \"nm\": \"Animation\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [ { \"id\": \"Star\", \"layers\": [ { \"nm\": \"Shape Layer\", \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"shapes\": [/* ... */] } ] } ], \"layers\": [ { \"nm\": \"Precomp Layer\", \"refId\": \"Star\" \"ty\": 0, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {} } ], } As you can see, the layers in the original animation have been moved to an asset (in this example there was only one layer but it works the same when you have multiple layer). And in layers of the outer animation there is a single layer referencing the new asset. The structure of the asset is fairly straightforward: a unique identifier ( Star in the example) and the list of layers in the precomposition. The layer has the usual attributes you can find on visual layers and a couple others: refId is the identifier of the precomp the layer is referencing, w and h define the clipping rectangle for the composition, in this case they match the value in the outer animation. Important things to note A precomp doesn't contain assets, but it can reference assets defined in the main animation object. It can also reference other precomps. Layer indexes are unique in each composition: you can have a layer with index 0 in multiple precomps and in the main animation, references to these (such as when parenting layers) are relative to the composition. You need to always specify w and h in the precomp layer or nothing will be displayed. What can you do with Precompositions? In this section we'll describe some example use case including the initial animations and the result to compare how a file needs to be changed to obtain certain effects. Resizing If you need to resize an animation, the best way of doing it is by precomposing all its layers and then scale the precomp layer. While for simple examples you'd might be able to get away with scaling all the layers in the original animation, it gets complicated if you have parented layers or transforms applied to some of the layers. Note that in the example below w and h keep their initial value and only the scale is changed. Scale 50 Show JSON var lottie_player_71 = new PlaygroundPlayer( 71, 'playground_71_2', 'lottie_target_71', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 60, \"nm\": \"Animation\", \"mn\": \"{0b14b755-3d9e-4f7f-b7ab-21cd57d13e23}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [{\"id\": \"Star\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Shape Layer\", \"mn\": \"{4d57cabf-951f-4067-b50e-8307f9f5fe72}\", \"ks\": {}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{c99b4a89-363b-4cd3-8797-bf65b57fdd29}\", \"d\": 1, \"p\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [256, 256], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0, 0]}]}, \"or\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"ir\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"is\": {\"a\": 0, \"k\": 0}, \"os\": {\"a\": 0, \"k\": 0}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{eb7fbdff-0656-41f5-9337-3aa283dde263}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 6}, \"c\": {\"a\": 0, \"k\": [1, 0.3411764705882353, 0.01568627450980392]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{54bfe210-7450-4824-accc-eef8f6c48ae8}\", \"o\": {\"a\": 0, \"k\": 100}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}}]}]}], \"layers\": [{\"ddd\": 0, \"ty\": 0, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"nm\": \"Precomp Layer\", \"ks\": {}, \"refId\": \"Star\"}], \"meta\": {\"g\": \"Glaxnimate 0.5.0-93-g187709f5\"}}, function (lottie, data) { lottie.w = lottie.h = 512 * data[\"Scale\"] / 100; lottie.layers[0].ks.s = { a: 0, k: [ data[\"Scale\"], data[\"Scale\"] ] };this.json_viewer_contents = {...lottie, assets:[\"...\"]}; }, {} ); Speeding up and Slowing down Similarly, you can use time stretch to speed up and slow down an animation: Speed 50 Show JSON var lottie_player_72 = new PlaygroundPlayer( 72, 'playground_72_2', 'lottie_target_72', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 60, \"nm\": \"Animation\", \"mn\": \"{0b14b755-3d9e-4f7f-b7ab-21cd57d13e23}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [{\"id\": \"Star\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Shape Layer\", \"mn\": \"{4d57cabf-951f-4067-b50e-8307f9f5fe72}\", \"ks\": {}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{c99b4a89-363b-4cd3-8797-bf65b57fdd29}\", \"d\": 1, \"p\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [256, 256], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0, 0]}]}, \"or\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"ir\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"is\": {\"a\": 0, \"k\": 0}, \"os\": {\"a\": 0, \"k\": 0}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{eb7fbdff-0656-41f5-9337-3aa283dde263}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 6}, \"c\": {\"a\": 0, \"k\": [1, 0.3411764705882353, 0.01568627450980392]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{54bfe210-7450-4824-accc-eef8f6c48ae8}\", \"o\": {\"a\": 0, \"k\": 100}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}}]}]}], \"layers\": [{\"ddd\": 0, \"ty\": 0, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"nm\": \"Precomp Layer\", \"ks\": {}, \"refId\": \"Star\"}], \"meta\": {\"g\": \"Glaxnimate 0.5.0-93-g187709f5\"}}, function (lottie, data) { var time_mult = 100 / data[\"Speed\"]; lottie.op = 60 * time_mult; lottie.layers[0].op = 60 * time_mult; lottie.layers[0].sr = time_mult;this.json_viewer_contents = {...lottie, assets:[\"...\"]}; }, {} ); You can also change the start time to delay the start of the precomp playback: Start 30 Speed 50 Show JSON var lottie_player_73 = new PlaygroundPlayer( 73, 'playground_73_3', 'lottie_target_73', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 60, \"nm\": \"Animation\", \"mn\": \"{0b14b755-3d9e-4f7f-b7ab-21cd57d13e23}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [{\"id\": \"Star\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Shape Layer\", \"mn\": \"{4d57cabf-951f-4067-b50e-8307f9f5fe72}\", \"ks\": {}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{c99b4a89-363b-4cd3-8797-bf65b57fdd29}\", \"d\": 1, \"p\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [256, 256], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0, 0]}]}, \"or\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"ir\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"is\": {\"a\": 0, \"k\": 0}, \"os\": {\"a\": 0, \"k\": 0}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{eb7fbdff-0656-41f5-9337-3aa283dde263}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 6}, \"c\": {\"a\": 0, \"k\": [1, 0.3411764705882353, 0.01568627450980392]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{54bfe210-7450-4824-accc-eef8f6c48ae8}\", \"o\": {\"a\": 0, \"k\": 100}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}}]}]}], \"layers\": [{\"ddd\": 0, \"ty\": 0, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"nm\": \"Precomp Layer\", \"ks\": {}, \"refId\": \"Star\"}], \"meta\": {\"g\": \"Glaxnimate 0.5.0-93-g187709f5\"}}, function (lottie, data) { var time_mult = 100 / data[\"Speed\"]; var start = data[\"Start\"]; lottie.op = 60 * time_mult + start; lottie.layers[0].op = 60 * time_mult + start; lottie.layers[0].sr = time_mult; lottie.layers[0].st = start;this.json_viewer_contents = {...lottie, assets:[\"...\"]}; }, {} ); Reversing Playback While sr only allows you to speed up and slow down time, with time remapping You can have more interesting effects, such as reversing playback: Show JSON var lottie_player_74 = new PlaygroundPlayer( 74, 'playground_74_1', 'lottie_target_74', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 60, \"nm\": \"Animation\", \"mn\": \"{0b14b755-3d9e-4f7f-b7ab-21cd57d13e23}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [{\"id\": \"Star\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Shape Layer\", \"mn\": \"{4d57cabf-951f-4067-b50e-8307f9f5fe72}\", \"ks\": {}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{c99b4a89-363b-4cd3-8797-bf65b57fdd29}\", \"d\": 1, \"p\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [256, 256], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0, 0]}]}, \"or\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"ir\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"is\": {\"a\": 0, \"k\": 0}, \"os\": {\"a\": 0, \"k\": 0}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{eb7fbdff-0656-41f5-9337-3aa283dde263}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 6}, \"c\": {\"a\": 0, \"k\": [1, 0.3411764705882353, 0.01568627450980392]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{54bfe210-7450-4824-accc-eef8f6c48ae8}\", \"o\": {\"a\": 0, \"k\": 100}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}}]}]}], \"layers\": [{\"ddd\": 0, \"ty\": 0, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"nm\": \"Precomp Layer\", \"ks\": {}, \"refId\": \"Star\"}], \"meta\": {\"g\": \"Glaxnimate 0.5.0-93-g187709f5\"}}, function (lottie, data) { lottie.layers[0].tm = { a: 1, \"k\": [ { \"t\": 0, \"s\": [1], \"o\": { \"x\": 0, \"y\": 0}, \"i\": { \"x\": 1, \"y\": 1} }, { \"t\": 60, \"s\": [0], \"o\": { \"x\": 0, \"y\": 0}, \"i\": { \"x\": 1, \"y\": 1} } ] };this.json_viewer_contents = {...lottie, assets:[\"...\"]}; }, {} ); Repeated Elements Another important use for precomps is that they allow to have multiple layers showing the same precomp. In the following example the star is animated once but there are 8 precomp layers with different rotations: var lottie_player_80 = new LottiePlayer( 'lottie_target_80', '../../examples/precomp/star-splosion.json', true, {} ); Overlaying Animations Precomps also make it easier to combine multiple files into ones. One thing to keep in mind is if the two files already have assets, you need to ensure their asset identifier are unique, this can be done by overwriting asset id and layer refId properties to some kind of incremental values. In the following example we will overlay the animation from the last example with a different animation. First Animation: var lottie_player_81 = new LottiePlayer( 'lottie_target_81', '../../examples/precomp/star-splosion.json', true, {} ); Second Animation: var lottie_player_82 = new LottiePlayer( 'lottie_target_82', '../../examples/precomp/circle.json', true, {} ); Overlaid: Show JSON var lottie_player_75 = new PlaygroundPlayer( 75, 'playground_75_1', 'lottie_target_75', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 60, \"nm\": \"Animation\", \"mn\": \"{0b14b755-3d9e-4f7f-b7ab-21cd57d13e23}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [{\"id\": \"Star\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Shape Layer\", \"mn\": \"{4d57cabf-951f-4067-b50e-8307f9f5fe72}\", \"ks\": {}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{c99b4a89-363b-4cd3-8797-bf65b57fdd29}\", \"d\": 1, \"p\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [256, 256], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0, 0]}]}, \"or\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"ir\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"is\": {\"a\": 0, \"k\": 0}, \"os\": {\"a\": 0, \"k\": 0}, \"r\": {\"a\": 0, \"k\": -45}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{eb7fbdff-0656-41f5-9337-3aa283dde263}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 6}, \"c\": {\"a\": 0, \"k\": [1, 0.3411764705882353, 0.01568627450980392]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{54bfe210-7450-4824-accc-eef8f6c48ae8}\", \"o\": {\"a\": 0, \"k\": 100}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}}]}]}, {\"id\": \"Expanding Stars\", \"layers\": [{\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 0}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 45}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 90}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 135}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 180}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": -45}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": -90}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": -135}}}]}, {\"id\": \"Circle\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Layer\", \"mn\": \"{456fdfe5-686b-4006-92f4-951c47ab4bc7}\", \"ks\": {}, \"shapes\": [{\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{05d5f1a0-6046-4aea-a405-b9ba60a24bd7}\", \"d\": 1, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0, 0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [730, 730]}]}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{d835adb4-6502-4e3e-98c2-70d1145f1a23}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [6], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"c\": {\"a\": 0, \"k\": [0.11372549019607843, 0.1568627450980392, 0.2823529411764706]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{78036603-40f1-42ca-ada5-fee506b4ac58}\", \"o\": {\"a\": 1, \"k\": [{\"t\": 30, \"s\": [100], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}}]}]}], \"layers\": [{\"nm\": \"Expanding Stars Layer\", \"refId\": \"Expanding Stars\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {}}, {\"nm\": \"Circle Layer\", \"refId\": \"Circle\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {}}]}, function (lottie, data) { this.json_viewer_contents = {...lottie, assets:[\"...\"]}; }, {} ); If you look at the JSON you'll notice that this is how the structure changed: // First Animation: { \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [ { \"id\": \"Star\", \"layers\": [ /* Star Precomp Layers */ ] } ], \"layers\": [ /* First Animation Layers */ ] } // Second Animation { \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [ /* Second Animation Layers */ ] } // Overlaid { \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [ { \"id\": \"Star\", \"layers\": [ /* Star Precomp Layers */ ] }, { \"id\": \"Expanding Stars\", \"layers\": [ /* First Animation Layers */ ] }, { \"id\": \"Circle\", \"layers\": [ /* Second Animation Layers */ ] } ], \"layers\": [ { \"nm\": \"Expanding Stars Layer\", \"refId\": \"Expanding Stars\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {} }, { \"nm\": \"Circle Layer\", \"refId\": \"Circle\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {} } ] } In this example the two animations had the same duration and size, you can use the techniques described earlier to resize or retime the animations if you want to overlay animations with different sizes or durations. Concatenating Animations This works basically the same as overlaying them, just by changing some timing properties in the precomp layers. Show JSON var lottie_player_76 = new PlaygroundPlayer( 76, 'playground_76_1', 'lottie_target_76', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 60, \"nm\": \"Animation\", \"mn\": \"{0b14b755-3d9e-4f7f-b7ab-21cd57d13e23}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [{\"id\": \"Star\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Shape Layer\", \"mn\": \"{4d57cabf-951f-4067-b50e-8307f9f5fe72}\", \"ks\": {}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{c99b4a89-363b-4cd3-8797-bf65b57fdd29}\", \"d\": 1, \"p\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [256, 256], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0, 0]}]}, \"or\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"ir\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"is\": {\"a\": 0, \"k\": 0}, \"os\": {\"a\": 0, \"k\": 0}, \"r\": {\"a\": 0, \"k\": -45}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{eb7fbdff-0656-41f5-9337-3aa283dde263}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 6}, \"c\": {\"a\": 0, \"k\": [1, 0.3411764705882353, 0.01568627450980392]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{54bfe210-7450-4824-accc-eef8f6c48ae8}\", \"o\": {\"a\": 0, \"k\": 100}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}}]}]}, {\"id\": \"Expanding Stars\", \"layers\": [{\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 0}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 45}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 90}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 135}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 180}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": -45}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": -90}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": -135}}}]}, {\"id\": \"Circle\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Layer\", \"mn\": \"{456fdfe5-686b-4006-92f4-951c47ab4bc7}\", \"ks\": {}, \"shapes\": [{\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{05d5f1a0-6046-4aea-a405-b9ba60a24bd7}\", \"d\": 1, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0, 0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [730, 730]}]}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{d835adb4-6502-4e3e-98c2-70d1145f1a23}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [6], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"c\": {\"a\": 0, \"k\": [0.11372549019607843, 0.1568627450980392, 0.2823529411764706]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{78036603-40f1-42ca-ada5-fee506b4ac58}\", \"o\": {\"a\": 1, \"k\": [{\"t\": 30, \"s\": [100], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}}]}]}], \"layers\": [{\"nm\": \"Expanding Stars Layer\", \"refId\": \"Expanding Stars\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {}}, {\"nm\": \"Circle Layer\", \"refId\": \"Circle\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {}}]}, function (lottie, data) { lottie.op = 120 lottie.layers[1].ip = 60; lottie.layers[1].op = 120; lottie.layers[1].st = 60;this.json_viewer_contents = {...lottie, assets:[\"...\"]}; }, {} ); Masking Animations Just like any other visual layer, precomp layers can be used for mattes . Show JSON var lottie_player_77 = new PlaygroundPlayer( 77, 'playground_77_1', 'lottie_target_77', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 60, \"nm\": \"Animation\", \"mn\": \"{0b14b755-3d9e-4f7f-b7ab-21cd57d13e23}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [{\"id\": \"Star\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Shape Layer\", \"mn\": \"{4d57cabf-951f-4067-b50e-8307f9f5fe72}\", \"ks\": {}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{c99b4a89-363b-4cd3-8797-bf65b57fdd29}\", \"d\": 1, \"p\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [256, 256], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0, 0]}]}, \"or\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"ir\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"is\": {\"a\": 0, \"k\": 0}, \"os\": {\"a\": 0, \"k\": 0}, \"r\": {\"a\": 0, \"k\": -45}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{eb7fbdff-0656-41f5-9337-3aa283dde263}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 6}, \"c\": {\"a\": 0, \"k\": [1, 0.3411764705882353, 0.01568627450980392]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{54bfe210-7450-4824-accc-eef8f6c48ae8}\", \"o\": {\"a\": 0, \"k\": 100}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}}]}]}, {\"id\": \"Expanding Stars\", \"layers\": [{\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 0}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 45}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 90}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 135}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 180}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": -45}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": -90}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": -135}}}]}, {\"id\": \"Circle\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Layer\", \"mn\": \"{456fdfe5-686b-4006-92f4-951c47ab4bc7}\", \"ks\": {}, \"shapes\": [{\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{05d5f1a0-6046-4aea-a405-b9ba60a24bd7}\", \"d\": 1, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0, 0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [730, 730]}]}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{d835adb4-6502-4e3e-98c2-70d1145f1a23}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [6], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"c\": {\"a\": 0, \"k\": [0.11372549019607843, 0.1568627450980392, 0.2823529411764706]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{78036603-40f1-42ca-ada5-fee506b4ac58}\", \"o\": {\"a\": 1, \"k\": [{\"t\": 30, \"s\": [100], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}}]}]}], \"layers\": [{\"nm\": \"Expanding Stars Layer\", \"refId\": \"Expanding Stars\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {}}, {\"nm\": \"Circle Layer\", \"refId\": \"Circle\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {}}]}, function (lottie, data) { lottie.layers[0].td = 1; lottie.layers[1].tt = 1;this.json_viewer_contents = {...lottie, assets:[\"...\"]}; }, {} );","title":"Precompositions"},{"location":"breakdown/precomps/#precompositions","text":"This page will explain Precompositions (or precomps for short), which are a defining feature of the Lottie format which allows for great flexibility in effects and organization of animation files.","title":"Precompositions"},{"location":"breakdown/precomps/#what-are-precompositions","text":"In short, a precomposition is an animation embedded inside another animation, of which you can control playback. Once you have a precomposition, you can use layers to reference it in various parts of the animation to avoid repeating elements.","title":"What are Precompositions?"},{"location":"breakdown/precomps/#how-do-precompositions-work-in-a-lottie","text":"The main object is the Precomposition Asset . Its structure is very simple, just an asset identifier and a list of layers. By itself a precomposition asset doesn't do much, it needs to be referenced by a Precomposition Layer . You can think of the precomp asset to be similar to a video asset, and the layer plays back the animation defined by that asset. Follows a simple example: First we start with a file without precomps: var lottie_player_78 = new LottiePlayer( 'lottie_target_78', '../../examples/precomp/star-nocomp.json', true, {} ); And the same animation but using a precomp: var lottie_player_79 = new LottiePlayer( 'lottie_target_79', '../../examples/precomp/star-comp.json', true, {} ); Now let's have a look at how the JSON changed: This is the original animation, nothing special about it: { \"nm\": \"Animation\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [ { \"nm\": \"Shape Layer\", \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"ks\": {}, \"shapes\": [/* ... */] } ] } And this is the version using a precomposition: { \"nm\": \"Animation\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [ { \"id\": \"Star\", \"layers\": [ { \"nm\": \"Shape Layer\", \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"shapes\": [/* ... */] } ] } ], \"layers\": [ { \"nm\": \"Precomp Layer\", \"refId\": \"Star\" \"ty\": 0, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {} } ], } As you can see, the layers in the original animation have been moved to an asset (in this example there was only one layer but it works the same when you have multiple layer). And in layers of the outer animation there is a single layer referencing the new asset. The structure of the asset is fairly straightforward: a unique identifier ( Star in the example) and the list of layers in the precomposition. The layer has the usual attributes you can find on visual layers and a couple others: refId is the identifier of the precomp the layer is referencing, w and h define the clipping rectangle for the composition, in this case they match the value in the outer animation.","title":"How do Precompositions work in a Lottie?"},{"location":"breakdown/precomps/#important-things-to-note","text":"A precomp doesn't contain assets, but it can reference assets defined in the main animation object. It can also reference other precomps. Layer indexes are unique in each composition: you can have a layer with index 0 in multiple precomps and in the main animation, references to these (such as when parenting layers) are relative to the composition. You need to always specify w and h in the precomp layer or nothing will be displayed.","title":"Important things to note"},{"location":"breakdown/precomps/#what-can-you-do-with-precompositions","text":"In this section we'll describe some example use case including the initial animations and the result to compare how a file needs to be changed to obtain certain effects.","title":"What can you do with Precompositions?"},{"location":"breakdown/precomps/#resizing","text":"If you need to resize an animation, the best way of doing it is by precomposing all its layers and then scale the precomp layer. While for simple examples you'd might be able to get away with scaling all the layers in the original animation, it gets complicated if you have parented layers or transforms applied to some of the layers. Note that in the example below w and h keep their initial value and only the scale is changed. Scale 50 Show JSON var lottie_player_71 = new PlaygroundPlayer( 71, 'playground_71_2', 'lottie_target_71', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 60, \"nm\": \"Animation\", \"mn\": \"{0b14b755-3d9e-4f7f-b7ab-21cd57d13e23}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [{\"id\": \"Star\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Shape Layer\", \"mn\": \"{4d57cabf-951f-4067-b50e-8307f9f5fe72}\", \"ks\": {}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{c99b4a89-363b-4cd3-8797-bf65b57fdd29}\", \"d\": 1, \"p\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [256, 256], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0, 0]}]}, \"or\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"ir\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"is\": {\"a\": 0, \"k\": 0}, \"os\": {\"a\": 0, \"k\": 0}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{eb7fbdff-0656-41f5-9337-3aa283dde263}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 6}, \"c\": {\"a\": 0, \"k\": [1, 0.3411764705882353, 0.01568627450980392]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{54bfe210-7450-4824-accc-eef8f6c48ae8}\", \"o\": {\"a\": 0, \"k\": 100}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}}]}]}], \"layers\": [{\"ddd\": 0, \"ty\": 0, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"nm\": \"Precomp Layer\", \"ks\": {}, \"refId\": \"Star\"}], \"meta\": {\"g\": \"Glaxnimate 0.5.0-93-g187709f5\"}}, function (lottie, data) { lottie.w = lottie.h = 512 * data[\"Scale\"] / 100; lottie.layers[0].ks.s = { a: 0, k: [ data[\"Scale\"], data[\"Scale\"] ] };this.json_viewer_contents = {...lottie, assets:[\"...\"]}; }, {} );","title":"Resizing"},{"location":"breakdown/precomps/#speeding-up-and-slowing-down","text":"Similarly, you can use time stretch to speed up and slow down an animation: Speed 50 Show JSON var lottie_player_72 = new PlaygroundPlayer( 72, 'playground_72_2', 'lottie_target_72', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 60, \"nm\": \"Animation\", \"mn\": \"{0b14b755-3d9e-4f7f-b7ab-21cd57d13e23}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [{\"id\": \"Star\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Shape Layer\", \"mn\": \"{4d57cabf-951f-4067-b50e-8307f9f5fe72}\", \"ks\": {}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{c99b4a89-363b-4cd3-8797-bf65b57fdd29}\", \"d\": 1, \"p\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [256, 256], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0, 0]}]}, \"or\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"ir\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"is\": {\"a\": 0, \"k\": 0}, \"os\": {\"a\": 0, \"k\": 0}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{eb7fbdff-0656-41f5-9337-3aa283dde263}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 6}, \"c\": {\"a\": 0, \"k\": [1, 0.3411764705882353, 0.01568627450980392]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{54bfe210-7450-4824-accc-eef8f6c48ae8}\", \"o\": {\"a\": 0, \"k\": 100}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}}]}]}], \"layers\": [{\"ddd\": 0, \"ty\": 0, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"nm\": \"Precomp Layer\", \"ks\": {}, \"refId\": \"Star\"}], \"meta\": {\"g\": \"Glaxnimate 0.5.0-93-g187709f5\"}}, function (lottie, data) { var time_mult = 100 / data[\"Speed\"]; lottie.op = 60 * time_mult; lottie.layers[0].op = 60 * time_mult; lottie.layers[0].sr = time_mult;this.json_viewer_contents = {...lottie, assets:[\"...\"]}; }, {} ); You can also change the start time to delay the start of the precomp playback: Start 30 Speed 50 Show JSON var lottie_player_73 = new PlaygroundPlayer( 73, 'playground_73_3', 'lottie_target_73', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 60, \"nm\": \"Animation\", \"mn\": \"{0b14b755-3d9e-4f7f-b7ab-21cd57d13e23}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [{\"id\": \"Star\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Shape Layer\", \"mn\": \"{4d57cabf-951f-4067-b50e-8307f9f5fe72}\", \"ks\": {}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{c99b4a89-363b-4cd3-8797-bf65b57fdd29}\", \"d\": 1, \"p\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [256, 256], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0, 0]}]}, \"or\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"ir\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"is\": {\"a\": 0, \"k\": 0}, \"os\": {\"a\": 0, \"k\": 0}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{eb7fbdff-0656-41f5-9337-3aa283dde263}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 6}, \"c\": {\"a\": 0, \"k\": [1, 0.3411764705882353, 0.01568627450980392]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{54bfe210-7450-4824-accc-eef8f6c48ae8}\", \"o\": {\"a\": 0, \"k\": 100}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}}]}]}], \"layers\": [{\"ddd\": 0, \"ty\": 0, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"nm\": \"Precomp Layer\", \"ks\": {}, \"refId\": \"Star\"}], \"meta\": {\"g\": \"Glaxnimate 0.5.0-93-g187709f5\"}}, function (lottie, data) { var time_mult = 100 / data[\"Speed\"]; var start = data[\"Start\"]; lottie.op = 60 * time_mult + start; lottie.layers[0].op = 60 * time_mult + start; lottie.layers[0].sr = time_mult; lottie.layers[0].st = start;this.json_viewer_contents = {...lottie, assets:[\"...\"]}; }, {} );","title":"Speeding up and Slowing down"},{"location":"breakdown/precomps/#reversing-playback","text":"While sr only allows you to speed up and slow down time, with time remapping You can have more interesting effects, such as reversing playback: Show JSON var lottie_player_74 = new PlaygroundPlayer( 74, 'playground_74_1', 'lottie_target_74', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 60, \"nm\": \"Animation\", \"mn\": \"{0b14b755-3d9e-4f7f-b7ab-21cd57d13e23}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [{\"id\": \"Star\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Shape Layer\", \"mn\": \"{4d57cabf-951f-4067-b50e-8307f9f5fe72}\", \"ks\": {}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{c99b4a89-363b-4cd3-8797-bf65b57fdd29}\", \"d\": 1, \"p\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [256, 256], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0, 0]}]}, \"or\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"ir\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"is\": {\"a\": 0, \"k\": 0}, \"os\": {\"a\": 0, \"k\": 0}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{eb7fbdff-0656-41f5-9337-3aa283dde263}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 6}, \"c\": {\"a\": 0, \"k\": [1, 0.3411764705882353, 0.01568627450980392]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{54bfe210-7450-4824-accc-eef8f6c48ae8}\", \"o\": {\"a\": 0, \"k\": 100}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}}]}]}], \"layers\": [{\"ddd\": 0, \"ty\": 0, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"nm\": \"Precomp Layer\", \"ks\": {}, \"refId\": \"Star\"}], \"meta\": {\"g\": \"Glaxnimate 0.5.0-93-g187709f5\"}}, function (lottie, data) { lottie.layers[0].tm = { a: 1, \"k\": [ { \"t\": 0, \"s\": [1], \"o\": { \"x\": 0, \"y\": 0}, \"i\": { \"x\": 1, \"y\": 1} }, { \"t\": 60, \"s\": [0], \"o\": { \"x\": 0, \"y\": 0}, \"i\": { \"x\": 1, \"y\": 1} } ] };this.json_viewer_contents = {...lottie, assets:[\"...\"]}; }, {} );","title":"Reversing Playback"},{"location":"breakdown/precomps/#repeated-elements","text":"Another important use for precomps is that they allow to have multiple layers showing the same precomp. In the following example the star is animated once but there are 8 precomp layers with different rotations: var lottie_player_80 = new LottiePlayer( 'lottie_target_80', '../../examples/precomp/star-splosion.json', true, {} );","title":"Repeated Elements"},{"location":"breakdown/precomps/#overlaying-animations","text":"Precomps also make it easier to combine multiple files into ones. One thing to keep in mind is if the two files already have assets, you need to ensure their asset identifier are unique, this can be done by overwriting asset id and layer refId properties to some kind of incremental values. In the following example we will overlay the animation from the last example with a different animation. First Animation: var lottie_player_81 = new LottiePlayer( 'lottie_target_81', '../../examples/precomp/star-splosion.json', true, {} ); Second Animation: var lottie_player_82 = new LottiePlayer( 'lottie_target_82', '../../examples/precomp/circle.json', true, {} ); Overlaid: Show JSON var lottie_player_75 = new PlaygroundPlayer( 75, 'playground_75_1', 'lottie_target_75', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 60, \"nm\": \"Animation\", \"mn\": \"{0b14b755-3d9e-4f7f-b7ab-21cd57d13e23}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [{\"id\": \"Star\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Shape Layer\", \"mn\": \"{4d57cabf-951f-4067-b50e-8307f9f5fe72}\", \"ks\": {}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{c99b4a89-363b-4cd3-8797-bf65b57fdd29}\", \"d\": 1, \"p\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [256, 256], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0, 0]}]}, \"or\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"ir\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"is\": {\"a\": 0, \"k\": 0}, \"os\": {\"a\": 0, \"k\": 0}, \"r\": {\"a\": 0, \"k\": -45}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{eb7fbdff-0656-41f5-9337-3aa283dde263}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 6}, \"c\": {\"a\": 0, \"k\": [1, 0.3411764705882353, 0.01568627450980392]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{54bfe210-7450-4824-accc-eef8f6c48ae8}\", \"o\": {\"a\": 0, \"k\": 100}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}}]}]}, {\"id\": \"Expanding Stars\", \"layers\": [{\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 0}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 45}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 90}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 135}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 180}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": -45}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": -90}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": -135}}}]}, {\"id\": \"Circle\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Layer\", \"mn\": \"{456fdfe5-686b-4006-92f4-951c47ab4bc7}\", \"ks\": {}, \"shapes\": [{\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{05d5f1a0-6046-4aea-a405-b9ba60a24bd7}\", \"d\": 1, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0, 0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [730, 730]}]}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{d835adb4-6502-4e3e-98c2-70d1145f1a23}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [6], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"c\": {\"a\": 0, \"k\": [0.11372549019607843, 0.1568627450980392, 0.2823529411764706]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{78036603-40f1-42ca-ada5-fee506b4ac58}\", \"o\": {\"a\": 1, \"k\": [{\"t\": 30, \"s\": [100], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}}]}]}], \"layers\": [{\"nm\": \"Expanding Stars Layer\", \"refId\": \"Expanding Stars\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {}}, {\"nm\": \"Circle Layer\", \"refId\": \"Circle\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {}}]}, function (lottie, data) { this.json_viewer_contents = {...lottie, assets:[\"...\"]}; }, {} ); If you look at the JSON you'll notice that this is how the structure changed: // First Animation: { \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [ { \"id\": \"Star\", \"layers\": [ /* Star Precomp Layers */ ] } ], \"layers\": [ /* First Animation Layers */ ] } // Second Animation { \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [ /* Second Animation Layers */ ] } // Overlaid { \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [ { \"id\": \"Star\", \"layers\": [ /* Star Precomp Layers */ ] }, { \"id\": \"Expanding Stars\", \"layers\": [ /* First Animation Layers */ ] }, { \"id\": \"Circle\", \"layers\": [ /* Second Animation Layers */ ] } ], \"layers\": [ { \"nm\": \"Expanding Stars Layer\", \"refId\": \"Expanding Stars\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {} }, { \"nm\": \"Circle Layer\", \"refId\": \"Circle\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {} } ] } In this example the two animations had the same duration and size, you can use the techniques described earlier to resize or retime the animations if you want to overlay animations with different sizes or durations.","title":"Overlaying Animations"},{"location":"breakdown/precomps/#concatenating-animations","text":"This works basically the same as overlaying them, just by changing some timing properties in the precomp layers. Show JSON var lottie_player_76 = new PlaygroundPlayer( 76, 'playground_76_1', 'lottie_target_76', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 60, \"nm\": \"Animation\", \"mn\": \"{0b14b755-3d9e-4f7f-b7ab-21cd57d13e23}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [{\"id\": \"Star\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Shape Layer\", \"mn\": \"{4d57cabf-951f-4067-b50e-8307f9f5fe72}\", \"ks\": {}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{c99b4a89-363b-4cd3-8797-bf65b57fdd29}\", \"d\": 1, \"p\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [256, 256], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0, 0]}]}, \"or\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"ir\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"is\": {\"a\": 0, \"k\": 0}, \"os\": {\"a\": 0, \"k\": 0}, \"r\": {\"a\": 0, \"k\": -45}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{eb7fbdff-0656-41f5-9337-3aa283dde263}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 6}, \"c\": {\"a\": 0, \"k\": [1, 0.3411764705882353, 0.01568627450980392]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{54bfe210-7450-4824-accc-eef8f6c48ae8}\", \"o\": {\"a\": 0, \"k\": 100}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}}]}]}, {\"id\": \"Expanding Stars\", \"layers\": [{\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 0}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 45}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 90}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 135}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 180}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": -45}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": -90}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": -135}}}]}, {\"id\": \"Circle\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Layer\", \"mn\": \"{456fdfe5-686b-4006-92f4-951c47ab4bc7}\", \"ks\": {}, \"shapes\": [{\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{05d5f1a0-6046-4aea-a405-b9ba60a24bd7}\", \"d\": 1, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0, 0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [730, 730]}]}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{d835adb4-6502-4e3e-98c2-70d1145f1a23}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [6], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"c\": {\"a\": 0, \"k\": [0.11372549019607843, 0.1568627450980392, 0.2823529411764706]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{78036603-40f1-42ca-ada5-fee506b4ac58}\", \"o\": {\"a\": 1, \"k\": [{\"t\": 30, \"s\": [100], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}}]}]}], \"layers\": [{\"nm\": \"Expanding Stars Layer\", \"refId\": \"Expanding Stars\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {}}, {\"nm\": \"Circle Layer\", \"refId\": \"Circle\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {}}]}, function (lottie, data) { lottie.op = 120 lottie.layers[1].ip = 60; lottie.layers[1].op = 120; lottie.layers[1].st = 60;this.json_viewer_contents = {...lottie, assets:[\"...\"]}; }, {} );","title":"Concatenating Animations"},{"location":"breakdown/precomps/#masking-animations","text":"Just like any other visual layer, precomp layers can be used for mattes . Show JSON var lottie_player_77 = new PlaygroundPlayer( 77, 'playground_77_1', 'lottie_target_77', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 60, \"nm\": \"Animation\", \"mn\": \"{0b14b755-3d9e-4f7f-b7ab-21cd57d13e23}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [{\"id\": \"Star\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Shape Layer\", \"mn\": \"{4d57cabf-951f-4067-b50e-8307f9f5fe72}\", \"ks\": {}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{c99b4a89-363b-4cd3-8797-bf65b57fdd29}\", \"d\": 1, \"p\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [256, 256], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0, 0]}]}, \"or\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"ir\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"is\": {\"a\": 0, \"k\": 0}, \"os\": {\"a\": 0, \"k\": 0}, \"r\": {\"a\": 0, \"k\": -45}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{eb7fbdff-0656-41f5-9337-3aa283dde263}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 6}, \"c\": {\"a\": 0, \"k\": [1, 0.3411764705882353, 0.01568627450980392]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{54bfe210-7450-4824-accc-eef8f6c48ae8}\", \"o\": {\"a\": 0, \"k\": 100}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}}]}]}, {\"id\": \"Expanding Stars\", \"layers\": [{\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 0}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 45}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 90}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 135}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 180}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": -45}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": -90}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": -135}}}]}, {\"id\": \"Circle\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Layer\", \"mn\": \"{456fdfe5-686b-4006-92f4-951c47ab4bc7}\", \"ks\": {}, \"shapes\": [{\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{05d5f1a0-6046-4aea-a405-b9ba60a24bd7}\", \"d\": 1, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0, 0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [730, 730]}]}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{d835adb4-6502-4e3e-98c2-70d1145f1a23}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [6], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"c\": {\"a\": 0, \"k\": [0.11372549019607843, 0.1568627450980392, 0.2823529411764706]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{78036603-40f1-42ca-ada5-fee506b4ac58}\", \"o\": {\"a\": 1, \"k\": [{\"t\": 30, \"s\": [100], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}}]}]}], \"layers\": [{\"nm\": \"Expanding Stars Layer\", \"refId\": \"Expanding Stars\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {}}, {\"nm\": \"Circle Layer\", \"refId\": \"Circle\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {}}]}, function (lottie, data) { lottie.layers[0].td = 1; lottie.layers[1].tt = 1;this.json_viewer_contents = {...lottie, assets:[\"...\"]}; }, {} );","title":"Masking Animations"},{"location":"playground/builder/","text":"html, body { min-height: 100vh; } body { display: flex; flex-flow: column; } div[role='main'], body > .container, #playground_layout { width: 100%; height: 100%; padding: 0; margin: 0; flex-grow: 1; display: flex; flex-flow: column; } #playground_layout { display: flex; flex-flow: row; align-items: stretch; padding: 24px } #blockly_div { flex-grow: 1; } #playground_output_container { width: 512px; } #lottie_player { width: 512px; height: 512px } #playground_output { margin: 0; width: 512px; display: flex; flex-flow: column; } #blockly_output { margin: 0; overflow: auto; flex-grow: 1; border: none; } #playground_output_buttons { padding: 0; list-style: none; display: flex; margin-bottom: 0px; } #playground_output_buttons > li > button { border: 1px solid #D9E0E6; padding: 8px; } Save Load Clear Copy JSON Load from URL function save() { localStorage.setItem(\"blockly_lottie\", lottie_blockly.workspace_to_xml_string()); } function load() { lottie_blockly.xml_to_workspace(localStorage.getItem(\"blockly_lottie\")); } function update_code() { var json = lottie_blockly.workspace_to_json(); var output = document.getElementById(\"blockly_output\"); output.value = JSON.stringify(json, null, 4); syntax_edit_update(output, output.value); var anim_data = { container: document.getElementById('lottie_player'), renderer: 'svg', loop: true, autoplay: true, animationData: JSON.parse(output.value) }; var frame = 0; if ( anim != null ) { try { frame = anim.currentFrame } catch (e) {} try { anim.destroy(); } catch (e) {} anim = null; } anim = bodymovin.loadAnimation(anim_data); if ( frame != 0 ) anim.goToAndPlay(frame, true); } function copy_json() { var element = document.getElementById(\"blockly_output\"); var text = element.value; navigator.clipboard.writeText(text); } function copy_xml() { navigator.clipboard.writeText(lottie_blockly.workspace_to_xml_string()); } function parse_json() { lottie_blockly.json_to_workspace(document.getElementById(\"blockly_output\").value); } function load_url_prompt() { var url = prompt(\"URL to a lottie JSON\"); if ( url ) lottie_blockly.load_json_url(url) } var options = { comments: true, toolbox: lottie_toolbox, media: 'https://unpkg.com/blockly/media/', collapse: true, }; var anim = null; var lottie_blockly = new LottieBlockly(options, \"blockly_div\", alert); lottie_blockly.workspace.addChangeListener(update_code); var current_url = new URL(window.location.href); var requested_url = current_url.searchParams.get(\"url\"); if ( requested_url ) lottie_blockly.load_json_url(requested_url); else load();","title":"Builder"},{"location":"playground/json_editor/","text":"import { DotLottie } from \"https://unpkg.com/@lottiefiles/dotlottie-web@0.23.2/dist/index.js\" window.DotLottie = DotLottie; Loading... File New Load from URL... Open File... Load Saved Save Download Edit Undo Redo Search by JSON... Find/Replace... Go to Line... Prettify JSON Lottie View Issues... Go to Next Issue View Lottie Features... View Toggle Wide Layout Preview Background... Renderer lottie-web SVG lottie-web Canvas DotLottie Help View Keyboard Shortcuts Fit in View Normal View Upload File \u00d7 Drop JSON file here Cancel Load from URL \u00d7 Cancel Load Key bindings \u00d7 Close Lottie Features \u00d7 Close function input_error(e, safe = false) { error_container.style.display = \"block\"; loading_div.style.display = \"none\"; clear_element(error_container); error_container.appendChild(document.createTextNode(safe ? e : \"Could not load input!\")); console.error(e); } function input_start() { error_container.style.display = \"none\"; loading_div.style.display = \"block\"; } function lottie_file_input(ev) { input_start(); lottie_receive_files(ev.target.files); } function lottie_receive_files(files) { for ( var i = 0; i < files.length; i++ ) { var file = files[i]; if ( file.type.match(\"application/json\") ) { var reader = new FileReader(); reader.onload = function(e2) { lottie_string_input(e2.target.result, true); document.getElementById(\"dismiss_file_modal\").click(); }; reader.readAsText(file); return; } } input_error(\"Not a JSON file\", true); } function lottie_drop_input(ev) { ev.preventDefault(); if (ev.dataTransfer.items) { input_start(); lottie_receive_files( Array.from(ev.dataTransfer.items) .filter(i => i.kind === 'file') .map(i => i.getAsFile()) ); } } function lottie_url_input(url) { input_start(); fetch(url) .then(r => r.json()) .then(set_editor_json) .catch(input_error); } function set_editor_json(data) { lottie_string_input(JSON.stringify(data, undefined, 4)); } function attach_listener() { lottie_player.anim.addEventListener(\"enterFrame\", (ev) => { frame_slider.value = frame_edit.value = Math.round(lottie_player.anim.currentFrame); }); } function switch_renderer(renderer) { lottie_player.switch_renderer(renderer); attach_listener(); } function on_lottie_update(lottie) { worker.update(lottie); lottie_player.lottie = lottie; frame_slider.min = frame_edit.min = lottie.ip; frame_slider.max = frame_edit.max = lottie.op; lottie_player.reload(); frame_slider.value = frame_edit.value = Math.round(lottie_player.anim.currentFrame); attach_listener(); } function update_frame(value) { value = Number(value); if ( value != Math.round(lottie_player.anim.currentFrame) ) lottie_player.go_to_frame(value); } function pretty() { set_editor_json(lottie_player.lottie); } function lottie_string_input(data, auto_prettify = false) { if ( auto_prettify && data.split(\"\\n\").length < 3 ) { try { data = JSON.parse(data); data = JSON.stringify(data, undefined, 4); } catch (e) {} } editor.set_content(data); error_container.style.display = \"none\"; loading_div.style.display = \"none\"; } function inspect_tree(node) { let children = []; let name = node.name; if ( node.firstChild() ) { while ( true ) { children.push(inspect_tree(node)); if ( !node.nextSibling() ) break; } node.parent() } return { [name]: children }; } function action_save() { localStorage.setItem(\"editor_lottie\", JSON.stringify(lottie_player.lottie)); } function action_load() { set_editor_json(JSON.parse(localStorage.getItem(\"editor_lottie\"))); } function action_new() { set_editor_json({ \"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [], \"fonts\": { \"list\": [] }, \"layers\": [] }); } function action_download() { download_json(lottie_player.lottie, \"lottie.json\"); } function toggle_playback(button) { if ( lottie_player.autoplay ) { lottie_player.pause(); button.title = \"Play\"; button.firstElementChild.setAttribute(\"class\", \"fa-solid fa-play\"); } else { lottie_player.play(); button.title = \"Pause\"; button.firstElementChild.setAttribute(\"class\", \"fa-solid fa-pause\"); } } function toggle_playback_controls() { if ( frame_slider.style.display == \"none\" ) { frame_slider.style.display = \"block\"; frame_edit.style.display = \"block\"; } else { frame_slider.style.display = \"none\"; frame_edit.style.display = \"none\"; } } function refresh_features() { let parent = document.getElementById(\"features_container\"); clear_element(parent); let features = get_features(editor.completions.validation_result); let has_something = false; for ( let what of [\"Layers\", \"Shapes\"] ) { let attr = what.toLowerCase(); if ( features[attr].length ) { has_something = true; parent.appendChild(document.createElement(\"h6\")).appendChild(document.createTextNode(what)); let list = parent.appendChild(document.createElement(\"ul\")); for ( let lay of features[attr] ) { let li = list.appendChild(document.createElement(\"li\")); for ( link of get_validation_links(lay, editor.schema) ) { li.appendChild(link.to_element()); li.appendChild(document.createTextNode(\" \")); } } } } if ( features.features.size ) { has_something = true; parent.appendChild(document.createElement(\"h6\")).appendChild(document.createTextNode(\"Features\")); let list = parent.appendChild(document.createElement(\"ul\")); for ( let feature of features.features ) { let link = list.appendChild(document.createElement(\"li\")).appendChild(document.createElement(\"a\")); link.setAttribute(\"href\", \"https://canilottie.com/\" + feature); link.appendChild(document.createTextNode( feature.split(\"-\").map(f => f[0].toUpperCase() + f.slice(1)).join(\" \") )); } } if ( !has_something ) { parent.appendChild(document.createElement(\"p\")).appendChild(document.createTextNode(\"None Found\")); } } let expr_variables = [\"$bm_rt\", \"time\", \"value\", \"thisProperty\", \"thisComp\", \"thisLayer\"]; let expr_funcs = [\"comp\", \"posterizeTime\", \"timeToFrames\", \"framesToTime\", \"rgbToHsl\", \"hslToRgb\", \"createPath\", \"add\", \"sub\", \"mul\", \"div\", \"mod\", \"clamp\", \"normalize\", \"length\", \"lookAt\", \"seedRandom\", \"random\", \"linear\", \"ease\", \"easeIn\", \"easeOut\", \"degreesToRadians\", \"radiansToDegrees\", \"$bm_sum\", \"sum\", \"$bm_sub\", \"$bm_div\" ]; let frame_slider = document.getElementById(\"frame_slider\"); let frame_edit = document.getElementById(\"frame_edit\"); let editor = new LottieJsonEditor( document.getElementById(\"editor_parent\"), document.getElementById(\"info_box\"), on_lottie_update ); const search_by_json_cmd = search_by_json_factory(); let worker = new LottieJsonWorker(); worker.on(\"schema_loaded\", (data) => { editor.set_schema(Object.assign(new SchemaData(), data.schema)); editor.expression_completions.load_completions(data.expressions) if ( lottie_player.lottie ) worker.update(lottie_player.lottie); }); worker.on(\"result\", data => editor.end_load(data.result)); document.body.addEventListener(\"click\", e => { if ( !e.target.closest(\".info_box_trigger\") && !editor.info_box.element.contains(e.target) ) { editor.hide_info_box_tooltip(); } }); var lottie_player = new LottiePlayer(\"lottie_target\", undefined); let error_container = document.getElementById(\"error_alert\"); let loading_div = document.getElementById(\"loading_alert\"); var data = playground_get_data(); if ( data ) { if ( data[0] == \"{\" ) lottie_string_input(data, true); else lottie_url_input(data); } else if (window.location.search != '' ) { let url = (new URL(window.location)).searchParams.get(\"url\"); if ( url ) lottie_url_input(url); } else { action_new(); } let key_bindings_parent = document.getElementById(\"key_bindings\"); let platform = \"linux\"; let mod = \"Ctrl\"; if ( navigator.platform.indexOf(\"Mac\") != -1 ) { platform = \"mac\"; mode = \"Cmd\"; } else if ( navigator.platform.indexOf(\"Win\") != -1 ) { platform = \"win\"; } for ( arr of editor.view.state.field(CodeMirrorWrapper.keymap) ) { for ( key of arr ) { let seq = key[platform] ?? key.key; if ( seq && key.run.name ) { let row = key_bindings.appendChild(document.createElement(\"tr\")); row.appendChild(document.createElement(\"th\")) .appendChild(document.createTextNode(seq.replace(\"Mod\", mod))); let cmd = key.run.name.replace(/[A-Z]/g, l => \" \" + l) .replace(/^[a-z]/, l => l.toUpperCase()); row.appendChild(document.createElement(\"td\")) .appendChild(document.createTextNode(cmd)); } } }","title":"JSON Editor"}]}